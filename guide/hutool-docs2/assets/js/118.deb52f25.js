(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{446:function(a,e,t){"use strict";t.r(e);var c=t(7),h=Object(c.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"来源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#来源"}},[a._v("#")]),a._v(" 来源")]),a._v(" "),e("p",[a._v("Hutool-cache模块最早受到jodd-cache的启发（如今大部分逻辑依旧与jodd保持一致），此模块提供一种缓存的简单实现方案，在小型项目中对于简单的缓存需求非常好用。")]),a._v(" "),e("h2",{attrs:{id:"介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[a._v("#")]),a._v(" 介绍")]),a._v(" "),e("p",[a._v("Hutoo-cache模块提供了几种缓存策略实现：")]),a._v(" "),e("h3",{attrs:{id:"fifocache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fifocache"}},[a._v("#")]),a._v(" FIFOCache")]),a._v(" "),e("p",[a._v("FIFO(first in first out) 先进先出策略。元素不停的加入缓存直到缓存满为止，当缓存满时，清理过期缓存对象，清理后依旧满则删除先入的缓存（链表首部对象）。")]),a._v(" "),e("p",[a._v("优点：简单快速"),e("br"),a._v("\n缺点：不灵活，不能保证最常用的对象总是被保留")]),a._v(" "),e("h3",{attrs:{id:"lfucache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lfucache"}},[a._v("#")]),a._v(" LFUCache")]),a._v(" "),e("p",[a._v("LFU(least frequently used) 最少使用率策略。根据使用次数来判定对象是否被持续缓存（使用率是通过访问次数计算），当缓存满时清理过期对象，清理后依旧满的情况下清除最少访问（访问计数最小）的对象并将其他对象的访问数减去这个最小访问数，以便新对象进入后可以公平计数。")]),a._v(" "),e("h3",{attrs:{id:"lrucache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lrucache"}},[a._v("#")]),a._v(" LRUCache")]),a._v(" "),e("p",[a._v("LRU (least recently used)最近最久未使用缓存。根据使用时间来判定对象是否被持续缓存，当对象被访问时放入缓存，当缓存满了，最久未被使用的对象将被移除。此缓存基于LinkedHashMap，因此当被缓存的对象每被访问一次，这个对象的key就到链表头部。这个算法简单并且非常快，他比FIFO有一个显著优势是经常使用的对象不太可能被移除缓存。缺点是当缓存满时，不能被很快的访问。")]),a._v(" "),e("h3",{attrs:{id:"timedcache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#timedcache"}},[a._v("#")]),a._v(" TimedCache")]),a._v(" "),e("p",[a._v("定时缓存，对被缓存的对象定义一个过期时间，当对象超过过期时间会被清理。此缓存没有容量限制，对象只有在过期后才会被移除")]),a._v(" "),e("h3",{attrs:{id:"weakcache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#weakcache"}},[a._v("#")]),a._v(" WeakCache")]),a._v(" "),e("p",[a._v("弱引用缓存。对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除。该类使用了WeakHashMap做为其实现，缓存的清理依赖于JVM的垃圾回收。")]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"filecach"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#filecach"}},[a._v("#")]),a._v(" FileCach")]),a._v(" "),e("p",[a._v("FileCach是一个独立的缓存，主要是将小文件以byte[]的形式缓存到内容中，减少文件的访问，以解决频繁读取文件引起的性能问题。")]),a._v(" "),e("p",[a._v("主要实现有：")]),a._v(" "),e("ul",[e("li",[a._v("LFUFileCache")]),a._v(" "),e("li",[a._v("LRUFileCache")])])])}),[],!1,null,null,null);e.default=h.exports}}]);