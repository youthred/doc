(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(e){function t(t){for(var a,l,o=t[0],s=t[1],c=t[2],u=0,p=[];u<o.length;u++)l=o[u],Object.prototype.hasOwnProperty.call(r,l)&&r[l]&&p.push(r[l][0]),r[l]=0;for(a in s)Object.prototype.hasOwnProperty.call(s,a)&&(e[a]=s[a]);for(d&&d(t);p.length;)p.shift()();return i.push.apply(i,c||[]),n()}function n(){for(var e,t=0;t<i.length;t++){for(var n=i[t],a=!0,o=1;o<n.length;o++){var s=n[o];0!==r[s]&&(a=!1)}a&&(i.splice(t--,1),e=l(l.s=n[0]))}return e}var a={},r={1:0},i=[];function l(t){if(a[t])return a[t].exports;var n=a[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,l),n.l=!0,n.exports}l.e=function(e){var t=[],n=r[e];if(0!==n)if(n)t.push(n[2]);else{var a=new Promise((function(t,a){n=r[e]=[t,a]}));t.push(n[2]=a);var i,o=document.createElement("script");o.charset="utf-8",o.timeout=120,l.nc&&o.setAttribute("nonce",l.nc),o.src=function(e){return l.p+"assets/js/"+({}[e]||e)+"."+{2:"506aadd9",3:"80e9b84c",4:"db9306fb",5:"efcccfbe",6:"c46def83",7:"d7a15157",8:"5781ea2a",9:"b3e46a5e",10:"2dcb38a6",11:"390d1ada",12:"e5252996",13:"6edb229d",14:"f1f5581d",15:"e8e86f28",16:"a7382f38",17:"48975242",18:"2c2268d9",19:"544c00f4",20:"1587e751",21:"e6cde23f",22:"633eadf8",23:"c5ad6635",24:"b926f758",25:"1ba6e9df",26:"7d497226",27:"97d803dc",28:"984fbd17",29:"7927ef06",30:"e2da94e1",31:"d16320de",32:"92526b77",33:"2cd27194",34:"53141972",35:"7b884fb5",36:"9bd50a8c",37:"fae9d7d6",38:"491be769",39:"0692252d",40:"9c0f5b5a",41:"cf1d4877",42:"2188bcea",43:"d076c8dc",44:"5e4d96aa",45:"6e131efa",46:"d5a898c0",47:"cd7fed4a",48:"821004b3",49:"155e2d23",50:"55fbd8eb",51:"05499341",52:"70185059",53:"820c0678",54:"4cf09ced",55:"1c63864e",56:"6c0ad321",57:"b38d75cb",58:"fa05e008",59:"88e1e898",60:"d1d43c9c",61:"55ba91d1",62:"d8d81cec",63:"cc5897fd",64:"896c4f10",65:"f924b3a0",66:"a6a9791f",67:"4b3b9dc1",68:"7e2b29b9",69:"fb491816",70:"ecb3d47f",71:"1fb9e056",72:"c7b95fbc",73:"c446e88b",74:"c7528b77",75:"bf9db3b4",76:"ea6948df",77:"1c5933bd",78:"f80f2422",79:"e82486f5",80:"ca1255cb",81:"fa45ad0e",82:"7b15ef55",83:"62b93a39",84:"9b035a4b",85:"40c1b52d",86:"89ddf812",87:"b79fec29",88:"e99a1db5",89:"cb5db8b0",90:"e8945f60",91:"9206fbe3",92:"e7fd5509",93:"1b6f4f3f",94:"fed650a2",95:"5fccfe51",96:"3a8fadcf",97:"c5f66427",98:"428ae33e",99:"bc09843b",100:"c7ca6495",101:"8f7f43b4",102:"a96719f3",103:"77c45272",104:"0bedfb06",105:"eee08264",106:"4839cbe7",107:"62839741",108:"79fc894d",109:"7c497c9e",110:"5aa72e7e",111:"7b2c9181",112:"4f919e6c",113:"d21308fa",114:"d788076d",115:"bc14a9a4",116:"2a09469a",117:"1bbdf464",118:"deb52f25",119:"fe649608",120:"b7f60d9e",121:"f5c064d3",122:"f822bd08",123:"ab579dd6",124:"64248e89",125:"6efb51e8",126:"d7d6b673",127:"e4f1dd68",128:"3e705e77",129:"a3a8d545",130:"929065e4",131:"b92e2d45",132:"2d4f1485",133:"df76958d",134:"d5d98908",135:"336493dd",136:"ae090df7",137:"5d3e662c",138:"fdc8c0fa",139:"822f8160",140:"129de77c",141:"4f53e419",142:"4967d636",143:"440d499e",144:"581263bf",145:"c3a3b599",146:"7021a57b",147:"1fb48837",148:"bc5bed91",149:"2933338e",150:"c7446aa6",151:"211be761",152:"11842f68",153:"819d1ba4",154:"3d1de9c7",155:"a1a9fa7c",156:"3c6ba219",157:"4b41d4ec",158:"6447d314",159:"209df644",160:"33ac4d23",161:"948281ba",162:"e62493d1",163:"372922d7",164:"e79ba74e",165:"65f5b08f",166:"101f22ad",167:"75534c13",168:"f9ece822",169:"d63bf1c5",170:"23f2623b",171:"5c3fa82a",172:"89907e49",173:"ee4f1f98",174:"853fcf8f",175:"6623a38d",176:"411241e6",177:"57d64dc7",178:"cf0a80ab",179:"8dbe2525",180:"54d13dfa",181:"f7115b90",182:"fa0c99d9",183:"d9ba63da",184:"3e296b61",185:"12e0ae59",186:"f308088b",187:"9ef781ef",188:"aa415653",189:"d9f734df",190:"ba3918af",191:"0307c88d",192:"303ae1da",193:"e9ea6df9",194:"6ff3b4c6",195:"1cb5b7b1",196:"655e421b",197:"c7b5ae81",198:"904b60ec",199:"845bfadb",200:"b7005af4",201:"b73e5f80",202:"e8be4687",203:"11ac1fb8",204:"711bddda",205:"f41a5baa",206:"f178b95d",207:"8add5972",208:"38d3fbbe",209:"95e9890c",210:"2974f18a",211:"938a1669",212:"d5b4dca4",213:"2ace6051",214:"bc6e1d06",215:"6c7d607f",216:"dc2201a2",217:"cb09279b",218:"dc2613d7",219:"a2310a48",220:"aaf434f0",221:"3abe8a6f",222:"2ffdbea3",223:"0fb31557",224:"6cdcfc73"}[e]+".js"}(e);var s=new Error;i=function(t){o.onerror=o.onload=null,clearTimeout(c);var n=r[e];if(0!==n){if(n){var a=t&&("load"===t.type?"missing":t.type),i=t&&t.target&&t.target.src;s.message="Loading chunk "+e+" failed.\n("+a+": "+i+")",s.name="ChunkLoadError",s.type=a,s.request=i,n[1](s)}r[e]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:o})}),12e4);o.onerror=o.onload=i,document.head.appendChild(o)}return Promise.all(t)},l.m=e,l.c=a,l.d=function(e,t,n){l.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},l.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},l.t=function(e,t){if(1&t&&(e=l(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(l.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)l.d(n,a,function(t){return e[t]}.bind(null,a));return n},l.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return l.d(t,"a",t),t},l.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},l.p="/",l.oe=function(e){throw console.error(e),e};var o=window.webpackJsonp=window.webpackJsonp||[],s=o.push.bind(o);o.push=t,o=o.slice();for(var c=0;c<o.length;c++)t(o[c]);var d=s;i.push([104,0]),n()}([function(e,t,n){"use strict";var a=function(e){return e&&e.Math===Math&&e};e.exports=a("object"==typeof globalThis&&globalThis)||a("object"==typeof window&&window)||a("object"==typeof self&&self)||a("object"==typeof global&&global)||a("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(e,t,n){"use strict";var a="object"==typeof document&&document.all;e.exports=void 0===a&&void 0!==a?function(e){return"function"==typeof e||e===a}:function(e){return"function"==typeof e}},function(e,t,n){"use strict";var a=n(27),r=Function.prototype,i=r.call,l=a&&r.bind.bind(i,i);e.exports=a?l:function(e){return function(){return i.apply(e,arguments)}}},function(e,t,n){"use strict";e.exports=function(e){try{return!!e()}catch(e){return!0}}},function(e,t,n){"use strict";var a=n(3);e.exports=!a((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(e,t){var n=Array.isArray;e.exports=n},function(e,t,n){var a=n(68),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();e.exports=i},function(e,t,n){"use strict";function a(e,t,n,a,r,i,l,o){var s,c="function"==typeof e?e.options:e;if(t&&(c.render=t,c.staticRenderFns=n,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),l?(s=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),r&&r.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(l)},c._ssrRegister=s):r&&(s=o?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),s)if(c.functional){c._injectStyles=s;var d=c.render;c.render=function(e,t){return s.call(t),d(e,t)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,s):[s]}return{exports:e,options:c}}n.d(t,"a",(function(){return a}))},function(e,t,n){"use strict";var a=n(1);e.exports=function(e){return"object"==typeof e?null!==e:a(e)}},function(e,t,n){"use strict";var a=n(2),r=n(32),i=a({}.hasOwnProperty);e.exports=Object.hasOwn||function(e,t){return i(r(e),t)}},function(e,t,n){var a=n(163),r=n(166);e.exports=function(e,t){var n=r(e,t);return a(n)?n:void 0}},function(e,t,n){"use strict";n.d(t,"e",(function(){return a})),n.d(t,"b",(function(){return i})),n.d(t,"j",(function(){return l})),n.d(t,"g",(function(){return s})),n.d(t,"h",(function(){return c})),n.d(t,"i",(function(){return d})),n.d(t,"c",(function(){return u})),n.d(t,"f",(function(){return p})),n.d(t,"l",(function(){return m})),n.d(t,"m",(function(){return h})),n.d(t,"d",(function(){return f})),n.d(t,"k",(function(){return v})),n.d(t,"n",(function(){return b})),n.d(t,"a",(function(){return x}));n(16);const a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,l=/^[a-z]+:/i;function o(e){return decodeURI(e).replace(a,"").replace(r,"")}function s(e){return l.test(e)}function c(e){return/^mailto:/.test(e)}function d(e){return/^tel:/.test(e)}function u(e){if(s(e))return e;if(!e)return"404";const t=e.match(a),n=t?t[0]:"",r=o(e);return i.test(r)?e:r+".html"+n}function p(e,t){const n=e.hash,r=function(e){const t=e&&e.match(a);if(t)return t[0]}(t);if(r&&n!==r)return!1;return o(e.path)===o(t)}function m(e,t,n){if(s(t))return{type:"external",path:t};n&&(t=function(e,t,n){const a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;const r=t.split("/");n&&r[r.length-1]||r.pop();const i=e.replace(/^\//,"").split("/");for(let e=0;e<i.length;e++){const t=i[e];".."===t?r.pop():"."!==t&&r.push(t)}""!==r[0]&&r.unshift("");return r.join("/")}(t,n));const a=o(t);for(let t=0;t<e.length;t++)if(o(e[t].regularPath)===a)return Object.assign({},e[t],{type:"page",path:u(e[t].path)});return console.error(`[vuepress] No matching page found for sidebar item "${t}"`),{}}function h(e,t,n,a){const{pages:r,themeConfig:i}=n,l=a&&i.locales&&i.locales[a]||i;if("auto"===(e.frontmatter.sidebar||l.sidebar||i.sidebar))return g(e);const o=l.sidebar||i.sidebar;if(o){const{base:n,config:a}=function(e,t){if(Array.isArray(t))return{base:"/",config:t};for(const a in t)if(0===(n=e,/(\.html|\/)$/.test(n)?n:n+"/").indexOf(encodeURI(a)))return{base:a,config:t[a]};var n;return{}}(t,o);return"auto"===a?g(e):a?a.map(e=>function e(t,n,a,r=1){if("string"==typeof t)return m(n,t,a);if(Array.isArray(t))return Object.assign(m(n,t[0],a),{title:t[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=t.children||[];return 0===i.length&&t.path?Object.assign(m(n,t.path,a),{title:t.title}):{type:"group",path:t.path,title:t.title,sidebarDepth:t.sidebarDepth,initialOpenGroupIndex:t.initialOpenGroupIndex,children:i.map(t=>e(t,n,a,r+1)),collapsable:!1!==t.collapsable}}}(e,r,n)):[]}return[]}function g(e){const t=f(e.headers||[]);return[{type:"group",collapsable:!1,title:e.title,path:null,children:t.map(t=>({type:"auto",title:t.title,basePath:e.path,path:e.path+"#"+t.slug,children:t.children||[]}))}]}function f(e){let t;return(e=e.map(e=>Object.assign({},e))).forEach(e=>{2===e.level?t=e:t&&(t.children||(t.children=[])).push(e)}),e.filter(e=>2===e.level)}function v(e){return Object.assign(e,{type:e.items&&e.items.length?"links":"link"})}function b(e){return Object.prototype.toString.call(e).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(e){let t=e.frontmatter.date||e.lastUpdated||new Date,n=new Date(t);return"Invalid Date"==n&&t&&(n=new Date(t.replace(/-/g,"/"))),n.getTime()}function x(e,t){return y(t)-y(e)}},function(e,t){e.exports=function(e){return null!=e&&"object"==typeof e}},function(e,t,n){var a=n(15),r=n(148),i=n(149),l=a?a.toStringTag:void 0;e.exports=function(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":l&&l in Object(e)?r(e):i(e)}},function(e,t,n){"use strict";var a=n(4),r=n(17),i=n(35);e.exports=a?function(e,t,n){return r.f(e,t,i(1,n))}:function(e,t,n){return e[t]=n,e}},function(e,t,n){var a=n(6).Symbol;e.exports=a},function(e,t,n){"use strict";var a=n(26),r=n(32),i=n(33),l=n(142),o=n(144);a({target:"Array",proto:!0,arity:1,forced:n(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(e){return e instanceof TypeError}}()},{push:function(e){var t=r(this),n=i(t),a=arguments.length;o(n+a);for(var s=0;s<a;s++)t[n]=arguments[s],n++;return l(t,n),n}})},function(e,t,n){"use strict";var a=n(4),r=n(63),i=n(99),l=n(25),o=n(54),s=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;t.f=a?i?function(e,t,n){if(l(e),t=o(t),l(n),"function"==typeof e&&"prototype"===t&&"value"in n&&"writable"in n&&!n.writable){var a=d(e,t);a&&a.writable&&(e[t]=n.value,n={configurable:"configurable"in n?n.configurable:a.configurable,enumerable:"enumerable"in n?n.enumerable:a.enumerable,writable:!1})}return c(e,t,n)}:c:function(e,t,n){if(l(e),t=o(t),l(n),r)try{return c(e,t,n)}catch(e){}if("get"in n||"set"in n)throw new s("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},function(e,t,n){"use strict";var a=n(2),r=a({}.toString),i=a("".slice);e.exports=function(e){return i(r(e),8,-1)}},function(e,t,n){var a=n(153),r=n(154),i=n(155),l=n(156),o=n(157);function s(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=r,s.prototype.get=i,s.prototype.has=l,s.prototype.set=o,e.exports=s},function(e,t,n){var a=n(70);e.exports=function(e,t){for(var n=e.length;n--;)if(a(e[n][0],t))return n;return-1}},function(e,t,n){var a=n(10)(Object,"create");e.exports=a},function(e,t,n){var a=n(175);e.exports=function(e,t){var n=e.__data__;return a(t)?n["string"==typeof t?"string":"hash"]:n.map}},function(e,t,n){var a=n(45);e.exports=function(e){if("string"==typeof e||a(e))return e;var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(e,t,n){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var e,t,n={version:"0.2.0"},a=n.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(e,t,n){return e<t?t:e>n?n:e}function i(e){return 100*(-1+e)}n.configure=function(e){var t,n;for(t in e)void 0!==(n=e[t])&&e.hasOwnProperty(t)&&(a[t]=n);return this},n.status=null,n.set=function(e){var t=n.isStarted();e=r(e,a.minimum,1),n.status=1===e?null:e;var s=n.render(!t),c=s.querySelector(a.barSelector),d=a.speed,u=a.easing;return s.offsetWidth,l((function(t){""===a.positionUsing&&(a.positionUsing=n.getPositioningCSS()),o(c,function(e,t,n){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(e)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(e)+"%,0)"}:{"margin-left":i(e)+"%"}).transition="all "+t+"ms "+n,r}(e,d,u)),1===e?(o(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){o(s,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){n.remove(),t()}),d)}),d)):setTimeout(t,d)})),this},n.isStarted=function(){return"number"==typeof n.status},n.start=function(){n.status||n.set(0);var e=function(){setTimeout((function(){n.status&&(n.trickle(),e())}),a.trickleSpeed)};return a.trickle&&e(),this},n.done=function(e){return e||n.status?n.inc(.3+.5*Math.random()).set(1):this},n.inc=function(e){var t=n.status;return t?("number"!=typeof e&&(e=(1-t)*r(Math.random()*t,.1,.95)),t=r(t+e,0,.994),n.set(t)):n.start()},n.trickle=function(){return n.inc(Math.random()*a.trickleRate)},e=0,t=0,n.promise=function(a){return a&&"resolved"!==a.state()?(0===t&&n.start(),e++,t++,a.always((function(){0==--t?(e=0,n.done()):n.set((e-t)/e)})),this):this},n.render=function(e){if(n.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var t=document.createElement("div");t.id="nprogress",t.innerHTML=a.template;var r,l=t.querySelector(a.barSelector),s=e?"-100":i(n.status||0),d=document.querySelector(a.parent);return o(l,{transition:"all 0 linear",transform:"translate3d("+s+"%,0,0)"}),a.showSpinner||(r=t.querySelector(a.spinnerSelector))&&p(r),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(t),t},n.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(a.parent),"nprogress-custom-parent");var e=document.getElementById("nprogress");e&&p(e)},n.isRendered=function(){return!!document.getElementById("nprogress")},n.getPositioningCSS=function(){var e=document.body.style,t="WebkitTransform"in e?"Webkit":"MozTransform"in e?"Moz":"msTransform"in e?"ms":"OTransform"in e?"O":"";return t+"Perspective"in e?"translate3d":t+"Transform"in e?"translate":"margin"};var l=function(){var e=[];function t(){var n=e.shift();n&&n(t)}return function(n){e.push(n),1==e.length&&t()}}(),o=function(){var e=["Webkit","O","Moz","ms"],t={};function n(n){return n=n.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(e,t){return t.toUpperCase()})),t[n]||(t[n]=function(t){var n=document.body.style;if(t in n)return t;for(var a,r=e.length,i=t.charAt(0).toUpperCase()+t.slice(1);r--;)if((a=e[r]+i)in n)return a;return t}(n))}function a(e,t,a){t=n(t),e.style[t]=a}return function(e,t){var n,r,i=arguments;if(2==i.length)for(n in t)void 0!==(r=t[n])&&t.hasOwnProperty(n)&&a(e,n,r);else a(e,i[1],i[2])}}();function s(e,t){return("string"==typeof e?e:u(e)).indexOf(" "+t+" ")>=0}function c(e,t){var n=u(e),a=n+t;s(n,t)||(e.className=a.substring(1))}function d(e,t){var n,a=u(e);s(e,t)&&(n=a.replace(" "+t+" "," "),e.className=n.substring(1,n.length-1))}function u(e){return(" "+(e.className||"")+" ").replace(/\s+/gi," ")}function p(e){e&&e.parentNode&&e.parentNode.removeChild(e)}return n})?a.call(t,n,t,e):a)||(e.exports=r)},function(e,t,n){"use strict";var a=n(8),r=String,i=TypeError;e.exports=function(e){if(a(e))return e;throw new i(r(e)+" is not an object")}},function(e,t,n){"use strict";var a=n(0),r=n(51).f,i=n(14),l=n(95),o=n(37),s=n(64),c=n(123);e.exports=function(e,t){var n,d,u,p,m,h=e.target,g=e.global,f=e.stat;if(n=g?a:f?a[h]||o(h,{}):a[h]&&a[h].prototype)for(d in t){if(p=t[d],u=e.dontCallGetSet?(m=r(n,d))&&m.value:n[d],!c(g?d:h+(f?".":"#")+d,e.forced)&&void 0!==u){if(typeof p==typeof u)continue;s(p,u)}(e.sham||u&&u.sham)&&i(p,"sham",!0),l(n,d,p,e)}}},function(e,t,n){"use strict";var a=n(3);e.exports=!a((function(){var e=function(){}.bind();return"function"!=typeof e||e.hasOwnProperty("prototype")}))},function(e,t,n){"use strict";var a=n(47),r=n(52);e.exports=function(e){return a(r(e))}},function(e,t,n){"use strict";var a=n(0),r=n(1),i=function(e){return r(e)?e:void 0};e.exports=function(e,t){return arguments.length<2?i(a[e]):a[e]&&a[e][t]}},function(e,t,n){"use strict";var a=n(1),r=n(110),i=TypeError;e.exports=function(e){if(a(e))return e;throw new i(r(e)+" is not a function")}},function(e,t,n){"use strict";var a=n(0),r=n(60),i=n(9),l=n(62),o=n(58),s=n(57),c=a.Symbol,d=r("wks"),u=s?c.for||c:c&&c.withoutSetter||l;e.exports=function(e){return i(d,e)||(d[e]=o&&i(c,e)?c[e]:u("Symbol."+e)),d[e]}},function(e,t,n){"use strict";var a=n(52),r=Object;e.exports=function(e){return r(a(e))}},function(e,t,n){"use strict";var a=n(121);e.exports=function(e){return a(e.length)}},function(e,t,n){"use strict";var a=n(27),r=Function.prototype.call;e.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(e,t,n){"use strict";e.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},function(e,t,n){"use strict";var a=n(61),r=n(0),i=n(37),l=e.exports=r["__core-js_shared__"]||i("__core-js_shared__",{});(l.versions||(l.versions=[])).push({version:"3.36.0",mode:a?"pure":"global",copyright:"© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.36.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(e,t,n){"use strict";var a=n(0),r=Object.defineProperty;e.exports=function(e,t){try{r(a,e,{value:t,configurable:!0,writable:!0})}catch(n){a[e]=t}return t}},function(e,t,n){var a=n(147),r=n(12),i=Object.prototype,l=i.hasOwnProperty,o=i.propertyIsEnumerable,s=a(function(){return arguments}())?a:function(e){return r(e)&&l.call(e,"callee")&&!o.call(e,"callee")};e.exports=s},function(e,t,n){var a=n(10)(n(6),"Map");e.exports=a},function(e,t){e.exports=function(e){var t=typeof e;return null!=e&&("object"==t||"function"==t)}},function(e,t,n){var a=n(167),r=n(174),i=n(176),l=n(177),o=n(178);function s(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=r,s.prototype.get=i,s.prototype.has=l,s.prototype.set=o,e.exports=s},function(e,t){e.exports=function(e){var t=-1,n=Array(e.size);return e.forEach((function(e){n[++t]=e})),n}},function(e,t){e.exports=function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=9007199254740991}},function(e,t,n){var a=n(5),r=n(45),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,l=/^\w*$/;e.exports=function(e,t){if(a(e))return!1;var n=typeof e;return!("number"!=n&&"symbol"!=n&&"boolean"!=n&&null!=e&&!r(e))||(l.test(e)||!i.test(e)||null!=t&&e in Object(t))}},function(e,t,n){var a=n(13),r=n(12);e.exports=function(e){return"symbol"==typeof e||r(e)&&"[object Symbol]"==a(e)}},function(e,t){e.exports=function(e){return e}},function(e,t,n){"use strict";var a=n(2),r=n(3),i=n(18),l=Object,o=a("".split);e.exports=r((function(){return!l("z").propertyIsEnumerable(0)}))?function(e){return"String"===i(e)?o(e,""):l(e)}:l},function(e,t,n){"use strict";e.exports={}},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t){var n=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,l=parseInt,o="object"==typeof global&&global&&global.Object===Object&&global,s="object"==typeof self&&self&&self.Object===Object&&self,c=o||s||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function g(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==d.call(e)}(e))return NaN;if(h(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=h(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(n,"");var o=r.test(e);return o||i.test(e)?l(e.slice(2),o?2:8):a.test(e)?NaN:+e}e.exports=function(e,t,n){var a,r,i,l,o,s,c=0,d=!1,f=!1,v=!0;if("function"!=typeof e)throw new TypeError("Expected a function");function b(t){var n=a,i=r;return a=r=void 0,c=t,l=e.apply(i,n)}function y(e){return c=e,o=setTimeout(E,t),d?b(e):l}function x(e){var n=e-s;return void 0===s||n>=t||n<0||f&&e-c>=i}function E(){var e=m();if(x(e))return S(e);o=setTimeout(E,function(e){var n=t-(e-s);return f?p(n,i-(e-c)):n}(e))}function S(e){return o=void 0,v&&a?b(e):(a=r=void 0,l)}function C(){var e=m(),n=x(e);if(a=arguments,r=this,s=e,n){if(void 0===o)return y(s);if(f)return o=setTimeout(E,t),b(s)}return void 0===o&&(o=setTimeout(E,t)),l}return t=g(t)||0,h(n)&&(d=!!n.leading,i=(f="maxWait"in n)?u(g(n.maxWait)||0,t):i,v="trailing"in n?!!n.trailing:v),C.cancel=function(){void 0!==o&&clearTimeout(o),c=0,a=s=r=o=void 0},C.flush=function(){return void 0===o?l:S(m())},C}},function(e,t,n){"use strict";var a=n(4),r=n(34),i=n(106),l=n(35),o=n(28),s=n(54),c=n(9),d=n(63),u=Object.getOwnPropertyDescriptor;t.f=a?u:function(e,t){if(e=o(e),t=s(t),d)try{return u(e,t)}catch(e){}if(c(e,t))return l(!r(i.f,e,t),e[t])}},function(e,t,n){"use strict";var a=n(53),r=TypeError;e.exports=function(e){if(a(e))throw new r("Can't call method on "+e);return e}},function(e,t,n){"use strict";e.exports=function(e){return null==e}},function(e,t,n){"use strict";var a=n(107),r=n(55);e.exports=function(e){var t=a(e,"string");return r(t)?t:t+""}},function(e,t,n){"use strict";var a=n(29),r=n(1),i=n(56),l=n(57),o=Object;e.exports=l?function(e){return"symbol"==typeof e}:function(e){var t=a("Symbol");return r(t)&&i(t.prototype,o(e))}},function(e,t,n){"use strict";var a=n(2);e.exports=a({}.isPrototypeOf)},function(e,t,n){"use strict";var a=n(58);e.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(e,t,n){"use strict";var a=n(59),r=n(3),i=n(0).String;e.exports=!!Object.getOwnPropertySymbols&&!r((function(){var e=Symbol("symbol detection");return!i(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(e,t,n){"use strict";var a,r,i=n(0),l=n(108),o=i.process,s=i.Deno,c=o&&o.versions||s&&s.version,d=c&&c.v8;d&&(r=(a=d.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&l&&(!(a=l.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=l.match(/Chrome\/(\d+)/))&&(r=+a[1]),e.exports=r},function(e,t,n){"use strict";var a=n(36);e.exports=function(e,t){return a[e]||(a[e]=t||{})}},function(e,t,n){"use strict";e.exports=!1},function(e,t,n){"use strict";var a=n(2),r=0,i=Math.random(),l=a(1..toString);e.exports=function(e){return"Symbol("+(void 0===e?"":e)+")_"+l(++r+i,36)}},function(e,t,n){"use strict";var a=n(4),r=n(3),i=n(98);e.exports=!a&&!r((function(){return 7!==Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(e,t,n){"use strict";var a=n(9),r=n(116),i=n(51),l=n(17);e.exports=function(e,t,n){for(var o=r(t),s=l.f,c=i.f,d=0;d<o.length;d++){var u=o[d];a(e,u)||n&&a(n,u)||s(e,u,c(t,u))}}},function(e,t,n){"use strict";var a=n(120);e.exports=function(e){var t=+e;return t!=t||0===t?0:a(t)}},function(e,t,n){"use strict";var a=n(130),r=n(25),i=n(131);e.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{(e=a(Object.prototype,"__proto__","set"))(n,[]),t=n instanceof Array}catch(e){}return function(n,a){return r(n),i(a),t?e(n,a):n.__proto__=a,n}}():void 0)},function(e,t){e.exports=function(e,t){for(var n=-1,a=t.length,r=e.length;++n<a;)e[r+n]=t[n];return e}},function(e,t){var n="object"==typeof global&&global&&global.Object===Object&&global;e.exports=n},function(e,t,n){var a=n(19),r=n(158),i=n(159),l=n(160),o=n(161),s=n(162);function c(e){var t=this.__data__=new a(e);this.size=t.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=l,c.prototype.has=o,c.prototype.set=s,e.exports=c},function(e,t){e.exports=function(e,t){return e===t||e!=e&&t!=t}},function(e,t,n){var a=n(13),r=n(40);e.exports=function(e){if(!r(e))return!1;var t=a(e);return"[object Function]"==t||"[object GeneratorFunction]"==t||"[object AsyncFunction]"==t||"[object Proxy]"==t}},function(e,t){var n=Function.prototype.toString;e.exports=function(e){if(null!=e){try{return n.call(e)}catch(e){}try{return e+""}catch(e){}}return""}},function(e,t,n){var a=n(179),r=n(12);e.exports=function e(t,n,i,l,o){return t===n||(null==t||null==n||!r(t)&&!r(n)?t!=t&&n!=n:a(t,n,i,l,e,o))}},function(e,t,n){var a=n(75),r=n(182),i=n(76);e.exports=function(e,t,n,l,o,s){var c=1&n,d=e.length,u=t.length;if(d!=u&&!(c&&u>d))return!1;var p=s.get(e),m=s.get(t);if(p&&m)return p==t&&m==e;var h=-1,g=!0,f=2&n?new a:void 0;for(s.set(e,t),s.set(t,e);++h<d;){var v=e[h],b=t[h];if(l)var y=c?l(b,v,h,t,e,s):l(v,b,h,e,t,s);if(void 0!==y){if(y)continue;g=!1;break}if(f){if(!r(t,(function(e,t){if(!i(f,t)&&(v===e||o(v,e,n,l,s)))return f.push(t)}))){g=!1;break}}else if(v!==b&&!o(v,b,n,l,s)){g=!1;break}}return s.delete(e),s.delete(t),g}},function(e,t,n){var a=n(41),r=n(180),i=n(181);function l(e){var t=-1,n=null==e?0:e.length;for(this.__data__=new a;++t<n;)this.add(e[t])}l.prototype.add=l.prototype.push=r,l.prototype.has=i,e.exports=l},function(e,t){e.exports=function(e,t){return e.has(t)}},function(e,t,n){var a=n(192),r=n(198),i=n(81);e.exports=function(e){return i(e)?a(e):r(e)}},function(e,t,n){(function(e){var a=n(6),r=n(194),i=t&&!t.nodeType&&t,l=i&&"object"==typeof e&&e&&!e.nodeType&&e,o=l&&l.exports===i?a.Buffer:void 0,s=(o?o.isBuffer:void 0)||r;e.exports=s}).call(this,n(49)(e))},function(e,t){var n=/^(?:0|[1-9]\d*)$/;e.exports=function(e,t){var a=typeof e;return!!(t=null==t?9007199254740991:t)&&("number"==a||"symbol"!=a&&n.test(e))&&e>-1&&e%1==0&&e<t}},function(e,t,n){var a=n(195),r=n(196),i=n(197),l=i&&i.isTypedArray,o=l?r(l):a;e.exports=o},function(e,t,n){var a=n(71),r=n(43);e.exports=function(e){return null!=e&&r(e.length)&&!a(e)}},function(e,t,n){var a=n(10)(n(6),"Set");e.exports=a},function(e,t,n){var a=n(40);e.exports=function(e){return e==e&&!a(e)}},function(e,t){e.exports=function(e,t){return function(n){return null!=n&&(n[e]===t&&(void 0!==t||e in Object(n)))}}},function(e,t,n){var a=n(86),r=n(23);e.exports=function(e,t){for(var n=0,i=(t=a(t,e)).length;null!=e&&n<i;)e=e[r(t[n++])];return n&&n==i?e:void 0}},function(e,t,n){var a=n(5),r=n(44),i=n(209),l=n(212);e.exports=function(e,t){return a(e)?e:r(e,t)?[e]:i(l(e))}},function(e,t,n){},function(e,t,n){},function(e,t,n){},function(e,t,n){},function(e,t,n){var a=n(145),r=n(150),i=n(221),l=n(229),o=n(238),s=n(103),c=i((function(e){var t=s(e);return o(t)&&(t=void 0),l(a(e,1,o,!0),r(t,2))}));e.exports=c},function(e,t,n){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;e.exports=function(e){var t,n=""+e,r=a.exec(n);if(!r)return n;var i="",l=0,o=0;for(l=r.index;l<n.length;l++){switch(n.charCodeAt(l)){case 34:t="&quot;";break;case 38:t="&amp;";break;case 39:t="&#39;";break;case 60:t="&lt;";break;case 62:t="&gt;";break;default:continue}o!==l&&(i+=n.substring(o,l)),o=l+1,i+=t}return o!==l?i+n.substring(o,l):i}},function(e,t,n){"use strict";n.r(t);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(n(241),n(7)),i=Object(r.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);t.default=i.exports},function(e,t,n){"use strict";n.r(t);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(e){this.codeTabs.forEach(e=>{e.elm.classList.remove("theme-code-block__active")}),this.codeTabs[e].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(e=>Boolean(e.componentOptions)).map((e,t)=>(""===e.componentOptions.propsData.active&&(this.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(e){this.activeCodeTabIndex=e}}},r=(n(242),n(7)),i=Object(r.a)(a,(function(){var e=this,t=e._self._c;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},e._l(e.codeTabs,(function(n,a){return t("li",{key:n.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===e.activeCodeTabIndex},on:{click:function(t){return e.changeCodeTab(a)}}},[e._v("\n            "+e._s(n.title)+"\n          ")])])})),0)]),e._v(" "),e._t("default"),e._v(" "),e.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[e._v("// Make sure to add code blocks to your code group")]):e._e()],2)}),[],!1,null,"2f5f1757",null);t.default=i.exports},function(e,t,n){"use strict";var a=n(1),r=n(17),i=n(100),l=n(37);e.exports=function(e,t,n,o){o||(o={});var s=o.enumerable,c=void 0!==o.name?o.name:t;if(a(n)&&i(n,c,o),o.global)s?e[t]=n:l(t,n);else{try{o.unsafe?e[t]&&(s=!0):delete e[t]}catch(e){}s?e[t]=n:r.f(e,t,{value:n,enumerable:!1,configurable:!o.nonConfigurable,writable:!o.nonWritable})}return e}},function(e,t,n){"use strict";e.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(e,t,n){"use strict";var a=n(136),r=String;e.exports=function(e){if("Symbol"===a(e))throw new TypeError("Cannot convert a Symbol value to a string");return r(e)}},function(e,t,n){"use strict";var a=n(0),r=n(8),i=a.document,l=r(i)&&r(i.createElement);e.exports=function(e){return l?i.createElement(e):{}}},function(e,t,n){"use strict";var a=n(4),r=n(3);e.exports=a&&r((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(e,t,n){"use strict";var a=n(2),r=n(3),i=n(1),l=n(9),o=n(4),s=n(112).CONFIGURABLE,c=n(113),d=n(114),u=d.enforce,p=d.get,m=String,h=Object.defineProperty,g=a("".slice),f=a("".replace),v=a([].join),b=o&&!r((function(){return 8!==h((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=e.exports=function(e,t,n){"Symbol("===g(m(t),0,7)&&(t="["+f(m(t),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),n&&n.getter&&(t="get "+t),n&&n.setter&&(t="set "+t),(!l(e,"name")||s&&e.name!==t)&&(o?h(e,"name",{value:t,configurable:!0}):e.name=t),b&&n&&l(n,"arity")&&e.length!==n.arity&&h(e,"length",{value:n.arity});try{n&&l(n,"constructor")&&n.constructor?o&&h(e,"prototype",{writable:!1}):e.prototype&&(e.prototype=void 0)}catch(e){}var a=u(e);return l(a,"source")||(a.source=v(y,"string"==typeof t?t:"")),e};Function.prototype.toString=x((function(){return i(this)&&p(this).source||c(this)}),"toString")},function(e,t,n){"use strict";var a=n(60),r=n(62),i=a("keys");e.exports=function(e){return i[e]||(i[e]=r(e))}},function(e,t,n){"use strict";var a=n(2),r=n(9),i=n(28),l=n(118).indexOf,o=n(48),s=a([].push);e.exports=function(e,t){var n,a=i(e),c=0,d=[];for(n in a)!r(o,n)&&r(a,n)&&s(d,n);for(;t.length>c;)r(a,n=t[c++])&&(~l(d,n)||s(d,n));return d}},function(e,t){e.exports=function(e){var t=null==e?0:e.length;return t?e[t-1]:void 0}},function(e,t,n){e.exports=n(247)},function(e,t,n){"use strict";var a=n(26),r=n(124).left,i=n(125),l=n(59);a({target:"Array",proto:!0,forced:!n(126)&&l>79&&l<83||!i("reduce")},{reduce:function(e){var t=arguments.length;return r(this,e,t,t>1?arguments[1]:void 0)}})},function(e,t,n){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);t.f=i?function(e){var t=r(this,e);return!!t&&t.enumerable}:a},function(e,t,n){"use strict";var a=n(34),r=n(8),i=n(55),l=n(109),o=n(111),s=n(31),c=TypeError,d=s("toPrimitive");e.exports=function(e,t){if(!r(e)||i(e))return e;var n,s=l(e,d);if(s){if(void 0===t&&(t="default"),n=a(s,e,t),!r(n)||i(n))return n;throw new c("Can't convert object to primitive value")}return void 0===t&&(t="number"),o(e,t)}},function(e,t,n){"use strict";e.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(e,t,n){"use strict";var a=n(30),r=n(53);e.exports=function(e,t){var n=e[t];return r(n)?void 0:a(n)}},function(e,t,n){"use strict";var a=String;e.exports=function(e){try{return a(e)}catch(e){return"Object"}}},function(e,t,n){"use strict";var a=n(34),r=n(1),i=n(8),l=TypeError;e.exports=function(e,t){var n,o;if("string"===t&&r(n=e.toString)&&!i(o=a(n,e)))return o;if(r(n=e.valueOf)&&!i(o=a(n,e)))return o;if("string"!==t&&r(n=e.toString)&&!i(o=a(n,e)))return o;throw new l("Can't convert object to primitive value")}},function(e,t,n){"use strict";var a=n(4),r=n(9),i=Function.prototype,l=a&&Object.getOwnPropertyDescriptor,o=r(i,"name"),s=o&&"something"===function(){}.name,c=o&&(!a||a&&l(i,"name").configurable);e.exports={EXISTS:o,PROPER:s,CONFIGURABLE:c}},function(e,t,n){"use strict";var a=n(2),r=n(1),i=n(36),l=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(e){return l(e)}),e.exports=i.inspectSource},function(e,t,n){"use strict";var a,r,i,l=n(115),o=n(0),s=n(8),c=n(14),d=n(9),u=n(36),p=n(101),m=n(48),h=o.TypeError,g=o.WeakMap;if(l||u.state){var f=u.state||(u.state=new g);f.get=f.get,f.has=f.has,f.set=f.set,a=function(e,t){if(f.has(e))throw new h("Object already initialized");return t.facade=e,f.set(e,t),t},r=function(e){return f.get(e)||{}},i=function(e){return f.has(e)}}else{var v=p("state");m[v]=!0,a=function(e,t){if(d(e,v))throw new h("Object already initialized");return t.facade=e,c(e,v,t),t},r=function(e){return d(e,v)?e[v]:{}},i=function(e){return d(e,v)}}e.exports={set:a,get:r,has:i,enforce:function(e){return i(e)?r(e):a(e,{})},getterFor:function(e){return function(t){var n;if(!s(t)||(n=r(t)).type!==e)throw new h("Incompatible receiver, "+e+" required");return n}}}},function(e,t,n){"use strict";var a=n(0),r=n(1),i=a.WeakMap;e.exports=r(i)&&/native code/.test(String(i))},function(e,t,n){"use strict";var a=n(29),r=n(2),i=n(117),l=n(122),o=n(25),s=r([].concat);e.exports=a("Reflect","ownKeys")||function(e){var t=i.f(o(e)),n=l.f;return n?s(t,n(e)):t}},function(e,t,n){"use strict";var a=n(102),r=n(96).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(e){return a(e,r)}},function(e,t,n){"use strict";var a=n(28),r=n(119),i=n(33),l=function(e){return function(t,n,l){var o=a(t),s=i(o);if(0===s)return!e&&-1;var c,d=r(l,s);if(e&&n!=n){for(;s>d;)if((c=o[d++])!=c)return!0}else for(;s>d;d++)if((e||d in o)&&o[d]===n)return e||d||0;return!e&&-1}};e.exports={includes:l(!0),indexOf:l(!1)}},function(e,t,n){"use strict";var a=n(65),r=Math.max,i=Math.min;e.exports=function(e,t){var n=a(e);return n<0?r(n+t,0):i(n,t)}},function(e,t,n){"use strict";var a=Math.ceil,r=Math.floor;e.exports=Math.trunc||function(e){var t=+e;return(t>0?r:a)(t)}},function(e,t,n){"use strict";var a=n(65),r=Math.min;e.exports=function(e){var t=a(e);return t>0?r(t,9007199254740991):0}},function(e,t,n){"use strict";t.f=Object.getOwnPropertySymbols},function(e,t,n){"use strict";var a=n(3),r=n(1),i=/#|\.prototype\./,l=function(e,t){var n=s[o(e)];return n===d||n!==c&&(r(t)?a(t):!!t)},o=l.normalize=function(e){return String(e).replace(i,".").toLowerCase()},s=l.data={},c=l.NATIVE="N",d=l.POLYFILL="P";e.exports=l},function(e,t,n){"use strict";var a=n(30),r=n(32),i=n(47),l=n(33),o=TypeError,s="Reduce of empty array with no initial value",c=function(e){return function(t,n,c,d){var u=r(t),p=i(u),m=l(u);if(a(n),0===m&&c<2)throw new o(s);var h=e?m-1:0,g=e?-1:1;if(c<2)for(;;){if(h in p){d=p[h],h+=g;break}if(h+=g,e?h<0:m<=h)throw new o(s)}for(;e?h>=0:m>h;h+=g)h in p&&(d=n(d,p[h],h,u));return d}};e.exports={left:c(!1),right:c(!0)}},function(e,t,n){"use strict";var a=n(3);e.exports=function(e,t){var n=[][e];return!!n&&a((function(){n.call(null,t||function(){return 1},1)}))}},function(e,t,n){"use strict";var a=n(0),r=n(18);e.exports="process"===r(a.process)},function(e,t,n){"use strict";var a=n(26),r=n(0),i=n(128),l=n(129),o=r.WebAssembly,s=7!==new Error("e",{cause:7}).cause,c=function(e,t){var n={};n[e]=l(e,t,s),a({global:!0,constructor:!0,arity:1,forced:s},n)},d=function(e,t){if(o&&o[e]){var n={};n[e]=l("WebAssembly."+e,t,s),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:s},n)}};c("Error",(function(e){return function(t){return i(e,this,arguments)}})),c("EvalError",(function(e){return function(t){return i(e,this,arguments)}})),c("RangeError",(function(e){return function(t){return i(e,this,arguments)}})),c("ReferenceError",(function(e){return function(t){return i(e,this,arguments)}})),c("SyntaxError",(function(e){return function(t){return i(e,this,arguments)}})),c("TypeError",(function(e){return function(t){return i(e,this,arguments)}})),c("URIError",(function(e){return function(t){return i(e,this,arguments)}})),d("CompileError",(function(e){return function(t){return i(e,this,arguments)}})),d("LinkError",(function(e){return function(t){return i(e,this,arguments)}})),d("RuntimeError",(function(e){return function(t){return i(e,this,arguments)}}))},function(e,t,n){"use strict";var a=n(27),r=Function.prototype,i=r.apply,l=r.call;e.exports="object"==typeof Reflect&&Reflect.apply||(a?l.bind(i):function(){return l.apply(i,arguments)})},function(e,t,n){"use strict";var a=n(29),r=n(9),i=n(14),l=n(56),o=n(66),s=n(64),c=n(133),d=n(134),u=n(135),p=n(138),m=n(139),h=n(4),g=n(61);e.exports=function(e,t,n,f){var v=f?2:1,b=e.split("."),y=b[b.length-1],x=a.apply(null,b);if(x){var E=x.prototype;if(!g&&r(E,"cause")&&delete E.cause,!n)return x;var S=a("Error"),C=t((function(e,t){var n=u(f?t:e,void 0),a=f?new x(e):new x;return void 0!==n&&i(a,"message",n),m(a,C,a.stack,2),this&&l(E,this)&&d(a,this,C),arguments.length>v&&p(a,arguments[v]),a}));if(C.prototype=E,"Error"!==y?o?o(C,S):s(C,S,{name:!0}):h&&"stackTraceLimit"in x&&(c(C,x,"stackTraceLimit"),c(C,x,"prepareStackTrace")),s(C,x),!g)try{E.name!==y&&i(E,"name",y),E.constructor=C}catch(e){}return C}}},function(e,t,n){"use strict";var a=n(2),r=n(30);e.exports=function(e,t,n){try{return a(r(Object.getOwnPropertyDescriptor(e,t)[n]))}catch(e){}}},function(e,t,n){"use strict";var a=n(132),r=String,i=TypeError;e.exports=function(e){if(a(e))return e;throw new i("Can't set "+r(e)+" as a prototype")}},function(e,t,n){"use strict";var a=n(8);e.exports=function(e){return a(e)||null===e}},function(e,t,n){"use strict";var a=n(17).f;e.exports=function(e,t,n){n in e||a(e,n,{configurable:!0,get:function(){return t[n]},set:function(e){t[n]=e}})}},function(e,t,n){"use strict";var a=n(1),r=n(8),i=n(66);e.exports=function(e,t,n){var l,o;return i&&a(l=t.constructor)&&l!==n&&r(o=l.prototype)&&o!==n.prototype&&i(e,o),e}},function(e,t,n){"use strict";var a=n(97);e.exports=function(e,t){return void 0===e?arguments.length<2?"":t:a(e)}},function(e,t,n){"use strict";var a=n(137),r=n(1),i=n(18),l=n(31)("toStringTag"),o=Object,s="Arguments"===i(function(){return arguments}());e.exports=a?i:function(e){var t,n,a;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=o(e),l))?n:s?i(t):"Object"===(a=i(t))&&r(t.callee)?"Arguments":a}},function(e,t,n){"use strict";var a={};a[n(31)("toStringTag")]="z",e.exports="[object z]"===String(a)},function(e,t,n){"use strict";var a=n(8),r=n(14);e.exports=function(e,t){a(t)&&"cause"in t&&r(e,"cause",t.cause)}},function(e,t,n){"use strict";var a=n(14),r=n(140),i=n(141),l=Error.captureStackTrace;e.exports=function(e,t,n,o){i&&(l?l(e,t):a(e,"stack",r(n,o)))}},function(e,t,n){"use strict";var a=n(2),r=Error,i=a("".replace),l=String(new r("zxcasd").stack),o=/\n\s*at [^:]*:[^\n]*/,s=o.test(l);e.exports=function(e,t){if(s&&"string"==typeof e&&!r.prepareStackTrace)for(;t--;)e=i(e,o,"");return e}},function(e,t,n){"use strict";var a=n(3),r=n(35);e.exports=!a((function(){var e=new Error("a");return!("stack"in e)||(Object.defineProperty(e,"stack",r(1,7)),7!==e.stack)}))},function(e,t,n){"use strict";var a=n(4),r=n(143),i=TypeError,l=Object.getOwnPropertyDescriptor,o=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(e){return e instanceof TypeError}}();e.exports=o?function(e,t){if(r(e)&&!l(e,"length").writable)throw new i("Cannot set read only .length");return e.length=t}:function(e,t){return e.length=t}},function(e,t,n){"use strict";var a=n(18);e.exports=Array.isArray||function(e){return"Array"===a(e)}},function(e,t,n){"use strict";var a=TypeError;e.exports=function(e){if(e>9007199254740991)throw a("Maximum allowed index exceeded");return e}},function(e,t,n){var a=n(67),r=n(146);e.exports=function e(t,n,i,l,o){var s=-1,c=t.length;for(i||(i=r),o||(o=[]);++s<c;){var d=t[s];n>0&&i(d)?n>1?e(d,n-1,i,l,o):a(o,d):l||(o[o.length]=d)}return o}},function(e,t,n){var a=n(15),r=n(38),i=n(5),l=a?a.isConcatSpreadable:void 0;e.exports=function(e){return i(e)||r(e)||!!(l&&e&&e[l])}},function(e,t,n){var a=n(13),r=n(12);e.exports=function(e){return r(e)&&"[object Arguments]"==a(e)}},function(e,t,n){var a=n(15),r=Object.prototype,i=r.hasOwnProperty,l=r.toString,o=a?a.toStringTag:void 0;e.exports=function(e){var t=i.call(e,o),n=e[o];try{e[o]=void 0;var a=!0}catch(e){}var r=l.call(e);return a&&(t?e[o]=n:delete e[o]),r}},function(e,t){var n=Object.prototype.toString;e.exports=function(e){return n.call(e)}},function(e,t,n){var a=n(151),r=n(207),i=n(46),l=n(5),o=n(218);e.exports=function(e){return"function"==typeof e?e:null==e?i:"object"==typeof e?l(e)?r(e[0],e[1]):a(e):o(e)}},function(e,t,n){var a=n(152),r=n(206),i=n(84);e.exports=function(e){var t=r(e);return 1==t.length&&t[0][2]?i(t[0][0],t[0][1]):function(n){return n===e||a(n,e,t)}}},function(e,t,n){var a=n(69),r=n(73);e.exports=function(e,t,n,i){var l=n.length,o=l,s=!i;if(null==e)return!o;for(e=Object(e);l--;){var c=n[l];if(s&&c[2]?c[1]!==e[c[0]]:!(c[0]in e))return!1}for(;++l<o;){var d=(c=n[l])[0],u=e[d],p=c[1];if(s&&c[2]){if(void 0===u&&!(d in e))return!1}else{var m=new a;if(i)var h=i(u,p,d,e,t,m);if(!(void 0===h?r(p,u,3,i,m):h))return!1}}return!0}},function(e,t){e.exports=function(){this.__data__=[],this.size=0}},function(e,t,n){var a=n(20),r=Array.prototype.splice;e.exports=function(e){var t=this.__data__,n=a(t,e);return!(n<0)&&(n==t.length-1?t.pop():r.call(t,n,1),--this.size,!0)}},function(e,t,n){var a=n(20);e.exports=function(e){var t=this.__data__,n=a(t,e);return n<0?void 0:t[n][1]}},function(e,t,n){var a=n(20);e.exports=function(e){return a(this.__data__,e)>-1}},function(e,t,n){var a=n(20);e.exports=function(e,t){var n=this.__data__,r=a(n,e);return r<0?(++this.size,n.push([e,t])):n[r][1]=t,this}},function(e,t,n){var a=n(19);e.exports=function(){this.__data__=new a,this.size=0}},function(e,t){e.exports=function(e){var t=this.__data__,n=t.delete(e);return this.size=t.size,n}},function(e,t){e.exports=function(e){return this.__data__.get(e)}},function(e,t){e.exports=function(e){return this.__data__.has(e)}},function(e,t,n){var a=n(19),r=n(39),i=n(41);e.exports=function(e,t){var n=this.__data__;if(n instanceof a){var l=n.__data__;if(!r||l.length<199)return l.push([e,t]),this.size=++n.size,this;n=this.__data__=new i(l)}return n.set(e,t),this.size=n.size,this}},function(e,t,n){var a=n(71),r=n(164),i=n(40),l=n(72),o=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,d=s.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");e.exports=function(e){return!(!i(e)||r(e))&&(a(e)?p:o).test(l(e))}},function(e,t,n){var a,r=n(165),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";e.exports=function(e){return!!i&&i in e}},function(e,t,n){var a=n(6)["__core-js_shared__"];e.exports=a},function(e,t){e.exports=function(e,t){return null==e?void 0:e[t]}},function(e,t,n){var a=n(168),r=n(19),i=n(39);e.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(e,t,n){var a=n(169),r=n(170),i=n(171),l=n(172),o=n(173);function s(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=r,s.prototype.get=i,s.prototype.has=l,s.prototype.set=o,e.exports=s},function(e,t,n){var a=n(21);e.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(e,t){e.exports=function(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t}},function(e,t,n){var a=n(21),r=Object.prototype.hasOwnProperty;e.exports=function(e){var t=this.__data__;if(a){var n=t[e];return"__lodash_hash_undefined__"===n?void 0:n}return r.call(t,e)?t[e]:void 0}},function(e,t,n){var a=n(21),r=Object.prototype.hasOwnProperty;e.exports=function(e){var t=this.__data__;return a?void 0!==t[e]:r.call(t,e)}},function(e,t,n){var a=n(21);e.exports=function(e,t){var n=this.__data__;return this.size+=this.has(e)?0:1,n[e]=a&&void 0===t?"__lodash_hash_undefined__":t,this}},function(e,t,n){var a=n(22);e.exports=function(e){var t=a(this,e).delete(e);return this.size-=t?1:0,t}},function(e,t){e.exports=function(e){var t=typeof e;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==e:null===e}},function(e,t,n){var a=n(22);e.exports=function(e){return a(this,e).get(e)}},function(e,t,n){var a=n(22);e.exports=function(e){return a(this,e).has(e)}},function(e,t,n){var a=n(22);e.exports=function(e,t){var n=a(this,e),r=n.size;return n.set(e,t),this.size+=n.size==r?0:1,this}},function(e,t,n){var a=n(69),r=n(74),i=n(183),l=n(186),o=n(202),s=n(5),c=n(78),d=n(80),u="[object Object]",p=Object.prototype.hasOwnProperty;e.exports=function(e,t,n,m,h,g){var f=s(e),v=s(t),b=f?"[object Array]":o(e),y=v?"[object Array]":o(t),x=(b="[object Arguments]"==b?u:b)==u,E=(y="[object Arguments]"==y?u:y)==u,S=b==y;if(S&&c(e)){if(!c(t))return!1;f=!0,x=!1}if(S&&!x)return g||(g=new a),f||d(e)?r(e,t,n,m,h,g):i(e,t,b,n,m,h,g);if(!(1&n)){var C=x&&p.call(e,"__wrapped__"),w=E&&p.call(t,"__wrapped__");if(C||w){var U=C?e.value():e,T=w?t.value():t;return g||(g=new a),h(U,T,n,m,g)}}return!!S&&(g||(g=new a),l(e,t,n,m,h,g))}},function(e,t){e.exports=function(e){return this.__data__.set(e,"__lodash_hash_undefined__"),this}},function(e,t){e.exports=function(e){return this.__data__.has(e)}},function(e,t){e.exports=function(e,t){for(var n=-1,a=null==e?0:e.length;++n<a;)if(t(e[n],n,e))return!0;return!1}},function(e,t,n){var a=n(15),r=n(184),i=n(70),l=n(74),o=n(185),s=n(42),c=a?a.prototype:void 0,d=c?c.valueOf:void 0;e.exports=function(e,t,n,a,c,u,p){switch(n){case"[object DataView]":if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case"[object ArrayBuffer]":return!(e.byteLength!=t.byteLength||!u(new r(e),new r(t)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+e,+t);case"[object Error]":return e.name==t.name&&e.message==t.message;case"[object RegExp]":case"[object String]":return e==t+"";case"[object Map]":var m=o;case"[object Set]":var h=1&a;if(m||(m=s),e.size!=t.size&&!h)return!1;var g=p.get(e);if(g)return g==t;a|=2,p.set(e,t);var f=l(m(e),m(t),a,c,u,p);return p.delete(e),f;case"[object Symbol]":if(d)return d.call(e)==d.call(t)}return!1}},function(e,t,n){var a=n(6).Uint8Array;e.exports=a},function(e,t){e.exports=function(e){var t=-1,n=Array(e.size);return e.forEach((function(e,a){n[++t]=[a,e]})),n}},function(e,t,n){var a=n(187),r=Object.prototype.hasOwnProperty;e.exports=function(e,t,n,i,l,o){var s=1&n,c=a(e),d=c.length;if(d!=a(t).length&&!s)return!1;for(var u=d;u--;){var p=c[u];if(!(s?p in t:r.call(t,p)))return!1}var m=o.get(e),h=o.get(t);if(m&&h)return m==t&&h==e;var g=!0;o.set(e,t),o.set(t,e);for(var f=s;++u<d;){var v=e[p=c[u]],b=t[p];if(i)var y=s?i(b,v,p,t,e,o):i(v,b,p,e,t,o);if(!(void 0===y?v===b||l(v,b,n,i,o):y)){g=!1;break}f||(f="constructor"==p)}if(g&&!f){var x=e.constructor,E=t.constructor;x==E||!("constructor"in e)||!("constructor"in t)||"function"==typeof x&&x instanceof x&&"function"==typeof E&&E instanceof E||(g=!1)}return o.delete(e),o.delete(t),g}},function(e,t,n){var a=n(188),r=n(189),i=n(77);e.exports=function(e){return a(e,i,r)}},function(e,t,n){var a=n(67),r=n(5);e.exports=function(e,t,n){var i=t(e);return r(e)?i:a(i,n(e))}},function(e,t,n){var a=n(190),r=n(191),i=Object.prototype.propertyIsEnumerable,l=Object.getOwnPropertySymbols,o=l?function(e){return null==e?[]:(e=Object(e),a(l(e),(function(t){return i.call(e,t)})))}:r;e.exports=o},function(e,t){e.exports=function(e,t){for(var n=-1,a=null==e?0:e.length,r=0,i=[];++n<a;){var l=e[n];t(l,n,e)&&(i[r++]=l)}return i}},function(e,t){e.exports=function(){return[]}},function(e,t,n){var a=n(193),r=n(38),i=n(5),l=n(78),o=n(79),s=n(80),c=Object.prototype.hasOwnProperty;e.exports=function(e,t){var n=i(e),d=!n&&r(e),u=!n&&!d&&l(e),p=!n&&!d&&!u&&s(e),m=n||d||u||p,h=m?a(e.length,String):[],g=h.length;for(var f in e)!t&&!c.call(e,f)||m&&("length"==f||u&&("offset"==f||"parent"==f)||p&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||o(f,g))||h.push(f);return h}},function(e,t){e.exports=function(e,t){for(var n=-1,a=Array(e);++n<e;)a[n]=t(n);return a}},function(e,t){e.exports=function(){return!1}},function(e,t,n){var a=n(13),r=n(43),i=n(12),l={};l["[object Float32Array]"]=l["[object Float64Array]"]=l["[object Int8Array]"]=l["[object Int16Array]"]=l["[object Int32Array]"]=l["[object Uint8Array]"]=l["[object Uint8ClampedArray]"]=l["[object Uint16Array]"]=l["[object Uint32Array]"]=!0,l["[object Arguments]"]=l["[object Array]"]=l["[object ArrayBuffer]"]=l["[object Boolean]"]=l["[object DataView]"]=l["[object Date]"]=l["[object Error]"]=l["[object Function]"]=l["[object Map]"]=l["[object Number]"]=l["[object Object]"]=l["[object RegExp]"]=l["[object Set]"]=l["[object String]"]=l["[object WeakMap]"]=!1,e.exports=function(e){return i(e)&&r(e.length)&&!!l[a(e)]}},function(e,t){e.exports=function(e){return function(t){return e(t)}}},function(e,t,n){(function(e){var a=n(68),r=t&&!t.nodeType&&t,i=r&&"object"==typeof e&&e&&!e.nodeType&&e,l=i&&i.exports===r&&a.process,o=function(){try{var e=i&&i.require&&i.require("util").types;return e||l&&l.binding&&l.binding("util")}catch(e){}}();e.exports=o}).call(this,n(49)(e))},function(e,t,n){var a=n(199),r=n(200),i=Object.prototype.hasOwnProperty;e.exports=function(e){if(!a(e))return r(e);var t=[];for(var n in Object(e))i.call(e,n)&&"constructor"!=n&&t.push(n);return t}},function(e,t){var n=Object.prototype;e.exports=function(e){var t=e&&e.constructor;return e===("function"==typeof t&&t.prototype||n)}},function(e,t,n){var a=n(201)(Object.keys,Object);e.exports=a},function(e,t){e.exports=function(e,t){return function(n){return e(t(n))}}},function(e,t,n){var a=n(203),r=n(39),i=n(204),l=n(82),o=n(205),s=n(13),c=n(72),d=c(a),u=c(r),p=c(i),m=c(l),h=c(o),g=s;(a&&"[object DataView]"!=g(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=g(new r)||i&&"[object Promise]"!=g(i.resolve())||l&&"[object Set]"!=g(new l)||o&&"[object WeakMap]"!=g(new o))&&(g=function(e){var t=s(e),n="[object Object]"==t?e.constructor:void 0,a=n?c(n):"";if(a)switch(a){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return t}),e.exports=g},function(e,t,n){var a=n(10)(n(6),"DataView");e.exports=a},function(e,t,n){var a=n(10)(n(6),"Promise");e.exports=a},function(e,t,n){var a=n(10)(n(6),"WeakMap");e.exports=a},function(e,t,n){var a=n(83),r=n(77);e.exports=function(e){for(var t=r(e),n=t.length;n--;){var i=t[n],l=e[i];t[n]=[i,l,a(l)]}return t}},function(e,t,n){var a=n(73),r=n(208),i=n(215),l=n(44),o=n(83),s=n(84),c=n(23);e.exports=function(e,t){return l(e)&&o(t)?s(c(e),t):function(n){var l=r(n,e);return void 0===l&&l===t?i(n,e):a(t,l,3)}}},function(e,t,n){var a=n(85);e.exports=function(e,t,n){var r=null==e?void 0:a(e,t);return void 0===r?n:r}},function(e,t,n){var a=n(210),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,l=a((function(e){var t=[];return 46===e.charCodeAt(0)&&t.push(""),e.replace(r,(function(e,n,a,r){t.push(a?r.replace(i,"$1"):n||e)})),t}));e.exports=l},function(e,t,n){var a=n(211);e.exports=function(e){var t=a(e,(function(e){return 500===n.size&&n.clear(),e})),n=t.cache;return t}},function(e,t,n){var a=n(41);function r(e,t){if("function"!=typeof e||null!=t&&"function"!=typeof t)throw new TypeError("Expected a function");var n=function(){var a=arguments,r=t?t.apply(this,a):a[0],i=n.cache;if(i.has(r))return i.get(r);var l=e.apply(this,a);return n.cache=i.set(r,l)||i,l};return n.cache=new(r.Cache||a),n}r.Cache=a,e.exports=r},function(e,t,n){var a=n(213);e.exports=function(e){return null==e?"":a(e)}},function(e,t,n){var a=n(15),r=n(214),i=n(5),l=n(45),o=a?a.prototype:void 0,s=o?o.toString:void 0;e.exports=function e(t){if("string"==typeof t)return t;if(i(t))return r(t,e)+"";if(l(t))return s?s.call(t):"";var n=t+"";return"0"==n&&1/t==-1/0?"-0":n}},function(e,t){e.exports=function(e,t){for(var n=-1,a=null==e?0:e.length,r=Array(a);++n<a;)r[n]=t(e[n],n,e);return r}},function(e,t,n){var a=n(216),r=n(217);e.exports=function(e,t){return null!=e&&r(e,t,a)}},function(e,t){e.exports=function(e,t){return null!=e&&t in Object(e)}},function(e,t,n){var a=n(86),r=n(38),i=n(5),l=n(79),o=n(43),s=n(23);e.exports=function(e,t,n){for(var c=-1,d=(t=a(t,e)).length,u=!1;++c<d;){var p=s(t[c]);if(!(u=null!=e&&n(e,p)))break;e=e[p]}return u||++c!=d?u:!!(d=null==e?0:e.length)&&o(d)&&l(p,d)&&(i(e)||r(e))}},function(e,t,n){var a=n(219),r=n(220),i=n(44),l=n(23);e.exports=function(e){return i(e)?a(l(e)):r(e)}},function(e,t){e.exports=function(e){return function(t){return null==t?void 0:t[e]}}},function(e,t,n){var a=n(85);e.exports=function(e){return function(t){return a(t,e)}}},function(e,t,n){var a=n(46),r=n(222),i=n(224);e.exports=function(e,t){return i(r(e,t,a),e+"")}},function(e,t,n){var a=n(223),r=Math.max;e.exports=function(e,t,n){return t=r(void 0===t?e.length-1:t,0),function(){for(var i=arguments,l=-1,o=r(i.length-t,0),s=Array(o);++l<o;)s[l]=i[t+l];l=-1;for(var c=Array(t+1);++l<t;)c[l]=i[l];return c[t]=n(s),a(e,this,c)}}},function(e,t){e.exports=function(e,t,n){switch(n.length){case 0:return e.call(t);case 1:return e.call(t,n[0]);case 2:return e.call(t,n[0],n[1]);case 3:return e.call(t,n[0],n[1],n[2])}return e.apply(t,n)}},function(e,t,n){var a=n(225),r=n(228)(a);e.exports=r},function(e,t,n){var a=n(226),r=n(227),i=n(46),l=r?function(e,t){return r(e,"toString",{configurable:!0,enumerable:!1,value:a(t),writable:!0})}:i;e.exports=l},function(e,t){e.exports=function(e){return function(){return e}}},function(e,t,n){var a=n(10),r=function(){try{var e=a(Object,"defineProperty");return e({},"",{}),e}catch(e){}}();e.exports=r},function(e,t){var n=Date.now;e.exports=function(e){var t=0,a=0;return function(){var r=n(),i=16-(r-a);if(a=r,i>0){if(++t>=800)return arguments[0]}else t=0;return e.apply(void 0,arguments)}}},function(e,t,n){var a=n(75),r=n(230),i=n(235),l=n(76),o=n(236),s=n(42);e.exports=function(e,t,n){var c=-1,d=r,u=e.length,p=!0,m=[],h=m;if(n)p=!1,d=i;else if(u>=200){var g=t?null:o(e);if(g)return s(g);p=!1,d=l,h=new a}else h=t?[]:m;e:for(;++c<u;){var f=e[c],v=t?t(f):f;if(f=n||0!==f?f:0,p&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue e;t&&h.push(v),m.push(f)}else d(h,v,n)||(h!==m&&h.push(v),m.push(f))}return m}},function(e,t,n){var a=n(231);e.exports=function(e,t){return!!(null==e?0:e.length)&&a(e,t,0)>-1}},function(e,t,n){var a=n(232),r=n(233),i=n(234);e.exports=function(e,t,n){return t==t?i(e,t,n):a(e,r,n)}},function(e,t){e.exports=function(e,t,n,a){for(var r=e.length,i=n+(a?1:-1);a?i--:++i<r;)if(t(e[i],i,e))return i;return-1}},function(e,t){e.exports=function(e){return e!=e}},function(e,t){e.exports=function(e,t,n){for(var a=n-1,r=e.length;++a<r;)if(e[a]===t)return a;return-1}},function(e,t){e.exports=function(e,t,n){for(var a=-1,r=null==e?0:e.length;++a<r;)if(n(t,e[a]))return!0;return!1}},function(e,t,n){var a=n(82),r=n(237),i=n(42),l=a&&1/i(new a([,-0]))[1]==1/0?function(e){return new a(e)}:r;e.exports=l},function(e,t){e.exports=function(){}},function(e,t,n){var a=n(81),r=n(12);e.exports=function(e){return r(e)&&a(e)}},function(e,t,n){},function(e,t,n){},function(e,t,n){"use strict";n(87)},function(e,t,n){"use strict";n(88)},function(e,t,n){},function(e,t,n){},function(e,t,n){"use strict";n(89)},function(e,t,n){"use strict";n(90)},function(e,t,n){"use strict";n.r(t);
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function i(e){return null==e}function l(e){return null!=e}function o(e){return!0===e}function s(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function c(e){return"function"==typeof e}function d(e){return null!==e&&"object"==typeof e}var u=Object.prototype.toString;function p(e){return"[object Object]"===u.call(e)}function m(e){return"[object RegExp]"===u.call(e)}function h(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function g(e){return l(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function f(e){return null==e?"":Array.isArray(e)||p(e)&&e.toString===u?JSON.stringify(e,v,2):String(e)}function v(e,t){return t&&t.__v_isRef?t.value:t}function b(e){var t=parseFloat(e);return isNaN(t)?e:t}function y(e,t){for(var n=Object.create(null),a=e.split(","),r=0;r<a.length;r++)n[a[r]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}y("slot,component",!0);var x=y("key,ref,slot,slot-scope,is");function E(e,t){var n=e.length;if(n){if(t===e[n-1])return void(e.length=n-1);var a=e.indexOf(t);if(a>-1)return e.splice(a,1)}}var S=Object.prototype.hasOwnProperty;function C(e,t){return S.call(e,t)}function w(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var U=/-(\w)/g,T=w((function(e){return e.replace(U,(function(e,t){return t?t.toUpperCase():""}))})),B=w((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),k=/\B([A-Z])/g,j=w((function(e){return e.replace(k,"-$1").toLowerCase()}));var A=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function H(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function I(e,t){for(var n in t)e[n]=t[n];return e}function z(e){for(var t={},n=0;n<e.length;n++)e[n]&&I(t,e[n]);return t}function D(e,t,n){}var F=function(e,t,n){return!1},P=function(e){return e};function _(e,t){if(e===t)return!0;var n=d(e),a=d(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var r=Array.isArray(e),i=Array.isArray(t);if(r&&i)return e.length===t.length&&e.every((function(e,n){return _(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(r||i)return!1;var l=Object.keys(e),o=Object.keys(t);return l.length===o.length&&l.every((function(n){return _(e[n],t[n])}))}catch(e){return!1}}function L(e,t){for(var n=0;n<e.length;n++)if(_(e[n],t))return n;return-1}function O(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}function M(e,t){return e===t?0===e&&1/e!=1/t:e==e||t==t}var R=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],J={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:F,isReservedAttr:F,isUnknownElement:F,getTagNamespace:D,parsePlatformTagName:P,mustUseProp:F,async:!0,_lifecycleHooks:N},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function W(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function $(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var X=new RegExp("[^".concat(q.source,".$_\\d]"));var Z="__proto__"in{},V="undefined"!=typeof window,K=V&&window.navigator.userAgent.toLowerCase(),Q=K&&/msie|trident/.test(K),G=K&&K.indexOf("msie 9.0")>0,Y=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var ee=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var te,ne=K&&K.match(/firefox\/(\d+)/),ae={}.watch,re=!1;if(V)try{var ie={};Object.defineProperty(ie,"passive",{get:function(){re=!0}}),window.addEventListener("test-passive",null,ie)}catch(e){}var le=function(){return void 0===te&&(te=!V&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),te},oe=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function se(e){return"function"==typeof e&&/native code/.test(e.toString())}var ce,de="undefined"!=typeof Symbol&&se(Symbol)&&"undefined"!=typeof Reflect&&se(Reflect.ownKeys);ce="undefined"!=typeof Set&&se(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var ue=null;function pe(e){void 0===e&&(e=null),e||ue&&ue._scope.off(),ue=e,e&&e._scope.on()}var me=function(){function e(e,t,n,a,r,i,l,o){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=l,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(e.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),e}(),he=function(e){void 0===e&&(e="");var t=new me;return t.text=e,t.isComment=!0,t};function ge(e){return new me(void 0,void 0,void 0,String(e))}function fe(e){var t=new me(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}"function"==typeof SuppressedError&&SuppressedError;var ve=0,be=[],ye=function(){function e(){this._pending=!1,this.id=ve++,this.subs=[]}return e.prototype.addSub=function(e){this.subs.push(e)},e.prototype.removeSub=function(e){this.subs[this.subs.indexOf(e)]=null,this._pending||(this._pending=!0,be.push(this))},e.prototype.depend=function(t){e.target&&e.target.addDep(this)},e.prototype.notify=function(e){var t=this.subs.filter((function(e){return e}));for(var n=0,a=t.length;n<a;n++){0,t[n].update()}},e}();ye.target=null;var xe=[];function Ee(e){xe.push(e),ye.target=e}function Se(){xe.pop(),ye.target=xe[xe.length-1]}var Ce=Array.prototype,we=Object.create(Ce);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=Ce[e];$(we,e,(function(){for(var n=[],a=0;a<arguments.length;a++)n[a]=arguments[a];var r,i=t.apply(this,n),l=this.__ob__;switch(e){case"push":case"unshift":r=n;break;case"splice":r=n.slice(2)}return r&&l.observeArray(r),l.dep.notify(),i}))}));var Ue=Object.getOwnPropertyNames(we),Te={},Be=!0;function ke(e){Be=e}var je={notify:D,depend:D,addSub:D,removeSub:D},Ae=function(){function e(e,t,n){if(void 0===t&&(t=!1),void 0===n&&(n=!1),this.value=e,this.shallow=t,this.mock=n,this.dep=n?je:new ye,this.vmCount=0,$(e,"__ob__",this),r(e)){if(!n)if(Z)e.__proto__=we;else for(var a=0,i=Ue.length;a<i;a++){$(e,o=Ue[a],we[o])}t||this.observeArray(e)}else{var l=Object.keys(e);for(a=0;a<l.length;a++){var o;Ie(e,o=l[a],Te,void 0,t,n)}}}return e.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)He(e[t],!1,this.mock)},e}();function He(e,t,n){return e&&C(e,"__ob__")&&e.__ob__ instanceof Ae?e.__ob__:!Be||!n&&le()||!r(e)&&!p(e)||!Object.isExtensible(e)||e.__v_skip||Oe(e)||e instanceof me?void 0:new Ae(e,t,n)}function Ie(e,t,n,a,i,l,o){void 0===o&&(o=!1);var s=new ye,c=Object.getOwnPropertyDescriptor(e,t);if(!c||!1!==c.configurable){var d=c&&c.get,u=c&&c.set;d&&!u||n!==Te&&2!==arguments.length||(n=e[t]);var p=i?n&&n.__ob__:He(n,!1,l);return Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=d?d.call(e):n;return ye.target&&(s.depend(),p&&(p.dep.depend(),r(t)&&Fe(t))),Oe(t)&&!i?t.value:t},set:function(t){var a=d?d.call(e):n;if(M(a,t)){if(u)u.call(e,t);else{if(d)return;if(!i&&Oe(a)&&!Oe(t))return void(a.value=t);n=t}p=i?t&&t.__ob__:He(t,!1,l),s.notify()}}}),s}}function ze(e,t,n){if(!Le(e)){var a=e.__ob__;return r(e)&&h(t)?(e.length=Math.max(e.length,t),e.splice(t,1,n),a&&!a.shallow&&a.mock&&He(n,!1,!0),n):t in e&&!(t in Object.prototype)?(e[t]=n,n):e._isVue||a&&a.vmCount?n:a?(Ie(a.value,t,n,void 0,a.shallow,a.mock),a.dep.notify(),n):(e[t]=n,n)}}function De(e,t){if(r(e)&&h(t))e.splice(t,1);else{var n=e.__ob__;e._isVue||n&&n.vmCount||Le(e)||C(e,t)&&(delete e[t],n&&n.dep.notify())}}function Fe(e){for(var t=void 0,n=0,a=e.length;n<a;n++)(t=e[n])&&t.__ob__&&t.__ob__.dep.depend(),r(t)&&Fe(t)}function Pe(e){return _e(e,!0),$(e,"__v_isShallow",!0),e}function _e(e,t){if(!Le(e)){He(e,t,le());0}}function Le(e){return!(!e||!e.__v_isReadonly)}function Oe(e){return!(!e||!0!==e.__v_isRef)}function Me(e,t,n){Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var e=t[n];if(Oe(e))return e.value;var a=e&&e.__ob__;return a&&a.dep.depend(),e},set:function(e){var a=t[n];Oe(a)&&!Oe(e)?a.value=e:t[n]=e}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Re;var Ne=function(){function e(e){void 0===e&&(e=!1),this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Re,!e&&Re&&(this.index=(Re.scopes||(Re.scopes=[])).push(this)-1)}return e.prototype.run=function(e){if(this.active){var t=Re;try{return Re=this,e()}finally{Re=t}}else 0},e.prototype.on=function(){Re=this},e.prototype.off=function(){Re=this.parent},e.prototype.stop=function(e){if(this.active){var t=void 0,n=void 0;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].teardown();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},e}();function Je(e){var t=e._provided,n=e.$parent&&e.$parent._provided;return n===t?e._provided=Object.create(n):t}var qe=w((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function We(e,t){function n(){var e=n.fns;if(!r(e))return Bt(e,null,arguments,t,"v-on handler");for(var a=e.slice(),i=0;i<a.length;i++)Bt(a[i],null,arguments,t,"v-on handler")}return n.fns=e,n}function $e(e,t,n,a,r,l){var s,c,d,u;for(s in e)c=e[s],d=t[s],u=qe(s),i(c)||(i(d)?(i(c.fns)&&(c=e[s]=We(c,l)),o(u.once)&&(c=e[s]=r(u.name,c,u.capture)),n(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,e[s]=d));for(s in t)i(e[s])&&a((u=qe(s)).name,t[s],u.capture)}function Xe(e,t,n){var a;e instanceof me&&(e=e.data.hook||(e.data.hook={}));var r=e[t];function s(){n.apply(this,arguments),E(a.fns,s)}i(r)?a=We([s]):l(r.fns)&&o(r.merged)?(a=r).fns.push(s):a=We([r,s]),a.merged=!0,e[t]=a}function Ze(e,t,n,a,r){if(l(t)){if(C(t,n))return e[n]=t[n],r||delete t[n],!0;if(C(t,a))return e[n]=t[a],r||delete t[a],!0}return!1}function Ve(e){return s(e)?[ge(e)]:r(e)?function e(t,n){var a,c,d,u,p=[];for(a=0;a<t.length;a++)i(c=t[a])||"boolean"==typeof c||(d=p.length-1,u=p[d],r(c)?c.length>0&&(Ke((c=e(c,"".concat(n||"","_").concat(a)))[0])&&Ke(u)&&(p[d]=ge(u.text+c[0].text),c.shift()),p.push.apply(p,c)):s(c)?Ke(u)?p[d]=ge(u.text+c):""!==c&&p.push(ge(c)):Ke(c)&&Ke(u)?p[d]=ge(u.text+c.text):(o(t._isVList)&&l(c.tag)&&i(c.key)&&l(n)&&(c.key="__vlist".concat(n,"_").concat(a,"__")),p.push(c)));return p}(e):void 0}function Ke(e){return l(e)&&l(e.text)&&!1===e.isComment}function Qe(e,t){var n,a,i,o,s=null;if(r(e)||"string"==typeof e)for(s=new Array(e.length),n=0,a=e.length;n<a;n++)s[n]=t(e[n],n);else if("number"==typeof e)for(s=new Array(e),n=0;n<e;n++)s[n]=t(n+1,n);else if(d(e))if(de&&e[Symbol.iterator]){s=[];for(var c=e[Symbol.iterator](),u=c.next();!u.done;)s.push(t(u.value,s.length)),u=c.next()}else for(i=Object.keys(e),s=new Array(i.length),n=0,a=i.length;n<a;n++)o=i[n],s[n]=t(e[o],o,n);return l(s)||(s=[]),s._isVList=!0,s}function Ge(e,t,n,a){var r,i=this.$scopedSlots[e];i?(n=n||{},a&&(n=I(I({},a),n)),r=i(n)||(c(t)?t():t)):r=this.$slots[e]||(c(t)?t():t);var l=n&&n.slot;return l?this.$createElement("template",{slot:l},r):r}function Ye(e){return Hn(this.$options,"filters",e,!0)||P}function et(e,t){return r(e)?-1===e.indexOf(t):e!==t}function tt(e,t,n,a,r){var i=J.keyCodes[t]||n;return r&&a&&!J.keyCodes[t]?et(r,a):i?et(i,e):a?j(a)!==t:void 0===e}function nt(e,t,n,a,i){if(n)if(d(n)){r(n)&&(n=z(n));var l=void 0,o=function(r){if("class"===r||"style"===r||x(r))l=e;else{var o=e.attrs&&e.attrs.type;l=a||J.mustUseProp(t,o,r)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var s=T(r),c=j(r);s in l||c in l||(l[r]=n[r],i&&((e.on||(e.on={}))["update:".concat(r)]=function(e){n[r]=e}))};for(var s in n)o(s)}else;return e}function at(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||it(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,this._c,this),"__static__".concat(e),!1),a}function rt(e,t,n){return it(e,"__once__".concat(t).concat(n?"_".concat(n):""),!0),e}function it(e,t,n){if(r(e))for(var a=0;a<e.length;a++)e[a]&&"string"!=typeof e[a]&&lt(e[a],"".concat(t,"_").concat(a),n);else lt(e,t,n)}function lt(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function ot(e,t){if(t)if(p(t)){var n=e.on=e.on?I({},e.on):{};for(var a in t){var r=n[a],i=t[a];n[a]=r?[].concat(r,i):i}}else;return e}function st(e,t,n,a){t=t||{$stable:!n};for(var i=0;i<e.length;i++){var l=e[i];r(l)?st(l,t,n):l&&(l.proxy&&(l.fn.proxy=!0),t[l.key]=l.fn)}return a&&(t.$key=a),t}function ct(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function dt(e,t){return"string"==typeof e?t+e:e}function ut(e){e._o=rt,e._n=b,e._s=f,e._l=Qe,e._t=Ge,e._q=_,e._i=L,e._m=at,e._f=Ye,e._k=tt,e._b=nt,e._v=ge,e._e=he,e._u=st,e._g=ot,e._d=ct,e._p=dt}function pt(e,t){if(!e||!e.length)return{};for(var n={},a=0,r=e.length;a<r;a++){var i=e[a],l=i.data;if(l&&l.attrs&&l.attrs.slot&&delete l.attrs.slot,i.context!==t&&i.fnContext!==t||!l||null==l.slot)(n.default||(n.default=[])).push(i);else{var o=l.slot,s=n[o]||(n[o]=[]);"template"===i.tag?s.push.apply(s,i.children||[]):s.push(i)}}for(var c in n)n[c].every(mt)&&delete n[c];return n}function mt(e){return e.isComment&&!e.asyncFactory||" "===e.text}function ht(e){return e.isComment&&e.asyncFactory}function gt(e,t,n,r){var i,l=Object.keys(n).length>0,o=t?!!t.$stable:!l,s=t&&t.$key;if(t){if(t._normalized)return t._normalized;if(o&&r&&r!==a&&s===r.$key&&!l&&!r.$hasNormal)return r;for(var c in i={},t)t[c]&&"$"!==c[0]&&(i[c]=ft(e,n,c,t[c]))}else i={};for(var d in n)d in i||(i[d]=vt(n,d));return t&&Object.isExtensible(t)&&(t._normalized=i),$(i,"$stable",o),$(i,"$key",s),$(i,"$hasNormal",l),i}function ft(e,t,n,a){var i=function(){var t=ue;pe(e);var n=arguments.length?a.apply(null,arguments):a({}),i=(n=n&&"object"==typeof n&&!r(n)?[n]:Ve(n))&&n[0];return pe(t),n&&(!i||1===n.length&&i.isComment&&!ht(i))?void 0:n};return a.proxy&&Object.defineProperty(t,n,{get:i,enumerable:!0,configurable:!0}),i}function vt(e,t){return function(){return e[t]}}function bt(e){return{get attrs(){if(!e._attrsProxy){var t=e._attrsProxy={};$(t,"_v_attr_proxy",!0),yt(t,e.$attrs,a,e,"$attrs")}return e._attrsProxy},get listeners(){e._listenersProxy||yt(e._listenersProxy={},e.$listeners,a,e,"$listeners");return e._listenersProxy},get slots(){return function(e){e._slotsProxy||Et(e._slotsProxy={},e.$scopedSlots);return e._slotsProxy}(e)},emit:A(e.$emit,e),expose:function(t){t&&Object.keys(t).forEach((function(n){return Me(e,t,n)}))}}}function yt(e,t,n,a,r){var i=!1;for(var l in t)l in e?t[l]!==n[l]&&(i=!0):(i=!0,xt(e,l,a,r));for(var l in e)l in t||(i=!0,delete e[l]);return i}function xt(e,t,n,a){Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){return n[a][t]}})}function Et(e,t){for(var n in t)e[n]=t[n];for(var n in e)n in t||delete e[n]}var St=null;function Ct(e,t){return(e.__esModule||de&&"Module"===e[Symbol.toStringTag])&&(e=e.default),d(e)?t.extend(e):e}function wt(e){if(r(e))for(var t=0;t<e.length;t++){var n=e[t];if(l(n)&&(l(n.componentOptions)||ht(n)))return n}}function Ut(e,t,n,a,u,p){return(r(n)||s(n))&&(u=a,a=n,n=void 0),o(p)&&(u=2),function(e,t,n,a,s){if(l(n)&&l(n.__ob__))return he();l(n)&&l(n.is)&&(t=n.is);if(!t)return he();0;r(a)&&c(a[0])&&((n=n||{}).scopedSlots={default:a[0]},a.length=0);2===s?a=Ve(a):1===s&&(a=function(e){for(var t=0;t<e.length;t++)if(r(e[t]))return Array.prototype.concat.apply([],e);return e}(a));var u,p;if("string"==typeof t){var m=void 0;p=e.$vnode&&e.$vnode.ns||J.getTagNamespace(t),u=J.isReservedTag(t)?new me(J.parsePlatformTagName(t),n,a,void 0,void 0,e):n&&n.pre||!l(m=Hn(e.$options,"components",t))?new me(t,n,a,void 0,void 0,e):En(m,n,e,a,t)}else u=En(t,n,e,a);return r(u)?u:l(u)?(l(p)&&function e(t,n,a){t.ns=n,"foreignObject"===t.tag&&(n=void 0,a=!0);if(l(t.children))for(var r=0,s=t.children.length;r<s;r++){var c=t.children[r];l(c.tag)&&(i(c.ns)||o(a)&&"svg"!==c.tag)&&e(c,n,a)}}(u,p),l(n)&&function(e){d(e.style)&&Nt(e.style);d(e.class)&&Nt(e.class)}(n),u):he()}(e,t,n,a,u)}function Tt(e,t,n){Ee();try{if(t)for(var a=t;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,e,t,n))return}catch(e){kt(e,a,"errorCaptured hook")}}kt(e,t,n)}finally{Se()}}function Bt(e,t,n,a,r){var i;try{(i=n?e.apply(t,n):e.call(t))&&!i._isVue&&g(i)&&!i._handled&&(i.catch((function(e){return Tt(e,a,r+" (Promise/async)")})),i._handled=!0)}catch(e){Tt(e,a,r)}return i}function kt(e,t,n){if(J.errorHandler)try{return J.errorHandler.call(null,e,t,n)}catch(t){t!==e&&jt(t,null,"config.errorHandler")}jt(e,t,n)}function jt(e,t,n){if(!V||"undefined"==typeof console)throw e;console.error(e)}var At,Ht=!1,It=[],zt=!1;function Dt(){zt=!1;var e=It.slice(0);It.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&se(Promise)){var Ft=Promise.resolve();At=function(){Ft.then(Dt),ee&&setTimeout(D)},Ht=!0}else if(Q||"undefined"==typeof MutationObserver||!se(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())At="undefined"!=typeof setImmediate&&se(setImmediate)?function(){setImmediate(Dt)}:function(){setTimeout(Dt,0)};else{var Pt=1,_t=new MutationObserver(Dt),Lt=document.createTextNode(String(Pt));_t.observe(Lt,{characterData:!0}),At=function(){Pt=(Pt+1)%2,Lt.data=String(Pt)},Ht=!0}function Ot(e,t){var n;if(It.push((function(){if(e)try{e.call(t)}catch(e){Tt(e,t,"nextTick")}else n&&n(t)})),zt||(zt=!0,At()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}function Mt(e){return function(t,n){if(void 0===n&&(n=ue),n)return function(e,t,n){var a=e.$options;a[t]=Bn(a[t],n)}(n,e,t)}}Mt("beforeMount"),Mt("mounted"),Mt("beforeUpdate"),Mt("updated"),Mt("beforeDestroy"),Mt("destroyed"),Mt("activated"),Mt("deactivated"),Mt("serverPrefetch"),Mt("renderTracked"),Mt("renderTriggered"),Mt("errorCaptured");var Rt=new ce;function Nt(e){return function e(t,n){var a,i,l=r(t);if(!l&&!d(t)||t.__v_skip||Object.isFrozen(t)||t instanceof me)return;if(t.__ob__){var o=t.__ob__.dep.id;if(n.has(o))return;n.add(o)}if(l)for(a=t.length;a--;)e(t[a],n);else if(Oe(t))e(t.value,n);else for(i=Object.keys(t),a=i.length;a--;)e(t[i[a]],n)}(e,Rt),Rt.clear(),e}var Jt,qt=0,Wt=function(){function e(e,t,n,a,r){var i,l;i=this,void 0===(l=Re&&!Re._vm?Re:e?e._scope:void 0)&&(l=Re),l&&l.active&&l.effects.push(i),(this.vm=e)&&r&&(e._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++qt,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ce,this.newDepIds=new ce,this.expression="",c(t)?this.getter=t:(this.getter=function(e){if(!X.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=D)),this.value=this.lazy?void 0:this.get()}return e.prototype.get=function(){var e;Ee(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;Tt(e,t,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Nt(e),Se(),this.cleanupDeps()}return e},e.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},e.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},e.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mn(this)},e.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||d(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'.concat(this.expression,'"');Bt(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},e.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},e.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},e.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&E(this.vm._scope.effects,this),this.active){for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},e}();function $t(e,t){Jt.$on(e,t)}function Xt(e,t){Jt.$off(e,t)}function Zt(e,t){var n=Jt;return function a(){var r=t.apply(null,arguments);null!==r&&n.$off(e,a)}}function Vt(e,t,n){Jt=e,$e(t,n||{},$t,Xt,Zt,e),Jt=void 0}var Kt=null;function Qt(e){var t=Kt;return Kt=e,function(){Kt=t}}function Gt(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function Yt(e,t){if(t){if(e._directInactive=!1,Gt(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)Yt(e.$children[n]);en(e,"activated")}}function en(e,t,n,a){void 0===a&&(a=!0),Ee();var r=ue,i=Re;a&&pe(e);var l=e.$options[t],o="".concat(t," hook");if(l)for(var s=0,c=l.length;s<c;s++)Bt(l[s],e,n||null,e,o);e._hasHookEvent&&e.$emit("hook:"+t),a&&(pe(r),i&&i.on()),Se()}var tn=[],nn=[],an={},rn=!1,ln=!1,on=0;var sn=0,cn=Date.now;if(V&&!Q){var dn=window.performance;dn&&"function"==typeof dn.now&&cn()>document.createEvent("Event").timeStamp&&(cn=function(){return dn.now()})}var un=function(e,t){if(e.post){if(!t.post)return 1}else if(t.post)return-1;return e.id-t.id};function pn(){var e,t;for(sn=cn(),ln=!0,tn.sort(un),on=0;on<tn.length;on++)(e=tn[on]).before&&e.before(),t=e.id,an[t]=null,e.run();var n=nn.slice(),a=tn.slice();on=tn.length=nn.length=0,an={},rn=ln=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,Yt(e[t],!0)}(n),function(e){var t=e.length;for(;t--;){var n=e[t],a=n.vm;a&&a._watcher===n&&a._isMounted&&!a._isDestroyed&&en(a,"updated")}}(a),function(){for(var e=0;e<be.length;e++){var t=be[e];t.subs=t.subs.filter((function(e){return e})),t._pending=!1}be.length=0}(),oe&&J.devtools&&oe.emit("flush")}function mn(e){var t=e.id;if(null==an[t]&&(e!==ye.target||!e.noRecurse)){if(an[t]=!0,ln){for(var n=tn.length-1;n>on&&tn[n].id>e.id;)n--;tn.splice(n+1,0,e)}else tn.push(e);rn||(rn=!0,Ot(pn))}}function hn(e,t){if(e){for(var n=Object.create(null),a=de?Reflect.ownKeys(e):Object.keys(e),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){var l=e[i].from;if(l in t._provided)n[i]=t._provided[l];else if("default"in e[i]){var o=e[i].default;n[i]=c(o)?o.call(t):o}else 0}}return n}}function gn(e,t,n,i,l){var s,c=this,d=l.options;C(i,"_uid")?(s=Object.create(i))._original=i:(s=i,i=i._original);var u=o(d._compiled),p=!u;this.data=e,this.props=t,this.children=n,this.parent=i,this.listeners=e.on||a,this.injections=hn(d.inject,i),this.slots=function(){return c.$slots||gt(i,e.scopedSlots,c.$slots=pt(n,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return gt(i,e.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=gt(i,e.scopedSlots,this.$slots)),d._scopeId?this._c=function(e,t,n,a){var l=Ut(s,e,t,n,a,p);return l&&!r(l)&&(l.fnScopeId=d._scopeId,l.fnContext=i),l}:this._c=function(e,t,n,a){return Ut(s,e,t,n,a,p)}}function fn(e,t,n,a,r){var i=fe(e);return i.fnContext=n,i.fnOptions=a,t.slot&&((i.data||(i.data={})).slot=t.slot),i}function vn(e,t){for(var n in t)e[T(n)]=t[n]}function bn(e){return e.name||e.__name||e._componentTag}ut(gn.prototype);var yn={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;yn.prepatch(n,n)}else{(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;l(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns);return new e.componentOptions.Ctor(n)}(e,Kt)).$mount(t?e.elm:void 0,t)}},prepatch:function(e,t){var n=t.componentOptions;!function(e,t,n,r,i){var l=r.data.scopedSlots,o=e.$scopedSlots,s=!!(l&&!l.$stable||o!==a&&!o.$stable||l&&e.$scopedSlots.$key!==l.$key||!l&&e.$scopedSlots.$key),c=!!(i||e.$options._renderChildren||s),d=e.$vnode;e.$options._parentVnode=r,e.$vnode=r,e._vnode&&(e._vnode.parent=r),e.$options._renderChildren=i;var u=r.data.attrs||a;e._attrsProxy&&yt(e._attrsProxy,u,d.data&&d.data.attrs||a,e,"$attrs")&&(c=!0),e.$attrs=u,n=n||a;var p=e.$options._parentListeners;if(e._listenersProxy&&yt(e._listenersProxy,n,p||a,e,"$listeners"),e.$listeners=e.$options._parentListeners=n,Vt(e,n,p),t&&e.$options.props){ke(!1);for(var m=e._props,h=e.$options._propKeys||[],g=0;g<h.length;g++){var f=h[g],v=e.$options.props;m[f]=In(f,v,t,e)}ke(!0),e.$options.propsData=t}c&&(e.$slots=pt(i,r.context),e.$forceUpdate())}(t.componentInstance=e.componentInstance,n.propsData,n.listeners,t,n.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,en(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,nn.push(t)):Yt(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?function e(t,n){if(!(n&&(t._directInactive=!0,Gt(t))||t._inactive)){t._inactive=!0;for(var a=0;a<t.$children.length;a++)e(t.$children[a]);en(t,"deactivated")}}(t,!0):t.$destroy())}},xn=Object.keys(yn);function En(e,t,n,s,c){if(!i(e)){var u=n.$options._base;if(d(e)&&(e=u.extend(e)),"function"==typeof e){var p;if(i(e.cid)&&void 0===(e=function(e,t){if(o(e.error)&&l(e.errorComp))return e.errorComp;if(l(e.resolved))return e.resolved;var n=St;if(n&&l(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n),o(e.loading)&&l(e.loadingComp))return e.loadingComp;if(n&&!l(e.owners)){var a=e.owners=[n],r=!0,s=null,c=null;n.$on("hook:destroyed",(function(){return E(a,n)}));var u=function(e){for(var t=0,n=a.length;t<n;t++)a[t].$forceUpdate();e&&(a.length=0,null!==s&&(clearTimeout(s),s=null),null!==c&&(clearTimeout(c),c=null))},p=O((function(n){e.resolved=Ct(n,t),r?a.length=0:u(!0)})),m=O((function(t){l(e.errorComp)&&(e.error=!0,u(!0))})),h=e(p,m);return d(h)&&(g(h)?i(e.resolved)&&h.then(p,m):g(h.component)&&(h.component.then(p,m),l(h.error)&&(e.errorComp=Ct(h.error,t)),l(h.loading)&&(e.loadingComp=Ct(h.loading,t),0===h.delay?e.loading=!0:s=setTimeout((function(){s=null,i(e.resolved)&&i(e.error)&&(e.loading=!0,u(!1))}),h.delay||200)),l(h.timeout)&&(c=setTimeout((function(){c=null,i(e.resolved)&&m(null)}),h.timeout)))),r=!1,e.loading?e.loadingComp:e.resolved}}(p=e,u)))return function(e,t,n,a,r){var i=he();return i.asyncFactory=e,i.asyncMeta={data:t,context:n,children:a,tag:r},i}(p,t,n,s,c);t=t||{},$n(e),l(t.model)&&function(e,t){var n=e.model&&e.model.prop||"value",a=e.model&&e.model.event||"input";(t.attrs||(t.attrs={}))[n]=t.model.value;var i=t.on||(t.on={}),o=i[a],s=t.model.callback;l(o)?(r(o)?-1===o.indexOf(s):o!==s)&&(i[a]=[s].concat(o)):i[a]=s}(e.options,t);var m=function(e,t,n){var a=t.options.props;if(!i(a)){var r={},o=e.attrs,s=e.props;if(l(o)||l(s))for(var c in a){var d=j(c);Ze(r,s,c,d,!0)||Ze(r,o,c,d,!1)}return r}}(t,e);if(o(e.options.functional))return function(e,t,n,i,o){var s=e.options,c={},d=s.props;if(l(d))for(var u in d)c[u]=In(u,d,t||a);else l(n.attrs)&&vn(c,n.attrs),l(n.props)&&vn(c,n.props);var p=new gn(n,c,o,i,e),m=s.render.call(null,p._c,p);if(m instanceof me)return fn(m,n,p.parent,s,p);if(r(m)){for(var h=Ve(m)||[],g=new Array(h.length),f=0;f<h.length;f++)g[f]=fn(h[f],n,p.parent,s,p);return g}}(e,m,t,n,s);var h=t.on;if(t.on=t.nativeOn,o(e.options.abstract)){var f=t.slot;t={},f&&(t.slot=f)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<xn.length;n++){var a=xn[n],r=t[a],i=yn[a];r===i||r&&r._merged||(t[a]=r?Sn(i,r):i)}}(t);var v=bn(e.options)||c;return new me("vue-component-".concat(e.cid).concat(v?"-".concat(v):""),t,void 0,void 0,void 0,n,{Ctor:e,propsData:m,listeners:h,tag:c,children:s},p)}}}function Sn(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}var Cn=D,wn=J.optionMergeStrategies;function Un(e,t,n){if(void 0===n&&(n=!0),!t)return e;for(var a,r,i,l=de?Reflect.ownKeys(t):Object.keys(t),o=0;o<l.length;o++)"__ob__"!==(a=l[o])&&(r=e[a],i=t[a],n&&C(e,a)?r!==i&&p(r)&&p(i)&&Un(r,i):ze(e,a,i));return e}function Tn(e,t,n){return n?function(){var a=c(t)?t.call(n,n):t,r=c(e)?e.call(n,n):e;return a?Un(a,r):r}:t?e?function(){return Un(c(t)?t.call(this,this):t,c(e)?e.call(this,this):e)}:t:e}function Bn(e,t){var n=t?e?e.concat(t):r(t)?t:[t]:e;return n?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(n):n}function kn(e,t,n,a){var r=Object.create(e||null);return t?I(r,t):r}wn.data=function(e,t,n){return n?Tn(e,t,n):t&&"function"!=typeof t?e:Tn(e,t)},N.forEach((function(e){wn[e]=Bn})),R.forEach((function(e){wn[e+"s"]=kn})),wn.watch=function(e,t,n,a){if(e===ae&&(e=void 0),t===ae&&(t=void 0),!t)return Object.create(e||null);if(!e)return t;var i={};for(var l in I(i,e),t){var o=i[l],s=t[l];o&&!r(o)&&(o=[o]),i[l]=o?o.concat(s):r(s)?s:[s]}return i},wn.props=wn.methods=wn.inject=wn.computed=function(e,t,n,a){if(!e)return t;var r=Object.create(null);return I(r,e),t&&I(r,t),r},wn.provide=function(e,t){return e?function(){var n=Object.create(null);return Un(n,c(e)?e.call(this):e),t&&Un(n,c(t)?t.call(this):t,!1),n}:t};var jn=function(e,t){return void 0===t?e:t};function An(e,t,n){if(c(t)&&(t=t.options),function(e,t){var n=e.props;if(n){var a,i,l={};if(r(n))for(a=n.length;a--;)"string"==typeof(i=n[a])&&(l[T(i)]={type:null});else if(p(n))for(var o in n)i=n[o],l[T(o)]=p(i)?i:{type:i};else 0;e.props=l}}(t),function(e,t){var n=e.inject;if(n){var a=e.inject={};if(r(n))for(var i=0;i<n.length;i++)a[n[i]]={from:n[i]};else if(p(n))for(var l in n){var o=n[l];a[l]=p(o)?I({from:l},o):{from:o}}else 0}}(t),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];c(a)&&(t[n]={bind:a,update:a})}}(t),!t._base&&(t.extends&&(e=An(e,t.extends,n)),t.mixins))for(var a=0,i=t.mixins.length;a<i;a++)e=An(e,t.mixins[a],n);var l,o={};for(l in e)s(l);for(l in t)C(e,l)||s(l);function s(a){var r=wn[a]||jn;o[a]=r(e[a],t[a],n,a)}return o}function Hn(e,t,n,a){if("string"==typeof n){var r=e[t];if(C(r,n))return r[n];var i=T(n);if(C(r,i))return r[i];var l=B(i);return C(r,l)?r[l]:r[n]||r[i]||r[l]}}function In(e,t,n,a){var r=t[e],i=!C(n,e),l=n[e],o=Pn(Boolean,r.type);if(o>-1)if(i&&!C(r,"default"))l=!1;else if(""===l||l===j(e)){var s=Pn(String,r.type);(s<0||o<s)&&(l=!0)}if(void 0===l){l=function(e,t,n){if(!C(t,"default"))return;var a=t.default;0;if(e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n])return e._props[n];return c(a)&&"Function"!==Dn(t.type)?a.call(e):a}(a,r,e);var d=Be;ke(!0),He(l),ke(d)}return l}var zn=/^\s*function (\w+)/;function Dn(e){var t=e&&e.toString().match(zn);return t?t[1]:""}function Fn(e,t){return Dn(e)===Dn(t)}function Pn(e,t){if(!r(t))return Fn(t,e)?0:-1;for(var n=0,a=t.length;n<a;n++)if(Fn(t[n],e))return n;return-1}var _n={enumerable:!0,configurable:!0,get:D,set:D};function Ln(e,t,n){_n.get=function(){return this[t][n]},_n.set=function(e){this[t][n]=e},Object.defineProperty(e,n,_n)}function On(e){var t=e.$options;if(t.props&&function(e,t){var n=e.$options.propsData||{},a=e._props=Pe({}),r=e.$options._propKeys=[];e.$parent&&ke(!1);var i=function(i){r.push(i);var l=In(i,t,n,e);Ie(a,i,l,void 0,!0),i in e||Ln(e,"_props",i)};for(var l in t)i(l);ke(!0)}(e,t.props),function(e){var t=e.$options,n=t.setup;if(n){var a=e._setupContext=bt(e);pe(e),Ee();var r=Bt(n,null,[e._props||Pe({}),a],e,"setup");if(Se(),pe(),c(r))t.render=r;else if(d(r))if(e._setupState=r,r.__sfc){var i=e._setupProxy={};for(var l in r)"__sfc"!==l&&Me(i,r,l)}else for(var l in r)W(l)||Me(e,r,l);else 0}}(e),t.methods&&function(e,t){e.$options.props;for(var n in t)e[n]="function"!=typeof t[n]?D:A(t[n],e)}(e,t.methods),t.data)!function(e){var t=e.$options.data;p(t=e._data=c(t)?function(e,t){Ee();try{return e.call(t,t)}catch(e){return Tt(e,t,"data()"),{}}finally{Se()}}(t,e):t||{})||(t={});var n=Object.keys(t),a=e.$options.props,r=(e.$options.methods,n.length);for(;r--;){var i=n[r];0,a&&C(a,i)||W(i)||Ln(e,"_data",i)}var l=He(t);l&&l.vmCount++}(e);else{var n=He(e._data={});n&&n.vmCount++}t.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=le();for(var r in t){var i=t[r],l=c(i)?i:i.get;0,a||(n[r]=new Wt(e,l||D,D,Mn)),r in e||Rn(e,r,i)}}(e,t.computed),t.watch&&t.watch!==ae&&function(e,t){for(var n in t){var a=t[n];if(r(a))for(var i=0;i<a.length;i++)qn(e,n,a[i]);else qn(e,n,a)}}(e,t.watch)}var Mn={lazy:!0};function Rn(e,t,n){var a=!le();c(n)?(_n.get=a?Nn(t):Jn(n),_n.set=D):(_n.get=n.get?a&&!1!==n.cache?Nn(t):Jn(n.get):D,_n.set=n.set||D),Object.defineProperty(e,t,_n)}function Nn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),ye.target&&t.depend(),t.value}}function Jn(e){return function(){return e.call(this,this)}}function qn(e,t,n,a){return p(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}var Wn=0;function $n(e){var t=e.options;if(e.super){var n=$n(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var r in n)n[r]!==a[r]&&(t||(t={}),t[r]=n[r]);return t}(e);a&&I(e.extendOptions,a),(t=e.options=An(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function Xn(e){this._init(e)}function Zn(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,r=e._Ctor||(e._Ctor={});if(r[a])return r[a];var i=bn(e)||bn(n.options);var l=function(e){this._init(e)};return(l.prototype=Object.create(n.prototype)).constructor=l,l.cid=t++,l.options=An(n.options,e),l.super=n,l.options.props&&function(e){var t=e.options.props;for(var n in t)Ln(e.prototype,"_props",n)}(l),l.options.computed&&function(e){var t=e.options.computed;for(var n in t)Rn(e.prototype,n,t[n])}(l),l.extend=n.extend,l.mixin=n.mixin,l.use=n.use,R.forEach((function(e){l[e]=n[e]})),i&&(l.options.components[i]=l),l.superOptions=n.options,l.extendOptions=e,l.sealedOptions=I({},l.options),r[a]=l,l}}function Vn(e){return e&&(bn(e.Ctor.options)||e.tag)}function Kn(e,t){return r(e)?e.indexOf(t)>-1:"string"==typeof e?e.split(",").indexOf(t)>-1:!!m(e)&&e.test(t)}function Qn(e,t){var n=e.cache,a=e.keys,r=e._vnode,i=e.$vnode;for(var l in n){var o=n[l];if(o){var s=o.name;s&&!t(s)&&Gn(n,l,a,r)}}i.componentOptions.children=void 0}function Gn(e,t,n,a){var r=e[t];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),e[t]=null,E(n,t)}!function(e){e.prototype._init=function(e){var t=this;t._uid=Wn++,t._isVue=!0,t.__v_skip=!0,t._scope=new Ne(!0),t._scope.parent=void 0,t._scope._vm=!0,e&&e._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var r=a.componentOptions;n.propsData=r.propsData,n._parentListeners=r.listeners,n._renderChildren=r.children,n._componentTag=r.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(t,e):t.$options=An($n(t.constructor),e||{},t),t._renderProxy=t,t._self=t,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._provided=n?n._provided:Object.create(null),e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(t),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&Vt(e,t)}(t),function(e){e._vnode=null,e._staticTrees=null;var t=e.$options,n=e.$vnode=t._parentVnode,r=n&&n.context;e.$slots=pt(t._renderChildren,r),e.$scopedSlots=n?gt(e.$parent,n.data.scopedSlots,e.$slots):a,e._c=function(t,n,a,r){return Ut(e,t,n,a,r,!1)},e.$createElement=function(t,n,a,r){return Ut(e,t,n,a,r,!0)};var i=n&&n.data;Ie(e,"$attrs",i&&i.attrs||a,null,!0),Ie(e,"$listeners",t._parentListeners||a,null,!0)}(t),en(t,"beforeCreate",void 0,!1),function(e){var t=hn(e.$options.inject,e);t&&(ke(!1),Object.keys(t).forEach((function(n){Ie(e,n,t[n])})),ke(!0))}(t),On(t),function(e){var t=e.$options.provide;if(t){var n=c(t)?t.call(e):t;if(!d(n))return;for(var a=Je(e),r=de?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var l=r[i];Object.defineProperty(a,l,Object.getOwnPropertyDescriptor(n,l))}}}(t),en(t,"created"),t.$options.el&&t.$mount(t.$options.el)}}(Xn),function(e){var t={get:function(){return this._data}},n={get:function(){return this._props}};Object.defineProperty(e.prototype,"$data",t),Object.defineProperty(e.prototype,"$props",n),e.prototype.$set=ze,e.prototype.$delete=De,e.prototype.$watch=function(e,t,n){if(p(t))return qn(this,e,t,n);(n=n||{}).user=!0;var a=new Wt(this,e,t,n);if(n.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');Ee(),Bt(t,this,[a.value],this,r),Se()}return function(){a.teardown()}}}(Xn),function(e){var t=/^hook:/;e.prototype.$on=function(e,n){var a=this;if(r(e))for(var i=0,l=e.length;i<l;i++)a.$on(e[i],n);else(a._events[e]||(a._events[e]=[])).push(n),t.test(e)&&(a._hasHookEvent=!0);return a},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,t){var n=this;if(!arguments.length)return n._events=Object.create(null),n;if(r(e)){for(var a=0,i=e.length;a<i;a++)n.$off(e[a],t);return n}var l,o=n._events[e];if(!o)return n;if(!t)return n._events[e]=null,n;for(var s=o.length;s--;)if((l=o[s])===t||l.fn===t){o.splice(s,1);break}return n},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?H(n):n;for(var a=H(arguments,1),r='event handler for "'.concat(e,'"'),i=0,l=n.length;i<l;i++)Bt(n[i],t,a,t,r)}return t}}(Xn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,r=n._vnode,i=Qt(n);n._vnode=e,n.$el=r?n.__patch__(r,e):n.__patch__(n.$el,e,t,!1),i(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n);for(var l=n;l&&l.$vnode&&l.$parent&&l.$vnode===l.$parent._vnode;)l.$parent.$el=l.$el,l=l.$parent},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){en(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||E(t.$children,e),e._scope.stop(),e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),en(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Xn),function(e){ut(e.prototype),e.prototype.$nextTick=function(e){return Ot(e,this)},e.prototype._render=function(){var e=this,t=e.$options,n=t.render,a=t._parentVnode;a&&e._isMounted&&(e.$scopedSlots=gt(e.$parent,a.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&Et(e._slotsProxy,e.$scopedSlots)),e.$vnode=a;var i,l=ue,o=St;try{pe(e),St=e,i=n.call(e._renderProxy,e.$createElement)}catch(t){Tt(t,e,"render"),i=e._vnode}finally{St=o,pe(l)}return r(i)&&1===i.length&&(i=i[0]),i instanceof me||(i=he()),i.parent=a,i}}(Xn);var Yn=[String,RegExp,Array],ea={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yn,exclude:Yn,max:[String,Number]},methods:{cacheVNode:function(){var e=this.cache,t=this.keys,n=this.vnodeToCache,a=this.keyToCache;if(n){var r=n.tag,i=n.componentInstance,l=n.componentOptions;e[a]={name:Vn(l),tag:r,componentInstance:i},t.push(a),this.max&&t.length>parseInt(this.max)&&Gn(e,t[0],t,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Gn(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){Qn(e,(function(e){return Kn(t,e)}))})),this.$watch("exclude",(function(t){Qn(e,(function(e){return!Kn(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=wt(e),n=t&&t.componentOptions;if(n){var a=Vn(n),r=this.include,i=this.exclude;if(r&&(!a||!Kn(r,a))||i&&a&&Kn(i,a))return t;var l=this.cache,o=this.keys,s=null==t.key?n.Ctor.cid+(n.tag?"::".concat(n.tag):""):t.key;l[s]?(t.componentInstance=l[s].componentInstance,E(o,s),o.push(s)):(this.vnodeToCache=t,this.keyToCache=s),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return J}};Object.defineProperty(e,"config",t),e.util={warn:Cn,extend:I,mergeOptions:An,defineReactive:Ie},e.set=ze,e.delete=De,e.nextTick=Ot,e.observable=function(e){return He(e),e},e.options=Object.create(null),R.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,I(e.options.components,ea),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=H(arguments,1);return n.unshift(this),c(e.install)?e.install.apply(e,n):c(e)&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=An(this.options,e),this}}(e),Zn(e),function(e){R.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&p(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&c(n)&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(Xn),Object.defineProperty(Xn.prototype,"$isServer",{get:le}),Object.defineProperty(Xn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Xn,"FunctionalRenderContext",{value:gn}),Xn.version="https://doc.hutool.cn/assets/js/2.7.16";var ta=y("style,class"),na=y("input,textarea,option,select,progress"),aa=y("contenteditable,draggable,spellcheck"),ra=y("events,caret,typing,plaintext-only"),ia=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),la="http://www.w3.org/1999/xlink",oa=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},sa=function(e){return oa(e)?e.slice(6,e.length):""},ca=function(e){return null==e||!1===e};function da(e){for(var t=e.data,n=e,a=e;l(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=ua(a.data,t));for(;l(n=n.parent);)n&&n.data&&(t=ua(t,n.data));return function(e,t){if(l(e)||l(t))return pa(e,ma(t));return""}(t.staticClass,t.class)}function ua(e,t){return{staticClass:pa(e.staticClass,t.staticClass),class:l(e.class)?[e.class,t.class]:t.class}}function pa(e,t){return e?t?e+" "+t:e:t||""}function ma(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,r=e.length;a<r;a++)l(t=ma(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):d(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var ha={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ga=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fa=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),va=function(e){return ga(e)||fa(e)};var ba=Object.create(null);var ya=y("text,number,password,search,email,tel,url");var xa=Object.freeze({__proto__:null,createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(ha[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),Ea={create:function(e,t){Sa(t)},update:function(e,t){e.data.ref!==t.data.ref&&(Sa(e,!0),Sa(t))},destroy:function(e){Sa(e,!0)}};function Sa(e,t){var n=e.data.ref;if(l(n)){var a=e.context,i=e.componentInstance||e.elm,o=t?null:i,s=t?void 0:i;if(c(n))Bt(n,a,[o],a,"template ref function");else{var d=e.data.refInFor,u="string"==typeof n||"number"==typeof n,p=Oe(n),m=a.$refs;if(u||p)if(d){var h=u?m[n]:n.value;t?r(h)&&E(h,i):r(h)?h.includes(i)||h.push(i):u?(m[n]=[i],Ca(a,n,m[n])):n.value=[i]}else if(u){if(t&&m[n]!==i)return;m[n]=s,Ca(a,n,o)}else if(p){if(t&&n.value!==i)return;n.value=o}else 0}}}function Ca(e,t,n){var a=e._setupState;a&&C(a,t)&&(Oe(a[t])?a[t].value=n:a[t]=n)}var wa=new me("",{},[]),Ua=["create","activate","update","remove","destroy"];function Ta(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&l(e.data)===l(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=l(n=e.data)&&l(n=n.attrs)&&n.type,r=l(n=t.data)&&l(n=n.attrs)&&n.type;return a===r||ya(a)&&ya(r)}(e,t)||o(e.isAsyncPlaceholder)&&i(t.asyncFactory.error))}function Ba(e,t,n){var a,r,i={};for(a=t;a<=n;++a)l(r=e[a].key)&&(i[r]=a);return i}var ka={create:ja,update:ja,destroy:function(e){ja(e,wa)}};function ja(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,r,i=e===wa,l=t===wa,o=Ha(e.data.directives,e.context),s=Ha(t.data.directives,t.context),c=[],d=[];for(n in s)a=o[n],r=s[n],a?(r.oldValue=a.value,r.oldArg=a.arg,za(r,"update",t,e),r.def&&r.def.componentUpdated&&d.push(r)):(za(r,"bind",t,e),r.def&&r.def.inserted&&c.push(r));if(c.length){var u=function(){for(var n=0;n<c.length;n++)za(c[n],"inserted",t,e)};i?Xe(t,"insert",u):u()}d.length&&Xe(t,"postpatch",(function(){for(var n=0;n<d.length;n++)za(d[n],"componentUpdated",t,e)}));if(!i)for(n in o)s[n]||za(o[n],"unbind",e,e,l)}(e,t)}var Aa=Object.create(null);function Ha(e,t){var n,a,r=Object.create(null);if(!e)return r;for(n=0;n<e.length;n++){if((a=e[n]).modifiers||(a.modifiers=Aa),r[Ia(a)]=a,t._setupState&&t._setupState.__sfc){var i=a.def||Hn(t,"_setupState","v-"+a.name);a.def="function"==typeof i?{bind:i,update:i}:i}a.def=a.def||Hn(t.$options,"directives",a.name)}return r}function Ia(e){return e.rawName||"".concat(e.name,".").concat(Object.keys(e.modifiers||{}).join("."))}function za(e,t,n,a,r){var i=e.def&&e.def[t];if(i)try{i(n.elm,e,n,a,r)}catch(a){Tt(a,n.context,"directive ".concat(e.name," ").concat(t," hook"))}}var Da=[Ea,ka];function Fa(e,t){var n=t.componentOptions;if(!(l(n)&&!1===n.Ctor.options.inheritAttrs||i(e.data.attrs)&&i(t.data.attrs))){var a,r,s=t.elm,c=e.data.attrs||{},d=t.data.attrs||{};for(a in(l(d.__ob__)||o(d._v_attr_proxy))&&(d=t.data.attrs=I({},d)),d)r=d[a],c[a]!==r&&Pa(s,a,r,t.data.pre);for(a in(Q||Y)&&d.value!==c.value&&Pa(s,"value",d.value),c)i(d[a])&&(oa(a)?s.removeAttributeNS(la,sa(a)):aa(a)||s.removeAttribute(a))}}function Pa(e,t,n,a){a||e.tagName.indexOf("-")>-1?_a(e,t,n):ia(t)?ca(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):aa(t)?e.setAttribute(t,function(e,t){return ca(t)||"false"===t?"false":"contenteditable"===e&&ra(t)?t:"true"}(t,n)):oa(t)?ca(n)?e.removeAttributeNS(la,sa(t)):e.setAttributeNS(la,t,n):_a(e,t,n)}function _a(e,t,n){if(ca(n))e.removeAttribute(t);else{if(Q&&!G&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var La={create:Fa,update:Fa};function Oa(e,t){var n=t.elm,a=t.data,r=e.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var o=da(t),s=n._transitionClasses;l(s)&&(o=pa(o,ma(s))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}var Ma,Ra={create:Oa,update:Oa};function Na(e,t,n){var a=Ma;return function r(){var i=t.apply(null,arguments);null!==i&&Wa(e,r,n,a)}}var Ja=Ht&&!(ne&&Number(ne[1])<=53);function qa(e,t,n,a){if(Ja){var r=sn,i=t;t=i._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=r||e.timeStamp<=0||e.target.ownerDocument!==document)return i.apply(this,arguments)}}Ma.addEventListener(e,t,re?{capture:n,passive:a}:n)}function Wa(e,t,n,a){(a||Ma).removeEventListener(e,t._wrapper||t,n)}function $a(e,t){if(!i(e.data.on)||!i(t.data.on)){var n=t.data.on||{},a=e.data.on||{};Ma=t.elm||e.elm,function(e){if(l(e.__r)){var t=Q?"change":"input";e[t]=[].concat(e.__r,e[t]||[]),delete e.__r}l(e.__c)&&(e.change=[].concat(e.__c,e.change||[]),delete e.__c)}(n),$e(n,a,qa,Wa,Na,t.context),Ma=void 0}}var Xa,Za={create:$a,update:$a,destroy:function(e){return $a(e,wa)}};function Va(e,t){if(!i(e.data.domProps)||!i(t.data.domProps)){var n,a,r=t.elm,s=e.data.domProps||{},c=t.data.domProps||{};for(n in(l(c.__ob__)||o(c._v_attr_proxy))&&(c=t.data.domProps=I({},c)),s)n in c||(r[n]="");for(n in c){if(a=c[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),a===s[n])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===n&&"PROGRESS"!==r.tagName){r._value=a;var d=i(a)?"":String(a);Ka(r,d)&&(r.value=d)}else if("innerHTML"===n&&fa(r.tagName)&&i(r.innerHTML)){(Xa=Xa||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var u=Xa.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;u.firstChild;)r.appendChild(u.firstChild)}else if(a!==s[n])try{r[n]=a}catch(e){}}}}function Ka(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(l(a)){if(a.number)return b(n)!==b(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var Qa={create:Va,update:Va},Ga=w((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function Ya(e){var t=er(e.style);return e.staticStyle?I(e.staticStyle,t):t}function er(e){return Array.isArray(e)?z(e):"string"==typeof e?Ga(e):e}var tr,nr=/^--/,ar=/\s*!important$/,rr=function(e,t,n){if(nr.test(t))e.style.setProperty(t,n);else if(ar.test(n))e.style.setProperty(j(t),n.replace(ar,""),"important");else{var a=lr(t);if(Array.isArray(n))for(var r=0,i=n.length;r<i;r++)e.style[a]=n[r];else e.style[a]=n}},ir=["Webkit","Moz","ms"],lr=w((function(e){if(tr=tr||document.createElement("div").style,"filter"!==(e=T(e))&&e in tr)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<ir.length;n++){var a=ir[n]+t;if(a in tr)return a}}));function or(e,t){var n=t.data,a=e.data;if(!(i(n.staticStyle)&&i(n.style)&&i(a.staticStyle)&&i(a.style))){var r,o,s=t.elm,c=a.staticStyle,d=a.normalizedStyle||a.style||{},u=c||d,p=er(t.data.style)||{};t.data.normalizedStyle=l(p.__ob__)?I({},p):p;var m=function(e,t){var n,a={};if(t)for(var r=e;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(n=Ya(r.data))&&I(a,n);(n=Ya(e.data))&&I(a,n);for(var i=e;i=i.parent;)i.data&&(n=Ya(i.data))&&I(a,n);return a}(t,!0);for(o in u)i(m[o])&&rr(s,o,"");for(o in m)r=m[o],rr(s,o,null==r?"":r)}}var sr={create:or,update:or},cr=/\s+/;function dr(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(cr).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" ".concat(e.getAttribute("class")||""," ");n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function ur(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(cr).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" ".concat(e.getAttribute("class")||""," "),a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function pr(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&I(t,mr(e.name||"v")),I(t,e),t}return"string"==typeof e?mr(e):void 0}}var mr=w((function(e){return{enterClass:"".concat(e,"-enter"),enterToClass:"".concat(e,"-enter-to"),enterActiveClass:"".concat(e,"-enter-active"),leaveClass:"".concat(e,"-leave"),leaveToClass:"".concat(e,"-leave-to"),leaveActiveClass:"".concat(e,"-leave-active")}})),hr=V&&!G,gr="transition",fr="transitionend",vr="animation",br="animationend";hr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(gr="WebkitTransition",fr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(vr="WebkitAnimation",br="webkitAnimationEnd"));var yr=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function xr(e){yr((function(){yr(e)}))}function Er(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),dr(e,t))}function Sr(e,t){e._transitionClasses&&E(e._transitionClasses,t),ur(e,t)}function Cr(e,t,n){var a=Ur(e,t),r=a.type,i=a.timeout,l=a.propCount;if(!r)return n();var o="transition"===r?fr:br,s=0,c=function(){e.removeEventListener(o,d),n()},d=function(t){t.target===e&&++s>=l&&c()};setTimeout((function(){s<l&&c()}),i+1),e.addEventListener(o,d)}var wr=/\b(transform|all)(,|$)/;function Ur(e,t){var n,a=window.getComputedStyle(e),r=(a[gr+"Delay"]||"").split(", "),i=(a[gr+"Duration"]||"").split(", "),l=Tr(r,i),o=(a[vr+"Delay"]||"").split(", "),s=(a[vr+"Duration"]||"").split(", "),c=Tr(o,s),d=0,u=0;return"transition"===t?l>0&&(n="transition",d=l,u=i.length):"animation"===t?c>0&&(n="animation",d=c,u=s.length):u=(n=(d=Math.max(l,c))>0?l>c?"transition":"animation":null)?"transition"===n?i.length:s.length:0,{type:n,timeout:d,propCount:u,hasTransform:"transition"===n&&wr.test(a[gr+"Property"])}}function Tr(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return Br(t)+Br(e[n])})))}function Br(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function kr(e,t){var n=e.elm;l(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var a=pr(e.data.transition);if(!i(a)&&!l(n._enterCb)&&1===n.nodeType){for(var r=a.css,o=a.type,s=a.enterClass,u=a.enterToClass,p=a.enterActiveClass,m=a.appearClass,h=a.appearToClass,g=a.appearActiveClass,f=a.beforeEnter,v=a.enter,y=a.afterEnter,x=a.enterCancelled,E=a.beforeAppear,S=a.appear,C=a.afterAppear,w=a.appearCancelled,U=a.duration,T=Kt,B=Kt.$vnode;B&&B.parent;)T=B.context,B=B.parent;var k=!T._isMounted||!e.isRootInsert;if(!k||S||""===S){var j=k&&m?m:s,A=k&&g?g:p,H=k&&h?h:u,I=k&&E||f,z=k&&c(S)?S:v,D=k&&C||y,F=k&&w||x,P=b(d(U)?U.enter:U);0;var _=!1!==r&&!G,L=Hr(z),M=n._enterCb=O((function(){_&&(Sr(n,H),Sr(n,A)),M.cancelled?(_&&Sr(n,j),F&&F(n)):D&&D(n),n._enterCb=null}));e.data.show||Xe(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),z&&z(n,M)})),I&&I(n),_&&(Er(n,j),Er(n,A),xr((function(){Sr(n,j),M.cancelled||(Er(n,H),L||(Ar(P)?setTimeout(M,P):Cr(n,o,M)))}))),e.data.show&&(t&&t(),z&&z(n,M)),_||L||M()}}}function jr(e,t){var n=e.elm;l(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var a=pr(e.data.transition);if(i(a)||1!==n.nodeType)return t();if(!l(n._leaveCb)){var r=a.css,o=a.type,s=a.leaveClass,c=a.leaveToClass,u=a.leaveActiveClass,p=a.beforeLeave,m=a.leave,h=a.afterLeave,g=a.leaveCancelled,f=a.delayLeave,v=a.duration,y=!1!==r&&!G,x=Hr(m),E=b(d(v)?v.leave:v);0;var S=n._leaveCb=O((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),y&&(Sr(n,c),Sr(n,u)),S.cancelled?(y&&Sr(n,s),g&&g(n)):(t(),h&&h(n)),n._leaveCb=null}));f?f(C):C()}function C(){S.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),p&&p(n),y&&(Er(n,s),Er(n,u),xr((function(){Sr(n,s),S.cancelled||(Er(n,c),x||(Ar(E)?setTimeout(S,E):Cr(n,o,S)))}))),m&&m(n,S),y||x||S())}}function Ar(e){return"number"==typeof e&&!isNaN(e)}function Hr(e){if(i(e))return!1;var t=e.fns;return l(t)?Hr(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function Ir(e,t){!0!==t.data.show&&kr(t)}var zr=function(e){var t,n,a={},c=e.modules,d=e.nodeOps;for(t=0;t<Ua.length;++t)for(a[Ua[t]]=[],n=0;n<c.length;++n)l(c[n][Ua[t]])&&a[Ua[t]].push(c[n][Ua[t]]);function u(e){var t=d.parentNode(e);l(t)&&d.removeChild(t,e)}function p(e,t,n,r,i,s,c){if(l(e.elm)&&l(s)&&(e=s[c]=fe(e)),e.isRootInsert=!i,!function(e,t,n,r){var i=e.data;if(l(i)){var s=l(e.componentInstance)&&i.keepAlive;if(l(i=i.hook)&&l(i=i.init)&&i(e,!1),l(e.componentInstance))return m(e,t),h(n,e.elm,r),o(s)&&function(e,t,n,r){var i,o=e;for(;o.componentInstance;)if(o=o.componentInstance._vnode,l(i=o.data)&&l(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](wa,o);t.push(o);break}h(n,e.elm,r)}(e,t,n,r),!0}}(e,t,n,r)){var u=e.data,p=e.children,f=e.tag;l(f)?(e.elm=e.ns?d.createElementNS(e.ns,f):d.createElement(f,e),b(e),g(e,p,t),l(u)&&v(e,t),h(n,e.elm,r)):o(e.isComment)?(e.elm=d.createComment(e.text),h(n,e.elm,r)):(e.elm=d.createTextNode(e.text),h(n,e.elm,r))}}function m(e,t){l(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,f(e)?(v(e,t),b(e)):(Sa(e),t.push(e))}function h(e,t,n){l(e)&&(l(n)?d.parentNode(n)===e&&d.insertBefore(e,t,n):d.appendChild(e,t))}function g(e,t,n){if(r(t)){0;for(var a=0;a<t.length;++a)p(t[a],n,e.elm,null,!0,t,a)}else s(e.text)&&d.appendChild(e.elm,d.createTextNode(String(e.text)))}function f(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return l(e.tag)}function v(e,n){for(var r=0;r<a.create.length;++r)a.create[r](wa,e);l(t=e.data.hook)&&(l(t.create)&&t.create(wa,e),l(t.insert)&&n.push(e))}function b(e){var t;if(l(t=e.fnScopeId))d.setStyleScope(e.elm,t);else for(var n=e;n;)l(t=n.context)&&l(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t),n=n.parent;l(t=Kt)&&t!==e.context&&t!==e.fnContext&&l(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t)}function x(e,t,n,a,r,i){for(;a<=r;++a)p(n[a],i,e,t,!1,n,a)}function E(e){var t,n,r=e.data;if(l(r))for(l(t=r.hook)&&l(t=t.destroy)&&t(e),t=0;t<a.destroy.length;++t)a.destroy[t](e);if(l(t=e.children))for(n=0;n<e.children.length;++n)E(e.children[n])}function S(e,t,n){for(;t<=n;++t){var a=e[t];l(a)&&(l(a.tag)?(C(a),E(a)):u(a.elm))}}function C(e,t){if(l(t)||l(e.data)){var n,r=a.remove.length+1;for(l(t)?t.listeners+=r:t=function(e,t){function n(){0==--n.listeners&&u(e)}return n.listeners=t,n}(e.elm,r),l(n=e.componentInstance)&&l(n=n._vnode)&&l(n.data)&&C(n,t),n=0;n<a.remove.length;++n)a.remove[n](e,t);l(n=e.data.hook)&&l(n=n.remove)?n(e,t):t()}else u(e.elm)}function w(e,t,n,a){for(var r=n;r<a;r++){var i=t[r];if(l(i)&&Ta(e,i))return r}}function U(e,t,n,r,s,c){if(e!==t){l(t.elm)&&l(r)&&(t=r[s]=fe(t));var u=t.elm=e.elm;if(o(e.isAsyncPlaceholder))l(t.asyncFactory.resolved)?k(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(o(t.isStatic)&&o(e.isStatic)&&t.key===e.key&&(o(t.isCloned)||o(t.isOnce)))t.componentInstance=e.componentInstance;else{var m,h=t.data;l(h)&&l(m=h.hook)&&l(m=m.prepatch)&&m(e,t);var g=e.children,v=t.children;if(l(h)&&f(t)){for(m=0;m<a.update.length;++m)a.update[m](e,t);l(m=h.hook)&&l(m=m.update)&&m(e,t)}i(t.text)?l(g)&&l(v)?g!==v&&function(e,t,n,a,r){var o,s,c,u=0,m=0,h=t.length-1,g=t[0],f=t[h],v=n.length-1,b=n[0],y=n[v],E=!r;for(0;u<=h&&m<=v;)i(g)?g=t[++u]:i(f)?f=t[--h]:Ta(g,b)?(U(g,b,a,n,m),g=t[++u],b=n[++m]):Ta(f,y)?(U(f,y,a,n,v),f=t[--h],y=n[--v]):Ta(g,y)?(U(g,y,a,n,v),E&&d.insertBefore(e,g.elm,d.nextSibling(f.elm)),g=t[++u],y=n[--v]):Ta(f,b)?(U(f,b,a,n,m),E&&d.insertBefore(e,f.elm,g.elm),f=t[--h],b=n[++m]):(i(o)&&(o=Ba(t,u,h)),i(s=l(b.key)?o[b.key]:w(b,t,u,h))?p(b,a,e,g.elm,!1,n,m):Ta(c=t[s],b)?(U(c,b,a,n,m),t[s]=void 0,E&&d.insertBefore(e,c.elm,g.elm)):p(b,a,e,g.elm,!1,n,m),b=n[++m]);u>h?x(e,i(n[v+1])?null:n[v+1].elm,n,m,v,a):m>v&&S(t,u,h)}(u,g,v,n,c):l(v)?(l(e.text)&&d.setTextContent(u,""),x(u,null,v,0,v.length-1,n)):l(g)?S(g,0,g.length-1):l(e.text)&&d.setTextContent(u,""):e.text!==t.text&&d.setTextContent(u,t.text),l(h)&&l(m=h.hook)&&l(m=m.postpatch)&&m(e,t)}}}function T(e,t,n){if(o(n)&&l(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var B=y("attrs,class,staticClass,staticStyle,key");function k(e,t,n,a){var r,i=t.tag,s=t.data,c=t.children;if(a=a||s&&s.pre,t.elm=e,o(t.isComment)&&l(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(l(s)&&(l(r=s.hook)&&l(r=r.init)&&r(t,!0),l(r=t.componentInstance)))return m(t,n),!0;if(l(i)){if(l(c))if(e.hasChildNodes())if(l(r=s)&&l(r=r.domProps)&&l(r=r.innerHTML)){if(r!==e.innerHTML)return!1}else{for(var d=!0,u=e.firstChild,p=0;p<c.length;p++){if(!u||!k(u,c[p],n,a)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else g(t,c,n);if(l(s)){var h=!1;for(var f in s)if(!B(f)){h=!0,v(t,n);break}!h&&s.class&&Nt(s.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,r){if(!i(t)){var s,c=!1,u=[];if(i(e))c=!0,p(t,u);else{var m=l(e.nodeType);if(!m&&Ta(e,t))U(e,t,u,null,null,r);else{if(m){if(1===e.nodeType&&e.hasAttribute("data-server-rendered")&&(e.removeAttribute("data-server-rendered"),n=!0),o(n)&&k(e,t,u))return T(t,u,!0),e;s=e,e=new me(d.tagName(s).toLowerCase(),{},[],void 0,s)}var h=e.elm,g=d.parentNode(h);if(p(t,u,h._leaveCb?null:g,d.nextSibling(h)),l(t.parent))for(var v=t.parent,b=f(t);v;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](v);if(v.elm=t.elm,b){for(var x=0;x<a.create.length;++x)a.create[x](wa,v);var C=v.data.hook.insert;if(C.merged)for(var w=C.fns.slice(1),B=0;B<w.length;B++)w[B]()}else Sa(v);v=v.parent}l(g)?S([e],0,0):l(e.tag)&&E(e)}}return T(t,u,c),t.elm}l(e)&&E(e)}}({nodeOps:xa,modules:[La,Ra,Za,Qa,sr,V?{create:Ir,activate:Ir,remove:function(e,t){!0!==e.data.show?jr(e,t):t()}}:{}].concat(Da)});G&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&Rr(e,"input")}));var Dr={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?Xe(n,"postpatch",(function(){Dr.componentUpdated(e,t,n)})):Fr(e,t,n.context),e._vOptions=[].map.call(e.options,Lr)):("textarea"===n.tag||ya(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",Or),e.addEventListener("compositionend",Mr),e.addEventListener("change",Mr),G&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){Fr(e,t,n.context);var a=e._vOptions,r=e._vOptions=[].map.call(e.options,Lr);if(r.some((function(e,t){return!_(e,a[t])})))(e.multiple?t.value.some((function(e){return _r(e,r)})):t.value!==t.oldValue&&_r(t.value,r))&&Rr(e,"change")}}};function Fr(e,t,n){Pr(e,t,n),(Q||Y)&&setTimeout((function(){Pr(e,t,n)}),0)}function Pr(e,t,n){var a=t.value,r=e.multiple;if(!r||Array.isArray(a)){for(var i,l,o=0,s=e.options.length;o<s;o++)if(l=e.options[o],r)i=L(a,Lr(l))>-1,l.selected!==i&&(l.selected=i);else if(_(Lr(l),a))return void(e.selectedIndex!==o&&(e.selectedIndex=o));r||(e.selectedIndex=-1)}}function _r(e,t){return t.every((function(t){return!_(t,e)}))}function Lr(e){return"_value"in e?e._value:e.value}function Or(e){e.target.composing=!0}function Mr(e){e.target.composing&&(e.target.composing=!1,Rr(e.target,"input"))}function Rr(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function Nr(e){return!e.componentInstance||e.data&&e.data.transition?e:Nr(e.componentInstance._vnode)}var Jr={model:Dr,show:{bind:function(e,t,n){var a=t.value,r=(n=Nr(n)).data&&n.data.transition,i=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&r?(n.data.show=!0,kr(n,(function(){e.style.display=i}))):e.style.display=a?i:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=Nr(n)).data&&n.data.transition?(n.data.show=!0,a?kr(n,(function(){e.style.display=e.__vOriginalDisplay})):jr(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,r){r||(e.style.display=e.__vOriginalDisplay)}}},qr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Wr(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?Wr(wt(t.children)):e}function $r(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var r=n._parentListeners;for(var a in r)t[T(a)]=r[a];return t}function Xr(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var Zr=function(e){return e.tag||ht(e)},Vr=function(e){return"show"===e.name},Kr={name:"transition",props:qr,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(Zr)).length){0;var a=this.mode;0;var r=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return r;var i=Wr(r);if(!i)return r;if(this._leaving)return Xr(e,r);var l="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?l+"comment":l+i.tag:s(i.key)?0===String(i.key).indexOf(l)?i.key:l+i.key:i.key;var o=(i.data||(i.data={})).transition=$r(this),c=this._vnode,d=Wr(c);if(i.data.directives&&i.data.directives.some(Vr)&&(i.data.show=!0),d&&d.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(i,d)&&!ht(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=I({},o);if("out-in"===a)return this._leaving=!0,Xe(u,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),Xr(e,r);if("in-out"===a){if(ht(i))return c;var p,m=function(){p()};Xe(o,"afterEnter",m),Xe(o,"enterCancelled",m),Xe(u,"delayLeave",(function(e){p=e}))}}return r}}},Qr=I({tag:String,moveClass:String},qr);function Gr(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function Yr(e){e.data.newPos=e.elm.getBoundingClientRect()}function ei(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,r=t.top-n.top;if(a||r){e.data.moved=!0;var i=e.elm.style;i.transform=i.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),i.transitionDuration="0s"}}delete Qr.mode;var ti={Transition:Kr,TransitionGroup:{props:Qr,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var r=Qt(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,r(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],l=$r(this),o=0;o<r.length;o++){if((d=r[o]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))i.push(d),n[d.key]=d,(d.data||(d.data={})).transition=l;else;}if(a){var s=[],c=[];for(o=0;o<a.length;o++){var d;(d=a[o]).data.transition=l,d.data.pos=d.elm.getBoundingClientRect(),n[d.key]?s.push(d):c.push(d)}this.kept=e(t,null,s),this.removed=c}return e(t,null,i)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(Gr),e.forEach(Yr),e.forEach(ei),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;Er(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(fr,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(fr,e),n._moveCb=null,Sr(n,t))})}})))},methods:{hasMove:function(e,t){if(!hr)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){ur(n,e)})),dr(n,t),n.style.display="none",this.$el.appendChild(n);var a=Ur(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}}};function ni(e,t){for(var n in t)e[n]=t[n];return e}Xn.config.mustUseProp=function(e,t,n){return"value"===n&&na(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},Xn.config.isReservedTag=va,Xn.config.isReservedAttr=ta,Xn.config.getTagNamespace=function(e){return fa(e)?"svg":"math"===e?"math":void 0},Xn.config.isUnknownElement=function(e){if(!V)return!0;if(va(e))return!1;if(e=e.toLowerCase(),null!=ba[e])return ba[e];var t=document.createElement(e);return e.indexOf("-")>-1?ba[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:ba[e]=/HTMLUnknownElement/.test(t.toString())},I(Xn.options.directives,Jr),I(Xn.options.components,ti),Xn.prototype.__patch__=V?zr:D,Xn.prototype.$mount=function(e,t){return function(e,t,n){var a;e.$el=t,e.$options.render||(e.$options.render=he),en(e,"beforeMount"),a=function(){e._update(e._render(),n)},new Wt(e,a,D,{before:function(){e._isMounted&&!e._isDestroyed&&en(e,"beforeUpdate")}},!0),n=!1;var r=e._preWatchers;if(r)for(var i=0;i<r.length;i++)r[i].run();return null==e.$vnode&&(e._isMounted=!0,en(e,"mounted")),e}(this,e=e&&V?function(e){if("string"==typeof e){var t=document.querySelector(e);return t||document.createElement("div")}return e}(e):void 0,t)},V&&setTimeout((function(){J.devtools&&oe&&oe.emit("init",Xn)}),0);var ai=/[!'()*]/g,ri=function(e){return"%"+e.charCodeAt(0).toString(16)},ii=/%2C/g,li=function(e){return encodeURIComponent(e).replace(ai,ri).replace(ii,",")};function oi(e){try{return decodeURIComponent(e)}catch(e){0}return e}var si=function(e){return null==e||"object"==typeof e?e:String(e)};function ci(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=oi(n.shift()),r=n.length>0?oi(n.join("=")):null;void 0===t[a]?t[a]=r:Array.isArray(t[a])?t[a].push(r):t[a]=[t[a],r]})),t):t}function di(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return li(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(li(t)):a.push(li(t)+"="+li(e)))})),a.join("&")}return li(t)+"="+li(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var ui=/\/?$/;function pi(e,t,n,a){var r=a&&a.options.stringifyQuery,i=t.query||{};try{i=mi(i)}catch(e){}var l={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:i,params:t.params||{},fullPath:fi(t,r),matched:e?gi(e):[]};return n&&(l.redirectedFrom=fi(n,r)),Object.freeze(l)}function mi(e){if(Array.isArray(e))return e.map(mi);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=mi(e[n]);return t}return e}var hi=pi(null,{path:"/"});function gi(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function fi(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var r=e.hash;return void 0===r&&(r=""),(n||"/")+(t||di)(a)+r}function vi(e,t,n){return t===hi?e===t:!!t&&(e.path&&t.path?e.path.replace(ui,"")===t.path.replace(ui,"")&&(n||e.hash===t.hash&&bi(e.query,t.query)):!(!e.name||!t.name)&&(e.name===t.name&&(n||e.hash===t.hash&&bi(e.query,t.query)&&bi(e.params,t.params))))}function bi(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,r){var i=e[n];if(a[r]!==n)return!1;var l=t[n];return null==i||null==l?i===l:"object"==typeof i&&"object"==typeof l?bi(i,l):String(i)===String(l)}))}function yi(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var r=n.instances[a],i=n.enteredCbs[a];if(r&&i){delete n.enteredCbs[a];for(var l=0;l<i.length;l++)r._isBeingDestroyed||i[l](r)}}}}var xi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,r=t.parent,i=t.data;i.routerView=!0;for(var l=r.$createElement,o=n.name,s=r.$route,c=r._routerViewCache||(r._routerViewCache={}),d=0,u=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&d++,p.keepAlive&&r._directInactive&&r._inactive&&(u=!0),r=r.$parent}if(i.routerViewDepth=d,u){var m=c[o],h=m&&m.component;return h?(m.configProps&&Ei(h,i,m.route,m.configProps),l(h,i,a)):l()}var g=s.matched[d],f=g&&g.components[o];if(!g||!f)return c[o]=null,l();c[o]={component:f},i.registerRouteInstance=function(e,t){var n=g.instances[o];(t&&n!==e||!t&&n===e)&&(g.instances[o]=t)},(i.hook||(i.hook={})).prepatch=function(e,t){g.instances[o]=t.componentInstance},i.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==g.instances[o]&&(g.instances[o]=e.componentInstance),yi(s)};var v=g.props&&g.props[o];return v&&(ni(c[o],{route:s,configProps:v}),Ei(f,i,s,v)),l(f,i,a)}};function Ei(e,t,n,a){var r=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0;default:0}}(n,a);if(r){r=t.props=ni({},r);var i=t.attrs=t.attrs||{};for(var l in r)e.props&&l in e.props||(i[l]=r[l],delete r[l])}}function Si(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var r=t.split("/");n&&r[r.length-1]||r.pop();for(var i=e.replace(/^\//,"").split("/"),l=0;l<i.length;l++){var o=i[l];".."===o?r.pop():"."!==o&&r.push(o)}return""!==r[0]&&r.unshift(""),r.join("/")}function Ci(e){return e.replace(/\/(?:\s*\/)+/g,"/")}var wi=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},Ui=Oi,Ti=Hi,Bi=function(e,t){return zi(Hi(e,t),t)},ki=zi,ji=Li,Ai=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Hi(e,t){for(var n,a=[],r=0,i=0,l="",o=t&&t.delimiter||"/";null!=(n=Ai.exec(e));){var s=n[0],c=n[1],d=n.index;if(l+=e.slice(i,d),i=d+s.length,c)l+=c[1];else{var u=e[i],p=n[2],m=n[3],h=n[4],g=n[5],f=n[6],v=n[7];l&&(a.push(l),l="");var b=null!=p&&null!=u&&u!==p,y="+"===f||"*"===f,x="?"===f||"*"===f,E=n[2]||o,S=h||g;a.push({name:m||r++,prefix:p||"",delimiter:E,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:S?Fi(S):v?".*":"[^"+Di(E)+"]+?"})}}return i<e.length&&(l+=e.substr(i)),l&&a.push(l),a}function Ii(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function zi(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",_i(t)));return function(t,a){for(var r="",i=t||{},l=(a||{}).pretty?Ii:encodeURIComponent,o=0;o<e.length;o++){var s=e[o];if("string"!=typeof s){var c,d=i[s.name];if(null==d){if(s.optional){s.partial&&(r+=s.prefix);continue}throw new TypeError('Expected "'+s.name+'" to be defined')}if(wi(d)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=l(d[u]),!n[o].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===u?s.prefix:s.delimiter)+c}}else{if(c=s.asterisk?encodeURI(d).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()})):l(d),!n[o].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but received "'+c+'"');r+=s.prefix+c}}else r+=s}return r}}function Di(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Fi(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function Pi(e,t){return e.keys=t,e}function _i(e){return e&&e.sensitive?"":"i"}function Li(e,t,n){wi(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,r=!1!==n.end,i="",l=0;l<e.length;l++){var o=e[l];if("string"==typeof o)i+=Di(o);else{var s=Di(o.prefix),c="(?:"+o.pattern+")";t.push(o),o.repeat&&(c+="(?:"+s+c+")*"),i+=c=o.optional?o.partial?s+"("+c+")?":"(?:"+s+"("+c+"))?":s+"("+c+")"}}var d=Di(n.delimiter||"/"),u=i.slice(-d.length)===d;return a||(i=(u?i.slice(0,-d.length):i)+"(?:"+d+"(?=$))?"),i+=r?"$":a&&u?"":"(?="+d+"|$)",Pi(new RegExp("^"+i,_i(n)),t)}function Oi(e,t,n){return wi(t)||(n=t||n,t=[]),n=n||{},e instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Pi(e,t)}(e,t):wi(e)?function(e,t,n){for(var a=[],r=0;r<e.length;r++)a.push(Oi(e[r],t,n).source);return Pi(new RegExp("(?:"+a.join("|")+")",_i(n)),t)}(e,t,n):function(e,t,n){return Li(Hi(e,n),t,n)}(e,t,n)}Ui.parse=Ti,Ui.compile=Bi,Ui.tokensToFunction=ki,Ui.tokensToRegExp=ji;var Mi=Object.create(null);function Ri(e,t,n){t=t||{};try{var a=Mi[e]||(Mi[e]=Ui.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function Ni(e,t,n,a){var r="string"==typeof e?{path:e}:e;if(r._normalized)return r;if(r.name){var i=(r=ni({},e)).params;return i&&"object"==typeof i&&(r.params=ni({},i)),r}if(!r.path&&r.params&&t){(r=ni({},r))._normalized=!0;var l=ni(ni({},t.params),r.params);if(t.name)r.name=t.name,r.params=l;else if(t.matched.length){var o=t.matched[t.matched.length-1].path;r.path=Ri(o,l,t.path)}else 0;return r}var s=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var r=e.indexOf("?");return r>=0&&(n=e.slice(r+1),e=e.slice(0,r)),{path:e,query:n,hash:t}}(r.path||""),c=t&&t.path||"/",d=s.path?Si(s.path,c,n||r.append):c,u=function(e,t,n){void 0===t&&(t={});var a,r=n||ci;try{a=r(e||"")}catch(e){a={}}for(var i in t){var l=t[i];a[i]=Array.isArray(l)?l.map(si):si(l)}return a}(s.query,r.query,a&&a.options.parseQuery),p=r.hash||s.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Ji,qi=function(){},Wi={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,r=n.resolve(this.to,a,this.append),i=r.location,l=r.route,o=r.href,s={},c=n.options.linkActiveClass,d=n.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,g=l.redirectedFrom?pi(null,Ni(l.redirectedFrom),null,n):l;s[h]=vi(a,g,this.exactPath),s[m]=this.exact||this.exactPath?s[h]:function(e,t){return 0===e.path.replace(ui,"/").indexOf(t.path.replace(ui,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,g);var f=s[h]?this.ariaCurrentValue:null,v=function(e){$i(e)&&(t.replace?n.replace(i,qi):n.push(i,qi))},b={click:$i};Array.isArray(this.event)?this.event.forEach((function(e){b[e]=v})):b[this.event]=v;var y={class:s},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:l,navigate:v,isActive:s[m],isExactActive:s[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?e():e("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:o,"aria-current":f};else{var E=function e(t){var n;if(t)for(var a=0;a<t.length;a++){if("a"===(n=t[a]).tag)return n;if(n.children&&(n=e(n.children)))return n}}(this.$slots.default);if(E){E.isStatic=!1;var S=E.data=ni({},E.data);for(var C in S.on=S.on||{},S.on){var w=S.on[C];C in b&&(S.on[C]=Array.isArray(w)?w:[w])}for(var U in b)U in S.on?S.on[U].push(b[U]):S.on[U]=v;var T=E.data.attrs=ni({},E.data.attrs);T.href=o,T["aria-current"]=f}else y.on=b}return e(this.tag,y,this.$slots.default)}};function $i(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}var Xi="undefined"!=typeof window;function Zi(e,t,n,a,r){var i=t||[],l=n||Object.create(null),o=a||Object.create(null);e.forEach((function(e){!function e(t,n,a,r,i,l){var o=r.path,s=r.name;0;var c=r.pathToRegexpOptions||{},d=function(e,t,n){n||(e=e.replace(/\/$/,""));if("/"===e[0])return e;if(null==t)return e;return Ci(t.path+"/"+e)}(o,i,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var u={path:d,regex:Vi(d,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:s,parent:i,matchAs:l,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=l?Ci(l+"/"+r.path):void 0;e(t,n,a,r,u,i)}));n[u.path]||(t.push(u.path),n[u.path]=u);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};e(t,n,a,h,i,u.path||"/")}s&&(a[s]||(a[s]=u))}(i,l,o,e,r)}));for(var s=0,c=i.length;s<c;s++)"*"===i[s]&&(i.push(i.splice(s,1)[0]),c--,s--);return{pathList:i,pathMap:l,nameMap:o}}function Vi(e,t){return Ui(e,[],t)}function Ki(e,t){var n=Zi(e),a=n.pathList,r=n.pathMap,i=n.nameMap;function l(e,n,l){var o=Ni(e,n,!1,t),c=o.name;if(c){var d=i[c];if(!d)return s(null,o);var u=d.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof o.params&&(o.params={}),n&&"object"==typeof n.params)for(var p in n.params)!(p in o.params)&&u.indexOf(p)>-1&&(o.params[p]=n.params[p]);return o.path=Ri(d.path,o.params),s(d,o,l)}if(o.path){o.params={};for(var m=0;m<a.length;m++){var h=a[m],g=r[h];if(Qi(g.regex,o.path,o.params))return s(g,o,l)}}return s(null,o)}function o(e,n){var a=e.redirect,r="function"==typeof a?a(pi(e,n,null,t)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return s(null,n);var o=r,c=o.name,d=o.path,u=n.query,p=n.hash,m=n.params;if(u=o.hasOwnProperty("query")?o.query:u,p=o.hasOwnProperty("hash")?o.hash:p,m=o.hasOwnProperty("params")?o.params:m,c){i[c];return l({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,n)}if(d){var h=function(e,t){return Si(e,t.parent?t.parent.path:"/",!0)}(d,e);return l({_normalized:!0,path:Ri(h,m),query:u,hash:p},void 0,n)}return s(null,n)}function s(e,n,a){return e&&e.redirect?o(e,a||n):e&&e.matchAs?function(e,t,n){var a=l({_normalized:!0,path:Ri(n,t.params)});if(a){var r=a.matched,i=r[r.length-1];return t.params=a.params,s(i,t)}return s(null,t)}(0,n,e.matchAs):pi(e,n,a,t)}return{match:l,addRoute:function(e,t){var n="object"!=typeof e?i[e]:void 0;Zi([t||e],a,r,i,n),n&&n.alias.length&&Zi(n.alias.map((function(e){return{path:e,children:[t]}})),a,r,i,n)},getRoutes:function(){return a.map((function(e){return r[e]}))},addRoutes:function(e){Zi(e,a,r,i)}}}function Qi(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var r=1,i=a.length;r<i;++r){var l=e.keys[r-1];l&&(n[l.name||"pathMatch"]="string"==typeof a[r]?oi(a[r]):a[r])}return!0}var Gi=Xi&&window.performance&&window.performance.now?window.performance:Date;function Yi(){return Gi.now().toFixed(3)}var el=Yi();function tl(){return el}function nl(e){return el=e}var al=Object.create(null);function rl(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=ni({},window.history.state);return n.key=tl(),window.history.replaceState(n,"",t),window.addEventListener("popstate",ol),function(){window.removeEventListener("popstate",ol)}}function il(e,t,n,a){if(e.app){var r=e.options.scrollBehavior;r&&e.app.$nextTick((function(){var i=function(){var e=tl();if(e)return al[e]}(),l=r.call(e,t,n,a?i:null);l&&("function"==typeof l.then?l.then((function(e){pl(e,i)})).catch((function(e){0})):pl(l,i))}))}}function ll(){var e=tl();e&&(al[e]={x:window.pageXOffset,y:window.pageYOffset})}function ol(e){ll(),e.state&&e.state.key&&nl(e.state.key)}function sl(e){return dl(e.x)||dl(e.y)}function cl(e){return{x:dl(e.x)?e.x:window.pageXOffset,y:dl(e.y)?e.y:window.pageYOffset}}function dl(e){return"number"==typeof e}var ul=/^#\d/;function pl(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var r=ul.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(r){var i=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(r,i={x:dl((n=i).x)?n.x:0,y:dl(n.y)?n.y:0})}else sl(e)&&(t=cl(e))}else a&&sl(e)&&(t=cl(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var ml,hl=Xi&&((-1===(ml=window.navigator.userAgent).indexOf("Android 2.")&&-1===ml.indexOf("Android 4.0")||-1===ml.indexOf("Mobile Safari")||-1!==ml.indexOf("Chrome")||-1!==ml.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function gl(e,t){ll();var n=window.history;try{if(t){var a=ni({},n.state);a.key=tl(),n.replaceState(a,"",e)}else n.pushState({key:nl(Yi())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function fl(e){gl(e,!0)}var vl={redirected:2,aborted:4,cancelled:8,duplicated:16};function bl(e,t){return xl(e,t,vl.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return El.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}function yl(e,t){return xl(e,t,vl.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function xl(e,t,n,a){var r=new Error(a);return r._isRouter=!0,r.from=e,r.to=t,r.type=n,r}var El=["params","query","hash"];function Sl(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function Cl(e,t){return Sl(e)&&e._isRouter&&(null==t||e.type===t)}function wl(e,t,n){var a=function(r){r>=e.length?n():e[r]?t(e[r],(function(){a(r+1)})):a(r+1)};a(0)}function Ul(e){return function(t,n,a){var r=!1,i=0,l=null;Tl(e,(function(e,t,n,o){if("function"==typeof e&&void 0===e.cid){r=!0,i++;var s,c=jl((function(t){var r;((r=t).__esModule||kl&&"Module"===r[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:Ji.extend(t),n.components[o]=t,--i<=0&&a()})),d=jl((function(e){var t="Failed to resolve async component "+o+": "+e;l||(l=Sl(e)?e:new Error(t),a(l))}));try{s=e(c,d)}catch(e){d(e)}if(s)if("function"==typeof s.then)s.then(c,d);else{var u=s.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),r||a()}}function Tl(e,t){return Bl(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function Bl(e){return Array.prototype.concat.apply([],e)}var kl="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function jl(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var Al=function(e,t){this.router=e,this.base=function(e){if(!e)if(Xi){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";"/"!==e.charAt(0)&&(e="/"+e);return e.replace(/\/$/,"")}(t),this.current=hi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Hl(e,t,n,a){var r=Tl(e,(function(e,a,r,i){var l=function(e,t){"function"!=typeof e&&(e=Ji.extend(e));return e.options[t]}(e,t);if(l)return Array.isArray(l)?l.map((function(e){return n(e,a,r,i)})):n(l,a,r,i)}));return Bl(a?r.reverse():r)}function Il(e,t){if(t)return function(){return e.apply(t,arguments)}}Al.prototype.listen=function(e){this.cb=e},Al.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},Al.prototype.onError=function(e){this.errorCbs.push(e)},Al.prototype.transitionTo=function(e,t,n){var a,r=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),t&&t(a),r.ensureURL(),r.router.afterHooks.forEach((function(e){e&&e(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!r.ready&&(Cl(e,vl.redirected)&&i===hi||(r.ready=!0,r.readyErrorCbs.forEach((function(t){t(e)}))))}))},Al.prototype.confirmTransition=function(e,t,n){var a=this,r=this.current;this.pending=e;var i,l,o=function(e){!Cl(e)&&Sl(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},s=e.matched.length-1,c=r.matched.length-1;if(vi(e,r)&&s===c&&e.matched[s]===r.matched[c])return this.ensureURL(),e.hash&&il(this.router,r,e,!1),o(((l=xl(i=r,e,vl.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",l));var d=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(e){return Hl(e,"beforeRouteLeave",Il,!0)}(p),this.router.beforeHooks,function(e){return Hl(e,"beforeRouteUpdate",Il)}(u),m.map((function(e){return e.beforeEnter})),Ul(m)),g=function(t,n){if(a.pending!==e)return o(yl(r,e));try{t(e,r,(function(t){!1===t?(a.ensureURL(!0),o(function(e,t){return xl(e,t,vl.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(r,e))):Sl(t)?(a.ensureURL(!0),o(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(o(bl(r,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){o(e)}};wl(h,g,(function(){wl(function(e){return Hl(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,r,i){return e(a,r,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),i(e)}))}}(e,n,a)}))}(m).concat(a.router.resolveHooks),g,(function(){if(a.pending!==e)return o(yl(r,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){yi(e)}))}))}))},Al.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},Al.prototype.setupListeners=function(){},Al.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=hi,this.pending=null};var zl=function(e){function t(t,n){e.call(this,t,n),this._startLocation=Dl(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=hl&&n;a&&this.listeners.push(rl());var r=function(){var n=e.current,r=Dl(e.base);e.current===hi&&r===e._startLocation||e.transitionTo(r,(function(e){a&&il(t,e,n,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,r=this.current;this.transitionTo(e,(function(e){gl(Ci(a.base+e.fullPath)),il(a.router,e,r,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,r=this.current;this.transitionTo(e,(function(e){fl(Ci(a.base+e.fullPath)),il(a.router,e,r,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(Dl(this.base)!==this.current.fullPath){var t=Ci(this.base+this.current.fullPath);e?gl(t):fl(t)}},t.prototype.getCurrentLocation=function(){return Dl(this.base)},t}(Al);function Dl(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(Ci(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var Fl=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=Dl(e);if(!/^\/#/.test(t))return window.location.replace(Ci(e+"/#"+t)),!0}(this.base)||Pl()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=hl&&t;n&&this.listeners.push(rl());var a=function(){var t=e.current;Pl()&&e.transitionTo(_l(),(function(a){n&&il(e.router,a,t,!0),hl||Ml(a.fullPath)}))},r=hl?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},t.prototype.push=function(e,t,n){var a=this,r=this.current;this.transitionTo(e,(function(e){Ol(e.fullPath),il(a.router,e,r,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,r=this.current;this.transitionTo(e,(function(e){Ml(e.fullPath),il(a.router,e,r,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;_l()!==t&&(e?Ol(t):Ml(t))},t.prototype.getCurrentLocation=function(){return _l()},t}(Al);function Pl(){var e=_l();return"/"===e.charAt(0)||(Ml("/"+e),!1)}function _l(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function Ll(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function Ol(e){hl?gl(Ll(e)):window.location.hash=e}function Ml(e){hl?fl(Ll(e)):window.location.replace(Ll(e))}var Rl=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){Cl(e,vl.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(Al),Nl=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ki(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!hl&&!1!==e.fallback,this.fallback&&(t="hash"),Xi||(t="abstract"),this.mode=t,t){case"history":this.history=new zl(this,e.base);break;case"hash":this.history=new Fl(this,e.base,this.fallback);break;case"abstract":this.history=new Rl(this,e.base);break;default:0}},Jl={currentRoute:{configurable:!0}};Nl.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},Jl.currentRoute.get=function(){return this.history&&this.history.current},Nl.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof zl||n instanceof Fl){var a=function(e){n.setupListeners(),function(e){var a=n.current,r=t.options.scrollBehavior;hl&&r&&"fullPath"in e&&il(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},Nl.prototype.beforeEach=function(e){return Wl(this.beforeHooks,e)},Nl.prototype.beforeResolve=function(e){return Wl(this.resolveHooks,e)},Nl.prototype.afterEach=function(e){return Wl(this.afterHooks,e)},Nl.prototype.onReady=function(e,t){this.history.onReady(e,t)},Nl.prototype.onError=function(e){this.history.onError(e)},Nl.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},Nl.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},Nl.prototype.go=function(e){this.history.go(e)},Nl.prototype.back=function(){this.go(-1)},Nl.prototype.forward=function(){this.go(1)},Nl.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},Nl.prototype.resolve=function(e,t,n){var a=Ni(e,t=t||this.history.current,n,this),r=this.match(a,t),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(e,t,n){var a="hash"===n?"#"+t:t;return e?Ci(e+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},Nl.prototype.getRoutes=function(){return this.matcher.getRoutes()},Nl.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==hi&&this.history.transitionTo(this.history.getCurrentLocation())},Nl.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==hi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Nl.prototype,Jl);var ql=Nl;function Wl(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}Nl.install=function e(t){if(!e.installed||Ji!==t){e.installed=!0,Ji=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",xi),t.component("RouterLink",Wi);var r=t.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Nl.version="3.6.5",Nl.isNavigationFailure=Cl,Nl.NavigationFailureType=vl,Nl.START_LOCATION=hi,Xi&&window.Vue&&window.Vue.use(Nl);n(105);n(127),n(16);var $l={NotFound:()=>Promise.all([n.e(0),n.e(4)]).then(n.bind(null,333)),Layout:()=>Promise.all([n.e(0),n.e(2)]).then(n.bind(null,332))},Xl={"v-5e192e06":()=>n.e(5).then(n.bind(null,334)),"v-3df1eca8":()=>n.e(8).then(n.bind(null,335)),"v-4e830bce":()=>n.e(9).then(n.bind(null,336)),"v-ae8b4f00":()=>n.e(10).then(n.bind(null,337)),"v-106de6f7":()=>n.e(7).then(n.bind(null,338)),"v-cf3375fa":()=>n.e(11).then(n.bind(null,339)),"v-fc017312":()=>n.e(12).then(n.bind(null,340)),"v-05b64988":()=>n.e(13).then(n.bind(null,341)),"v-366b2c35":()=>n.e(15).then(n.bind(null,342)),"v-c8d8cb58":()=>n.e(16).then(n.bind(null,343)),"v-3b5b2bd3":()=>n.e(17).then(n.bind(null,344)),"v-f2bbe9fe":()=>n.e(19).then(n.bind(null,345)),"v-24516993":()=>n.e(20).then(n.bind(null,346)),"v-d4fe211e":()=>n.e(14).then(n.bind(null,347)),"v-610709fa":()=>n.e(18).then(n.bind(null,348)),"v-3b9986b4":()=>n.e(21).then(n.bind(null,349)),"v-e6999578":()=>n.e(23).then(n.bind(null,350)),"v-a50927ba":()=>n.e(24).then(n.bind(null,351)),"v-4080eff2":()=>n.e(25).then(n.bind(null,352)),"v-0759a67a":()=>n.e(22).then(n.bind(null,353)),"v-521a5756":()=>n.e(30).then(n.bind(null,354)),"v-eee13e98":()=>n.e(28).then(n.bind(null,355)),"v-570c35c2":()=>n.e(26).then(n.bind(null,356)),"v-76c51a8c":()=>n.e(31).then(n.bind(null,357)),"v-7566f2b5":()=>n.e(29).then(n.bind(null,358)),"v-5899c3e6":()=>n.e(32).then(n.bind(null,359)),"v-3c5c96e8":()=>n.e(34).then(n.bind(null,360)),"v-4e0379ef":()=>n.e(6).then(n.bind(null,361)),"v-6ecbeb40":()=>n.e(35).then(n.bind(null,362)),"v-08a66d6c":()=>n.e(33).then(n.bind(null,363)),"v-4ec1d49e":()=>n.e(27).then(n.bind(null,364)),"v-f6f63f66":()=>n.e(36).then(n.bind(null,365)),"v-c95fe988":()=>n.e(37).then(n.bind(null,366)),"v-72bf7324":()=>n.e(38).then(n.bind(null,367)),"v-d496470a":()=>n.e(40).then(n.bind(null,368)),"v-202202ac":()=>n.e(42).then(n.bind(null,369)),"v-2daefea4":()=>n.e(39).then(n.bind(null,370)),"v-1402f9e7":()=>n.e(43).then(n.bind(null,371)),"v-3be64c8f":()=>n.e(44).then(n.bind(null,372)),"v-512b1952":()=>n.e(45).then(n.bind(null,373)),"v-4159bb2c":()=>n.e(46).then(n.bind(null,374)),"v-f4bfc402":()=>n.e(41).then(n.bind(null,375)),"v-1cd0a948":()=>n.e(47).then(n.bind(null,376)),"v-1ff2bb34":()=>n.e(49).then(n.bind(null,377)),"v-bdeb45d4":()=>n.e(48).then(n.bind(null,378)),"v-6e3d0395":()=>n.e(50).then(n.bind(null,379)),"v-4946ba1a":()=>n.e(51).then(n.bind(null,380)),"v-83448174":()=>n.e(53).then(n.bind(null,381)),"v-2ad05378":()=>n.e(54).then(n.bind(null,382)),"v-2a3afbbd":()=>n.e(57).then(n.bind(null,383)),"v-6b25220f":()=>n.e(56).then(n.bind(null,384)),"v-ed8b3516":()=>n.e(58).then(n.bind(null,385)),"v-026aa2c0":()=>n.e(59).then(n.bind(null,386)),"v-8a9fe21a":()=>n.e(60).then(n.bind(null,387)),"v-370b04f1":()=>n.e(55).then(n.bind(null,388)),"v-4341ea62":()=>n.e(61).then(n.bind(null,389)),"v-1d2ccb1c":()=>n.e(62).then(n.bind(null,390)),"v-0bff2622":()=>n.e(63).then(n.bind(null,391)),"v-e85c093a":()=>n.e(52).then(n.bind(null,392)),"v-6d760620":()=>n.e(64).then(n.bind(null,393)),"v-21bff5d0":()=>n.e(65).then(n.bind(null,394)),"v-e698f07e":()=>n.e(67).then(n.bind(null,395)),"v-52327694":()=>n.e(66).then(n.bind(null,396)),"v-2f4ae390":()=>n.e(69).then(n.bind(null,397)),"v-c0b5a14a":()=>n.e(71).then(n.bind(null,398)),"v-542d6867":()=>n.e(72).then(n.bind(null,399)),"v-3808de6c":()=>n.e(73).then(n.bind(null,400)),"v-aca3c1ea":()=>n.e(68).then(n.bind(null,401)),"v-2a9d6a55":()=>n.e(74).then(n.bind(null,402)),"v-74b8d654":()=>n.e(75).then(n.bind(null,403)),"v-04450b9b":()=>n.e(76).then(n.bind(null,404)),"v-e4981322":()=>n.e(70).then(n.bind(null,405)),"v-1d7176e4":()=>n.e(78).then(n.bind(null,406)),"v-db2b878c":()=>n.e(79).then(n.bind(null,407)),"v-e23094cc":()=>n.e(82).then(n.bind(null,408)),"v-184ae15c":()=>n.e(81).then(n.bind(null,409)),"v-0a783e44":()=>n.e(80).then(n.bind(null,410)),"v-d73b26c8":()=>n.e(83).then(n.bind(null,411)),"v-24b05c4c":()=>n.e(85).then(n.bind(null,412)),"v-cbdc4a6c":()=>n.e(86).then(n.bind(null,413)),"v-7e4025a8":()=>n.e(87).then(n.bind(null,414)),"v-5d0726e4":()=>n.e(84).then(n.bind(null,415)),"v-3feacd60":()=>n.e(88).then(n.bind(null,416)),"v-d4d865d6":()=>n.e(89).then(n.bind(null,417)),"v-5a1660c6":()=>n.e(77).then(n.bind(null,418)),"v-7be59aea":()=>n.e(90).then(n.bind(null,419)),"v-cf40e806":()=>n.e(91).then(n.bind(null,420)),"v-c06956a8":()=>n.e(92).then(n.bind(null,421)),"v-1842494e":()=>n.e(95).then(n.bind(null,422)),"v-1e66006d":()=>n.e(94).then(n.bind(null,423)),"v-4798df2b":()=>n.e(96).then(n.bind(null,424)),"v-25beb49e":()=>n.e(93).then(n.bind(null,425)),"v-7881bc68":()=>n.e(97).then(n.bind(null,426)),"v-6ddee54a":()=>n.e(98).then(n.bind(null,427)),"v-06f6cec8":()=>n.e(99).then(n.bind(null,428)),"v-2913be89":()=>n.e(101).then(n.bind(null,429)),"v-584ec5fd":()=>n.e(100).then(n.bind(null,430)),"v-563b470c":()=>n.e(103).then(n.bind(null,431)),"v-10bd6e8e":()=>n.e(105).then(n.bind(null,432)),"v-e9d6fd42":()=>n.e(102).then(n.bind(null,433)),"v-45514f4e":()=>n.e(104).then(n.bind(null,434)),"v-51b8eafc":()=>n.e(107).then(n.bind(null,435)),"v-90d3aa78":()=>n.e(108).then(n.bind(null,436)),"v-7d37ac67":()=>n.e(109).then(n.bind(null,437)),"v-5f2251f2":()=>n.e(110).then(n.bind(null,438)),"v-01a9c769":()=>n.e(111).then(n.bind(null,439)),"v-2e6b19f9":()=>n.e(112).then(n.bind(null,440)),"v-2bc4bcf4":()=>n.e(114).then(n.bind(null,441)),"v-05ca86ef":()=>n.e(113).then(n.bind(null,442)),"v-59d3a274":()=>n.e(116).then(n.bind(null,443)),"v-9e552d54":()=>n.e(106).then(n.bind(null,444)),"v-359610e4":()=>n.e(117).then(n.bind(null,445)),"v-014f3d3b":()=>n.e(118).then(n.bind(null,446)),"v-7ad66091":()=>n.e(119).then(n.bind(null,447)),"v-9eabf29c":()=>n.e(120).then(n.bind(null,448)),"v-7e7a2096":()=>n.e(122).then(n.bind(null,449)),"v-3c7bf13c":()=>n.e(123).then(n.bind(null,450)),"v-7b681b77":()=>n.e(121).then(n.bind(null,451)),"v-7037c498":()=>n.e(124).then(n.bind(null,452)),"v-f79652fc":()=>n.e(125).then(n.bind(null,453)),"v-c17338aa":()=>n.e(127).then(n.bind(null,454)),"v-3a342a82":()=>n.e(126).then(n.bind(null,455)),"v-f24d97ba":()=>n.e(129).then(n.bind(null,456)),"v-0b721a8b":()=>n.e(131).then(n.bind(null,457)),"v-993a05a0":()=>n.e(132).then(n.bind(null,458)),"v-8eb9d4fc":()=>n.e(133).then(n.bind(null,459)),"v-a210187a":()=>n.e(134).then(n.bind(null,460)),"v-78db46f9":()=>n.e(115).then(n.bind(null,461)),"v-300f8496":()=>n.e(130).then(n.bind(null,462)),"v-1bff50da":()=>n.e(135).then(n.bind(null,463)),"v-57c6ee20":()=>n.e(136).then(n.bind(null,464)),"v-76cd8bd2":()=>n.e(140).then(n.bind(null,465)),"v-5ac4680a":()=>n.e(141).then(n.bind(null,466)),"v-2f953151":()=>n.e(142).then(n.bind(null,467)),"v-fcf54dac":()=>n.e(143).then(n.bind(null,468)),"v-41e2f6ee":()=>n.e(128).then(n.bind(null,469)),"v-07a84ac0":()=>n.e(144).then(n.bind(null,470)),"v-2d01b0d8":()=>n.e(146).then(n.bind(null,471)),"v-ba965380":()=>n.e(145).then(n.bind(null,472)),"v-116c32ea":()=>n.e(139).then(n.bind(null,473)),"v-754889d9":()=>n.e(148).then(n.bind(null,474)),"v-73b83b96":()=>n.e(150).then(n.bind(null,475)),"v-72ff0920":()=>n.e(137).then(n.bind(null,476)),"v-a075a47e":()=>n.e(138).then(n.bind(null,477)),"v-7a2ddb60":()=>n.e(147).then(n.bind(null,478)),"v-4d53113a":()=>n.e(151).then(n.bind(null,479)),"v-be476018":()=>n.e(152).then(n.bind(null,480)),"v-348eef76":()=>n.e(156).then(n.bind(null,481)),"v-255e37bd":()=>n.e(153).then(n.bind(null,482)),"v-6c230934":()=>n.e(155).then(n.bind(null,483)),"v-4a528fa0":()=>n.e(157).then(n.bind(null,484)),"v-0092eada":()=>n.e(158).then(n.bind(null,485)),"v-79b77597":()=>n.e(149).then(n.bind(null,486)),"v-65e26362":()=>n.e(159).then(n.bind(null,487)),"v-23f50ec4":()=>n.e(161).then(n.bind(null,488)),"v-58438bce":()=>n.e(160).then(n.bind(null,489)),"v-1b2ebac0":()=>n.e(154).then(n.bind(null,490)),"v-0cc20b5b":()=>n.e(162).then(n.bind(null,491)),"v-7243a964":()=>n.e(163).then(n.bind(null,492)),"v-5b368820":()=>n.e(164).then(n.bind(null,493)),"v-f70ddca6":()=>n.e(167).then(n.bind(null,494)),"v-cf8973a6":()=>n.e(168).then(n.bind(null,495)),"v-2a36dce3":()=>n.e(169).then(n.bind(null,496)),"v-a93f2dbe":()=>n.e(170).then(n.bind(null,497)),"v-3519994e":()=>n.e(171).then(n.bind(null,498)),"v-c06c8f68":()=>n.e(172).then(n.bind(null,499)),"v-12c3508d":()=>n.e(165).then(n.bind(null,500)),"v-8467c352":()=>n.e(174).then(n.bind(null,501)),"v-1bec1f01":()=>n.e(166).then(n.bind(null,502)),"v-d10ed3b6":()=>n.e(175).then(n.bind(null,503)),"v-59892333":()=>n.e(176).then(n.bind(null,504)),"v-7ef938c3":()=>n.e(177).then(n.bind(null,505)),"v-ea1b2768":()=>n.e(179).then(n.bind(null,506)),"v-b429df4a":()=>n.e(178).then(n.bind(null,507)),"v-7af52ea7":()=>n.e(180).then(n.bind(null,508)),"v-9e8c3118":()=>n.e(181).then(n.bind(null,509)),"v-239deada":()=>n.e(183).then(n.bind(null,510)),"v-5e64f3d6":()=>n.e(182).then(n.bind(null,511)),"v-ff92bc58":()=>n.e(186).then(n.bind(null,512)),"v-a71be36a":()=>n.e(187).then(n.bind(null,513)),"v-5f57ddce":()=>n.e(184).then(n.bind(null,514)),"v-42fa0b81":()=>n.e(173).then(n.bind(null,515)),"v-42809042":()=>n.e(185).then(n.bind(null,516)),"v-b690a60e":()=>n.e(188).then(n.bind(null,517)),"v-a51c0314":()=>n.e(191).then(n.bind(null,518)),"v-edbd1a1c":()=>n.e(189).then(n.bind(null,519)),"v-e026e1c6":()=>n.e(192).then(n.bind(null,520)),"v-61a4e700":()=>n.e(193).then(n.bind(null,521)),"v-4d9946c2":()=>n.e(194).then(n.bind(null,522)),"v-10cdf0c6":()=>n.e(195).then(n.bind(null,523)),"v-ce732f52":()=>n.e(197).then(n.bind(null,524)),"v-6bf762c9":()=>n.e(198).then(n.bind(null,525)),"v-69a41f30":()=>n.e(190).then(n.bind(null,526)),"v-655373ba":()=>n.e(199).then(n.bind(null,527)),"v-2556fd3f":()=>n.e(200).then(n.bind(null,528)),"v-798cb182":()=>n.e(201).then(n.bind(null,529)),"v-9ec23b3a":()=>n.e(202).then(n.bind(null,530)),"v-2fd09e57":()=>n.e(196).then(n.bind(null,531)),"v-f72692ce":()=>n.e(203).then(n.bind(null,532)),"v-874a2d94":()=>n.e(204).then(n.bind(null,533)),"v-7be0cdab":()=>n.e(205).then(n.bind(null,534)),"v-1237f2a3":()=>n.e(206).then(n.bind(null,535)),"v-cd5eb84e":()=>n.e(207).then(n.bind(null,536)),"v-ef8cee36":()=>n.e(208).then(n.bind(null,537)),"v-503f4502":()=>n.e(209).then(n.bind(null,538)),"v-7f839c76":()=>n.e(210).then(n.bind(null,539)),"v-573468e8":()=>n.e(211).then(n.bind(null,540)),"v-4a94ddbe":()=>n.e(212).then(n.bind(null,541)),"v-034cfd88":()=>n.e(213).then(n.bind(null,542)),"v-755203b9":()=>n.e(215).then(n.bind(null,543)),"v-6565e77a":()=>n.e(218).then(n.bind(null,544)),"v-559e6da6":()=>n.e(220).then(n.bind(null,545)),"v-7930af96":()=>n.e(217).then(n.bind(null,546)),"v-71bbe5a6":()=>n.e(221).then(n.bind(null,547)),"v-e35e4bc0":()=>n.e(222).then(n.bind(null,548)),"v-7d9c622a":()=>n.e(219).then(n.bind(null,549)),"v-73864004":()=>n.e(216).then(n.bind(null,550)),"v-5f539617":()=>n.e(214).then(n.bind(null,551)),"v-39a42cf8":()=>n.e(223).then(n.bind(null,552)),"v-61189df0":()=>n.e(224).then(n.bind(null,553))};function Zl(e){const t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}const Vl=/-(\w)/g,Kl=Zl(e=>e.replace(Vl,(e,t)=>t?t.toUpperCase():"")),Ql=/\B([A-Z])/g,Gl=Zl(e=>e.replace(Ql,"-$1").toLowerCase()),Yl=Zl(e=>e.charAt(0).toUpperCase()+e.slice(1));function eo(e,t){if(!t)return;if(e(t))return e(t);return t.includes("-")?e(Yl(Kl(t))):e(Yl(t))||e(Gl(t))}const to=Object.assign({},$l,Xl),no=e=>to[e],ao=e=>Xl[e],ro=e=>$l[e],io=e=>Xn.component(e);function lo(e){return eo(ao,e)}function oo(e){return eo(ro,e)}function so(e){return eo(no,e)}function co(e){return eo(io,e)}function uo(...e){return Promise.all(e.filter(e=>e).map(async e=>{if(!co(e)&&so(e)){const t=await so(e)();Xn.component(e,t.default)}}))}function po(e,t){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[e]=t)}var mo=n(91),ho=n.n(mo),go=n(92),fo=n.n(go),vo={created(){if(this.siteMeta=this.$site.headTags.filter(([e])=>"meta"===e).map(([e,t])=>t),this.$ssrContext){const t=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=t)?e.map(e=>{let t="<meta";return Object.keys(e).forEach(n=>{t+=` ${n}="${fo()(e[n])}"`}),t+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=yo(this.$canonicalUrl)}var e},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const e=this.getMergedMetaTags();this.currentMetaTags=xo(e,this.currentMetaTags)},getMergedMetaTags(){const e=this.$page.frontmatter.meta||[];return ho()([{name:"description",content:this.$description}],e,this.siteMeta,Eo)},updateCanonicalLink(){bo(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",yo(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xo(null,this.currentMetaTags),bo()}};function bo(){const e=document.querySelector("link[rel='canonical']");e&&e.remove()}function yo(e=""){return e?`<link href="${e}" rel="canonical" />`:""}function xo(e,t){if(t&&[...t].filter(e=>e.parentNode===document.head).forEach(e=>document.head.removeChild(e)),e)return e.map(e=>{const t=document.createElement("meta");return Object.keys(e).forEach(n=>{t.setAttribute(n,e[n])}),document.head.appendChild(t),t})}function Eo(e){for(const t of["name","property","itemprop"])if(e.hasOwnProperty(t))return e[t]+t;return JSON.stringify(e)}var So=n(50),Co={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:n.n(So)()((function(){this.setActiveHash()}),300),setActiveHash(){const e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter(t=>e.some(e=>e.hash===t.hash)),n=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+n;for(let e=0;e<t.length;e++){const i=t[e],l=t[e+1],o=0===e&&0===n||n>=i.parentElement.offsetTop+10&&(!l||n<l.parentElement.offsetTop-10),s=decodeURIComponent(this.$route.hash);if(o&&s!==decodeURIComponent(i.hash)){const n=i;if(r===a)for(let n=e+1;n<t.length;n++)if(s===decodeURIComponent(t[n].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(n.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},wo=n(24),Uo=n.n(wo),To={mounted(){Uo.a.configure({showSpinner:!1}),this.$router.beforeEach((e,t,n)=>{e.path===t.path||Xn.component(e.name)||Uo.a.start(),n()}),this.$router.afterEach(()=>{Uo.a.done(),this.isSidebarOpen=!1})}};n(239),n(240);class Bo{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:e="",duration:t=3e3}){let n=document.createElement("div");n.className="message move-in",n.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${e}</div>\n    `,this.containerEl.appendChild(n),t>0&&setTimeout(()=>{this.close(n)},t)}close(e){e.className=e.className.replace("move-in",""),e.className+="move-out",e.addEventListener("animationend",()=>{e.remove()})}}var ko={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(e=>{document.querySelectorAll(e).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(e){if(e.classList.contains("codecopy-enabled"))return;const t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",()=>{this.copyToClipboard(e.innerText)}),e.appendChild(t),e.classList.add("codecopy-enabled")},copyToClipboard(e){const t=document.createElement("textarea");t.value=e,t.setAttribute("readonly",""),t.style.position="absolute",t.style.left="-9999px",document.body.appendChild(t);const n=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);t.select(),document.execCommand("copy");(new Bo).show({text:"复制成功",duration:1e3}),document.body.removeChild(t),n&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(n))}}};!function(e,t){void 0===t&&(t={});var n=t.insertAt;if(e&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===n&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=e:r.appendChild(document.createTextNode(e))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var jo={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Ao={},Ho=function(e){return'<div id="app">\n'.concat(e,"\n</div>")},Io=function(e){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[e]?window.$VUEPRESS_DEMO_BLOCK[e]:jo[e]},zo=function e(t,n,a){var r=document.createElement(t);return n&&Object.keys(n).forEach((function(e){if(e.indexOf("data"))r[e]=n[e];else{var t=e.replace("data","");r.dataset[t]=n[e]}})),a&&a.forEach((function(t){var n=t.tag,a=t.attrs,i=t.children;r.appendChild(e(n,a,i))})),r},Do=function(e,t,n){var a,r=(a=e.querySelectorAll(".".concat(t)),Array.prototype.slice.call(a));return 1!==r.length||n?r:r[0]},Fo=function(e,t){var n,a,r=e.match(/<style>([\s\S]+)<\/style>/),i=e.match(/<template>([\s\S]+)<\/template>/),l=e.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:l&&l[1].replace(/^\n|\n$/g,""),jsLib:t.jsLib||[],cssLib:t.cssLib||[]};o.htmlTpl=Ho(o.html),o.jsTpl=(n=o.js,a=n.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),o.script=function(e,t){var n=e.split(/export\s+default/),a="(function() {".concat(n[0]," ; return ").concat(n[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](r);return i.template=t,i}(o.js,o.html);var s=Io("vue");return o.jsLib.unshift(s),o},Po=function(e,t){var n,a=e.match(/<style>([\s\S]+)<\/style>/),r=e.match(/<html>([\s\S]+)<\/html>/),i=e.match(/<script>([\s\S]+)<\/script>/),l={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:t.jsLib||[],cssLib:t.cssLib||[]};return l.htmlTpl=l.html,l.jsTpl=l.js,l.script=(n=l.js,window.Babel?window.Babel.transform(n,{presets:["es2015"]}).code:n),l},_o=function(e){return e=e.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),e+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Lo(){var e=Do(document,"vuepress-plugin-demo-block__wrapper",!0);e.length?e.forEach((function(e){if("true"!==e.dataset.created){e.style.display="block";var t=Do(e,"vuepress-plugin-demo-block__code"),n=Do(e,"vuepress-plugin-demo-block__display"),a=Do(e,"vuepress-plugin-demo-block__footer"),r=Do(n,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(e.dataset.code),l=decodeURIComponent(e.dataset.config),o=decodeURIComponent(e.dataset.type);l=l?JSON.parse(l):{};var s=t.querySelector("div").clientHeight,c="react"===o?function(e,t){var n=(0,window.Babel.transform)(e,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(n,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),i={js:r,css:r.__style__||"",jsLib:t.jsLib||[],cssLib:t.cssLib||[],jsTpl:_o(e),htmlTpl:Ho("")},l=Io("react"),o=Io("reactDOM");return i.jsLib.unshift(l,o),i}(i,l):"vanilla"===o?Po(i,l):Fo(i,l),d=zo("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(d),d.addEventListener("click",Oo.bind(null,d,s,t,a)),Io("jsfiddle")&&a.appendChild(function(e){var t=e.css,n=e.htmlTpl,a=e.jsTpl,r=e.jsLib,i=e.cssLib,l=r.concat(i).concat(Io("cssLib")).concat(Io("jsLib")).join(",");return zo("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:t}},{tag:"input",attrs:{type:"hidden",name:"html",value:n}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:l}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Io("codepen")&&a.appendChild(function(e){var t=e.css,n=e.htmlTpl,a=e.jsTpl,r=e.jsLib,i=e.cssLib,l=JSON.stringify({css:t,html:n,js:a,js_external:r.concat(Io("jsLib")).join(";"),css_external:i.concat(Io("cssLib")).join(";"),layout:Io("codepenLayout"),js_pre_processor:Io("codepenJsProcessor"),editors:Io("codepenEditors")});return zo("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:l}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==l.horizontal?l.horizontal:Io("horizontal")){e.classList.add("vuepress-plugin-demo-block__horizontal");var u=t.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),n.appendChild(u)}if(c.css&&function(e){if(!Ao[e]){var t=zo("style",{innerHTML:e});document.body.appendChild(t),Ao[e]=!0}}(c.css),"react"===o)ReactDOM.render(React.createElement(c.js),r);else if("vue"===o){var p=(new(Vue.extend(c.script))).$mount();r.appendChild(p.$el)}else"vanilla"===o&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());e.dataset.created="true"}})):setTimeout((function(e){Lo()}),300)}function Oo(e,t,n,a){var r="1"!==e.dataset.isExpand;n.style.height=r?"".concat(t,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),e.dataset.isExpand=r?"1":"0"}var Mo={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Lo()},updated:function(){Lo()}},Ro="auto",No="zoom-in",Jo="zoom-out",qo="grab",Wo="move";function $o(e,t,n){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?e.addEventListener(t,n,r):e.removeEventListener(t,n,r)}function Xo(e,t){if(e){var n=new Image;n.onload=function(){t&&t(n)},n.src=e}}function Zo(e){return e.dataset.original?e.dataset.original:"A"===e.parentNode.tagName?e.parentNode.getAttribute("href"):null}function Vo(e,t,n){!function(e){var t=Ko,n=Qo;if(e.transition){var a=e.transition;delete e.transition,e[t]=a}if(e.transform){var r=e.transform;delete e.transform,e[n]=r}}(t);var a=e.style,r={};for(var i in t)n&&(r[i]=a[i]||""),a[i]=t[i];return r}var Ko="transition",Qo="transform",Go="transform",Yo="transitionend";var es=function(){},ts={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:es,onClose:es,onGrab:es,onMove:es,onRelease:es,onBeforeOpen:es,onBeforeClose:es,onBeforeGrab:es,onBeforeRelease:es,onImageLoading:es,onImageLoaded:es},ns={init:function(e){var t,n;t=this,n=e,Object.getOwnPropertyNames(Object.getPrototypeOf(t)).forEach((function(e){t[e]=t[e].bind(n)}))},click:function(e){if(e.preventDefault(),rs(e))return window.open(this.target.srcOriginal||e.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(e.currentTarget)},scroll:function(){var e=document.documentElement||document.body.parentNode||document.body,t=window.pageXOffset||e.scrollLeft,n=window.pageYOffset||e.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:t,y:n});var a=this.lastScrollPosition.x-t,r=this.lastScrollPosition.y-n,i=this.options.scrollThreshold;(Math.abs(r)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(e){(function(e){return"Escape"===(e.key||e.code)||27===e.keyCode})(e)&&(this.released?this.close():this.release(this.close))},mousedown:function(e){if(as(e)&&!rs(e)){e.preventDefault();var t=e.clientX,n=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,n)}.bind(this),200)}},mousemove:function(e){this.released||this.move(e.clientX,e.clientY)},mouseup:function(e){as(e)&&!rs(e)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(e){e.preventDefault();var t=e.touches[0],n=t.clientX,a=t.clientY;this.pressTimer=setTimeout(function(){this.grab(n,a)}.bind(this),200)},touchmove:function(e){if(!this.released){var t=e.touches[0],n=t.clientX,a=t.clientY;this.move(n,a)}},touchend:function(e){(function(e){e.targetTouches.length})(e)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function as(e){return 0===e.button}function rs(e){return e.metaKey||e.ctrlKey}var is={init:function(e){this.el=document.createElement("div"),this.instance=e,this.parent=document.body,Vo(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(e.options),$o(this.el,"click",e.handler.clickOverlay.bind(e))},updateStyle:function(e){Vo(this.el,{zIndex:e.zIndex,backgroundColor:e.bgColor,transition:"opacity\n        "+e.transitionDuration+"s\n        "+e.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},ls="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},os=function(){function e(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(t,n,a){return n&&e(t.prototype,n),a&&e(t,a),t}}(),ss=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},cs={init:function(e,t){this.el=e,this.instance=t,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Zo(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var e=this.instance.options,t=e.zIndex,n=e.enableGrab,a=e.transitionDuration,r=e.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:t+1,cursor:n?qo:Jo,transition:Go+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Vo(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Vo(this.el,{transform:"none"})},grab:function(e,t,n){var a=ds(),r=a.x-e,i=a.y-t;Vo(this.el,{cursor:Wo,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+n)+","+(this.scale.y+n)+")"})},move:function(e,t,n){var a=ds(),r=a.x-e,i=a.y-t;Vo(this.el,{transition:Go,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+n)+","+(this.scale.y+n)+")"})},restoreCloseStyle:function(){Vo(this.el,this.styleClose)},restoreOpenStyle:function(){Vo(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var e=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var t=this.el.cloneNode(!1);t.setAttribute("src",this.srcOriginal),t.style.position="fixed",t.style.visibility="hidden",e.appendChild(t),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),e.removeChild(t)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var e=ds(),t=this.rect.left+this.rect.width/2,n=this.rect.top+this.rect.height/2;return{x:e.x-t,y:e.y-n}},calculateScale:function(){var e=this.el.dataset,t=e.zoomingHeight,n=e.zoomingWidth,a=this.instance.options,r=a.customSize,i=a.scaleBase;if(!r&&t&&n)return{x:n/this.rect.width,y:t/this.rect.height};if(r&&"object"===(void 0===r?"undefined":ls(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var l=this.rect.width/2,o=this.rect.height/2,s=ds(),c={x:s.x-l,y:s.y-o},d=c.x/l,u=c.y/o,p=i+Math.min(d,u);if(r&&"string"==typeof r){var m=n||this.el.naturalWidth,h=t||this.el.naturalHeight,g=parseFloat(r)*m/(100*this.rect.width),f=parseFloat(r)*h/(100*this.rect.height);if(p>g||p>f)return{x:g,y:f}}return{x:p,y:p}}};function ds(){var e=document.documentElement;return{x:Math.min(e.clientWidth,window.innerWidth)/2,y:Math.min(e.clientHeight,window.innerHeight)/2}}function us(e,t,n){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){$o(e,a,t[a],n)}))}var ps=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.target=Object.create(cs),this.overlay=Object.create(is),this.handler=Object.create(ns),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ss({},ts,t),this.overlay.init(this),this.handler.init(this)}return os(e,[{key:"listen",value:function(e){if("string"==typeof e)for(var t=document.querySelectorAll(e),n=t.length;n--;)this.listen(t[n]);else"IMG"===e.tagName&&(e.style.cursor=No,$o(e,"click",this.handler.click),this.options.preloadImage&&Xo(Zo(e)));return this}},{key:"config",value:function(e){return e?(ss(this.options,e),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof e?document.querySelector(e):e;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),Xo(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),$o(document,"scroll",this.handler.scroll),$o(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&$o(window,"resize",this.handler.resizeWindow);var i=function e(){$o(a,Yo,e,!1),t.lock=!1,t.target.upgradeSource(),t.options.enableGrab&&us(document,t.handler,!0),n(a)};return $o(a,Yo,i),this}}}},{key:"close",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var n=this.target.el;this.options.onBeforeClose(n),this.lock=!0,this.body.style.cursor=Ro,this.overlay.fadeOut(),this.target.zoomOut(),$o(document,"scroll",this.handler.scroll,!1),$o(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&$o(window,"resize",this.handler.resizeWindow,!1);var a=function a(){$o(n,Yo,a,!1),e.shown=!1,e.lock=!1,e.target.downgradeSource(),e.options.enableGrab&&us(document,e.handler,!1),e.target.restoreCloseStyle(),e.overlay.remove(),t(n)};return $o(n,Yo,a),this}}},{key:"grab",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(e,t,n);var i=function e(){$o(r,Yo,e,!1),a(r)};return $o(r,Yo,i),this}}},{key:"move",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Wo,this.target.move(e,t,n);var r=this.target.el,i=function e(){$o(r,Yo,e,!1),a(r)};return $o(r,Yo,i),this}}},{key:"release",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var n=this.target.el;this.options.onBeforeRelease(n),this.lock=!0,this.body.style.cursor=Ro,this.target.restoreOpenStyle();var a=function a(){$o(n,Yo,a,!1),e.lock=!1,e.released=!0,t(n)};return $o(n,Yo,a),this}}}]),e}();const ms=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),hs=Number("500");class gs{constructor(){this.instance=new ps(ms)}update(e=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(e)}updateDelay(e=".theme-vdoing-content img:not(.no-zoom)",t=hs){setTimeout(()=>this.update(e),t)}}var fs=[vo,Co,To,ko,Mo,{watch:{"https://doc.hutool.cn/assets/js/$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new gs,this.$vuepress.zooming.updateDelay()}}],vs={name:"GlobalLayout",computed:{layout(){const e=this.getLayout();return po("layout",e),Xn.component(e)}},methods:{getLayout(){if(this.$page.path){const e=this.$page.frontmatter.layout;return e&&(this.$vuepress.getLayoutAsyncComponent(e)||this.$vuepress.getVueComponent(e))?e:"Layout"}return"NotFound"}}},bs=n(7),ys=Object(bs.a)(vs,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(e,t,n){switch(t){case"components":e[t]||(e[t]={}),Object.assign(e[t],n);break;case"mixins":e[t]||(e[t]=[]),e[t].push(...n);break;default:throw new Error("Unknown option name.")}}(ys,"mixins",fs);const xs=[{name:"v-5e192e06",path:"/pages/index/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-5e192e06").then(n)}},{path:"https://doc.hutool.cn/pages/index/index.html",redirect:"/pages/index/"},{path:"/01.指南/01.快速入门/01.简介.html",redirect:"/pages/index/"},{name:"v-3df1eca8",path:"/pages/ConverterRegistry/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-3df1eca8").then(n)}},{path:"https://doc.hutool.cn/pages/ConverterRegistry/index.html",redirect:"/pages/ConverterRegistry/"},{path:"/01.指南/02.核心（Hutool-core）/02.类型转换/02.自定义类型转换-ConverterRegistry.html",redirect:"/pages/ConverterRegistry/"},{name:"v-4e830bce",path:"/pages/Date/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4e830bce").then(n)}},{path:"https://doc.hutool.cn/pages/Date/index.html",redirect:"/pages/Date/"},{path:"/01.指南/02.核心（Hutool-core）/03.日期时间/01.概述.html",redirect:"/pages/Date/"},{name:"v-ae8b4f00",path:"/pages/DateUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-ae8b4f00").then(n)}},{path:"https://doc.hutool.cn/pages/DateUtil/index.html",redirect:"/pages/DateUtil/"},{path:"/01.指南/02.核心（Hutool-core）/03.日期时间/02.日期时间工具-DateUtil.html",redirect:"/pages/DateUtil/"},{name:"v-106de6f7",path:"/pages/Convert/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-106de6f7").then(n)}},{path:"https://doc.hutool.cn/pages/Convert/index.html",redirect:"/pages/Convert/"},{path:"/01.指南/02.核心（Hutool-core）/02.类型转换/01.类型转换工具类-Convert.html",redirect:"/pages/Convert/"},{name:"v-cf3375fa",path:"/pages/DateTime/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-cf3375fa").then(n)}},{path:"https://doc.hutool.cn/pages/DateTime/index.html",redirect:"/pages/DateTime/"},{path:"/01.指南/02.核心（Hutool-core）/03.日期时间/03.日期时间对象-DateTime.html",redirect:"/pages/DateTime/"},{name:"v-fc017312",path:"/pages/ChineseDate/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-fc017312").then(n)}},{path:"https://doc.hutool.cn/pages/ChineseDate/index.html",redirect:"/pages/ChineseDate/"},{path:"/01.指南/02.核心（Hutool-core）/03.日期时间/04.农历日期-ChineseDate.html",redirect:"/pages/ChineseDate/"},{name:"v-05b64988",path:"/pages/LocalDateTimeUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-05b64988").then(n)}},{path:"https://doc.hutool.cn/pages/LocalDateTimeUtil/index.html",redirect:"/pages/LocalDateTimeUtil/"},{path:"/01.指南/02.核心（Hutool-core）/03.日期时间/05.LocalDateTime工具-LocalDateTimeUtil.html",redirect:"/pages/LocalDateTimeUtil/"},{name:"v-366b2c35",path:"/pages/io/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-366b2c35").then(n)}},{path:"https://doc.hutool.cn/pages/io/index.html",redirect:"/pages/io/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/00.概述.html",redirect:"/pages/io/"},{name:"v-c8d8cb58",path:"/pages/IoUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-c8d8cb58").then(n)}},{path:"https://doc.hutool.cn/pages/IoUtil/index.html",redirect:"/pages/IoUtil/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/01.IO工具类-IoUtil.html",redirect:"/pages/IoUtil/"},{name:"v-3b5b2bd3",path:"/pages/FileUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-3b5b2bd3").then(n)}},{path:"https://doc.hutool.cn/pages/FileUtil/index.html",redirect:"/pages/FileUtil/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/02.文件工具类-FileUtil.html",redirect:"/pages/FileUtil/"},{name:"v-f2bbe9fe",path:"/pages/FileTypeUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-f2bbe9fe").then(n)}},{path:"https://doc.hutool.cn/pages/FileTypeUtil/index.html",redirect:"/pages/FileTypeUtil/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/04.文件类型判断-FileTypeUtil.html",redirect:"/pages/FileTypeUtil/"},{name:"v-24516993",path:"/pages/FileReader/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-24516993").then(n)}},{path:"https://doc.hutool.cn/pages/FileReader/index.html",redirect:"/pages/FileReader/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/05.文件/01.文件读取-FileReader.html",redirect:"/pages/FileReader/"},{name:"v-d4fe211e",path:"/pages/TimeInterval/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-d4fe211e").then(n)}},{path:"https://doc.hutool.cn/pages/TimeInterval/index.html",redirect:"/pages/TimeInterval/"},{path:"/01.指南/02.核心（Hutool-core）/03.日期时间/06.计时器工具-TimeInterval.html",redirect:"/pages/TimeInterval/"},{name:"v-610709fa",path:"/pages/WatchMonitor/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-610709fa").then(n)}},{path:"https://doc.hutool.cn/pages/WatchMonitor/index.html",redirect:"/pages/WatchMonitor/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/03.文件监听-WatchMonitor.html",redirect:"/pages/WatchMonitor/"},{name:"v-3b9986b4",path:"/pages/FileWriter/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-3b9986b4").then(n)}},{path:"https://doc.hutool.cn/pages/FileWriter/index.html",redirect:"/pages/FileWriter/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/05.文件/02.文件写入-FileWriter.html",redirect:"/pages/FileWriter/"},{name:"v-e6999578",path:"/pages/Tailer/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-e6999578").then(n)}},{path:"https://doc.hutool.cn/pages/Tailer/index.html",redirect:"/pages/Tailer/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/05.文件/04.文件跟随-Tailer.html",redirect:"/pages/Tailer/"},{name:"v-a50927ba",path:"/pages/FileNameUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-a50927ba").then(n)}},{path:"https://doc.hutool.cn/pages/FileNameUtil/index.html",redirect:"/pages/FileNameUtil/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/05.文件/05.文件名工具-FileNameUtil.html",redirect:"/pages/FileNameUtil/"},{name:"v-4080eff2",path:"/pages/resource/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4080eff2").then(n)}},{path:"https://doc.hutool.cn/pages/resource/index.html",redirect:"/pages/resource/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/06.资源/00.概述.html",redirect:"/pages/resource/"},{name:"v-0759a67a",path:"/pages/FileAppender/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-0759a67a").then(n)}},{path:"https://doc.hutool.cn/pages/FileAppender/index.html",redirect:"/pages/FileAppender/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/05.文件/03.文件追加-FileAppender.html",redirect:"/pages/FileAppender/"},{name:"v-521a5756",path:"/pages/HexUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-521a5756").then(n)}},{path:"https://doc.hutool.cn/pages/HexUtil/index.html",redirect:"/pages/HexUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/02.16进制工具-HexUtil.html",redirect:"/pages/HexUtil/"},{name:"v-eee13e98",path:"/pages/util/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-eee13e98").then(n)}},{path:"https://doc.hutool.cn/pages/util/index.html",redirect:"/pages/util/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/00.概述.html",redirect:"/pages/util/"},{name:"v-570c35c2",path:"/pages/ResourceUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-570c35c2").then(n)}},{path:"https://doc.hutool.cn/pages/ResourceUtil/index.html",redirect:"/pages/ResourceUtil/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/06.资源/01.资源工具-ResourceUtil.html",redirect:"/pages/ResourceUtil/"},{name:"v-76c51a8c",path:"/pages/EscapeUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-76c51a8c").then(n)}},{path:"https://doc.hutool.cn/pages/EscapeUtil/index.html",redirect:"/pages/EscapeUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/03.Escape工具-EscapeUtil.html",redirect:"/pages/EscapeUtil/"},{name:"v-7566f2b5",path:"/pages/StrUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7566f2b5").then(n)}},{path:"https://doc.hutool.cn/pages/StrUtil/index.html",redirect:"/pages/StrUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/01.字符串工具-StrUtil.html",redirect:"/pages/StrUtil/"},{name:"v-5899c3e6",path:"/pages/HashUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-5899c3e6").then(n)}},{path:"https://doc.hutool.cn/pages/HashUtil/index.html",redirect:"/pages/HashUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/04.Hash算法-HashUtil.html",redirect:"/pages/HashUtil/"},{name:"v-3c5c96e8",path:"/pages/XmlUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-3c5c96e8").then(n)}},{path:"https://doc.hutool.cn/pages/XmlUtil/index.html",redirect:"/pages/XmlUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/06.XML工具-XmlUtil.html",redirect:"/pages/XmlUtil/"},{name:"v-4e0379ef",path:"/pages/Cloneable/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4e0379ef").then(n)}},{path:"https://doc.hutool.cn/pages/Cloneable/index.html",redirect:"/pages/Cloneable/"},{path:"/01.指南/02.核心（Hutool-core）/01.克隆/01.支持泛型的克隆接口和克隆类.html",redirect:"/pages/Cloneable/"},{name:"v-6ecbeb40",path:"/pages/ObjectUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-6ecbeb40").then(n)}},{path:"https://doc.hutool.cn/pages/ObjectUtil/index.html",redirect:"/pages/ObjectUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/07.对象工具-ObjectUtil.html",redirect:"/pages/ObjectUtil/"},{name:"v-08a66d6c",path:"/pages/URLUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-08a66d6c").then(n)}},{path:"https://doc.hutool.cn/pages/URLUtil/index.html",redirect:"/pages/URLUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/05.URL工具-URLUtil.html",redirect:"/pages/URLUtil/"},{name:"v-4ec1d49e",path:"/pages/ClassPathResource/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4ec1d49e").then(n)}},{path:"https://doc.hutool.cn/pages/ClassPathResource/index.html",redirect:"/pages/ClassPathResource/"},{path:"/01.指南/02.核心（Hutool-core）/04.IO流相关/06.资源/02.ClassPath资源访问-ClassPathResource.html",redirect:"/pages/ClassPathResource/"},{name:"v-f6f63f66",path:"/pages/ReflectUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-f6f63f66").then(n)}},{path:"https://doc.hutool.cn/pages/ReflectUtil/index.html",redirect:"/pages/ReflectUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/08.反射工具-ReflectUtil.html",redirect:"/pages/ReflectUtil/"},{name:"v-c95fe988",path:"/pages/TypeUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-c95fe988").then(n)}},{path:"https://doc.hutool.cn/pages/TypeUtil/index.html",redirect:"/pages/TypeUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/09.泛型类型工具-TypeUtil.html",redirect:"/pages/TypeUtil/"},{name:"v-72bf7324",path:"/pages/PageUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-72bf7324").then(n)}},{path:"https://doc.hutool.cn/pages/PageUtil/index.html",redirect:"/pages/PageUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/10.分页工具-PageUtil.html",redirect:"/pages/PageUtil/"},{name:"v-d496470a",path:"/pages/ClassUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-d496470a").then(n)}},{path:"https://doc.hutool.cn/pages/ClassUtil/index.html",redirect:"/pages/ClassUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/12.类工具-ClassUtil.html",redirect:"/pages/ClassUtil/"},{name:"v-202202ac",path:"/pages/RuntimeUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-202202ac").then(n)}},{path:"https://doc.hutool.cn/pages/RuntimeUtil/index.html",redirect:"/pages/RuntimeUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/14.命令行工具-RuntimeUtil.html",redirect:"/pages/RuntimeUtil/"},{name:"v-2daefea4",path:"/pages/ClipboardUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2daefea4").then(n)}},{path:"https://doc.hutool.cn/pages/ClipboardUtil/index.html",redirect:"/pages/ClipboardUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/11.剪贴板工具-ClipboardUtil.html",redirect:"/pages/ClipboardUtil/"},{name:"v-1402f9e7",path:"/pages/NumberUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1402f9e7").then(n)}},{path:"https://doc.hutool.cn/pages/NumberUtil/index.html",redirect:"/pages/NumberUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/15.数字工具-NumberUtil.html",redirect:"/pages/NumberUtil/"},{name:"v-3be64c8f",path:"/pages/ArrayUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-3be64c8f").then(n)}},{path:"https://doc.hutool.cn/pages/ArrayUtil/index.html",redirect:"/pages/ArrayUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/16.数组工具-ArrayUtil.html",redirect:"/pages/ArrayUtil/"},{name:"v-512b1952",path:"/pages/RandomUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-512b1952").then(n)}},{path:"https://doc.hutool.cn/pages/RandomUtil/index.html",redirect:"/pages/RandomUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/17.随机工具-RandomUtil.html",redirect:"/pages/RandomUtil/"},{name:"v-4159bb2c",path:"/pages/IdUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4159bb2c").then(n)}},{path:"https://doc.hutool.cn/pages/IdUtil/index.html",redirect:"/pages/IdUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/18.唯一ID工具-IdUtil.html",redirect:"/pages/IdUtil/"},{name:"v-f4bfc402",path:"/pages/EnumUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-f4bfc402").then(n)}},{path:"https://doc.hutool.cn/pages/EnumUtil/index.html",redirect:"/pages/EnumUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/13.枚举工具-EnumUtil.html",redirect:"/pages/EnumUtil/"},{name:"v-1cd0a948",path:"/pages/ZipUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1cd0a948").then(n)}},{path:"https://doc.hutool.cn/pages/ZipUtil/index.html",redirect:"/pages/ZipUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/19.压缩工具-ZipUtil.html",redirect:"/pages/ZipUtil/"},{name:"v-1ff2bb34",path:"/pages/ReUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1ff2bb34").then(n)}},{path:"https://doc.hutool.cn/pages/ReUtil/index.html",redirect:"/pages/ReUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/21.正则工具-ReUtil.html",redirect:"/pages/ReUtil/"},{name:"v-bdeb45d4",path:"/pages/ReferenceUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-bdeb45d4").then(n)}},{path:"https://doc.hutool.cn/pages/ReferenceUtil/index.html",redirect:"/pages/ReferenceUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/20.引用工具-ReferenceUtil.html",redirect:"/pages/ReferenceUtil/"},{name:"v-6e3d0395",path:"/pages/IdcardUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-6e3d0395").then(n)}},{path:"https://doc.hutool.cn/pages/IdcardUtil/index.html",redirect:"/pages/IdcardUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/23.身份证工具-IdcardUtil.html",redirect:"/pages/IdcardUtil/"},{name:"v-4946ba1a",path:"/pages/DesensitizedUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4946ba1a").then(n)}},{path:"https://doc.hutool.cn/pages/DesensitizedUtil/index.html",redirect:"/pages/DesensitizedUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/24.信息脱敏工具-DesensitizedUtil.html",redirect:"/pages/DesensitizedUtil/"},{name:"v-83448174",path:"/pages/ServiceLoaderUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-83448174").then(n)}},{path:"https://doc.hutool.cn/pages/ServiceLoaderUtil/index.html",redirect:"/pages/ServiceLoaderUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/26.SPI加载工具-ServiceLoaderUtil.html",redirect:"/pages/ServiceLoaderUtil/"},{name:"v-2ad05378",path:"/pages/CharsetUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2ad05378").then(n)}},{path:"https://doc.hutool.cn/pages/CharsetUtil/index.html",redirect:"/pages/CharsetUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/27.字符编码工具-CharsetUtil.html",redirect:"/pages/CharsetUtil/"},{name:"v-2a3afbbd",path:"/pages/Dict/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2a3afbbd").then(n)}},{path:"https://doc.hutool.cn/pages/Dict/index.html",redirect:"/pages/Dict/"},{path:"/01.指南/02.核心（Hutool-core）/06.语言特性/02.HashMap扩展-Dict.html",redirect:"/pages/Dict/"},{name:"v-6b25220f",path:"/pages/language/characteristics/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-6b25220f").then(n)}},{path:"https://doc.hutool.cn/pages/language/characteristics/index.html",redirect:"/pages/language/characteristics/"},{path:"/01.指南/02.核心（Hutool-core）/06.语言特性/01.概述.html",redirect:"/pages/language/characteristics/"},{name:"v-ed8b3516",path:"/pages/Singleton/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-ed8b3516").then(n)}},{path:"https://doc.hutool.cn/pages/Singleton/index.html",redirect:"/pages/Singleton/"},{path:"/01.指南/02.核心（Hutool-core）/06.语言特性/03.单例工具-Singleton.html",redirect:"/pages/Singleton/"},{name:"v-026aa2c0",path:"/pages/Assert/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-026aa2c0").then(n)}},{path:"https://doc.hutool.cn/pages/Assert/index.html",redirect:"/pages/Assert/"},{path:"/01.指南/02.核心（Hutool-core）/06.语言特性/04.断言-Assert.html",redirect:"/pages/Assert/"},{name:"v-8a9fe21a",path:"/pages/BCD/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-8a9fe21a").then(n)}},{path:"https://doc.hutool.cn/pages/BCD/index.html",redirect:"/pages/BCD/"},{path:"/01.指南/02.核心（Hutool-core）/06.语言特性/05.二进码十进数-BCD.html",redirect:"/pages/BCD/"},{name:"v-370b04f1",path:"/pages/ClassLoaderUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-370b04f1").then(n)}},{path:"https://doc.hutool.cn/pages/ClassLoaderUtil/index.html",redirect:"/pages/ClassLoaderUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/28.类加载工具-ClassLoaderUtil.html",redirect:"/pages/ClassLoaderUtil/"},{name:"v-4341ea62",path:"/pages/Console/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4341ea62").then(n)}},{path:"https://doc.hutool.cn/pages/Console/index.html",redirect:"/pages/Console/"},{path:"/01.指南/02.核心（Hutool-core）/06.语言特性/06.控制台打印封装-Console.html",redirect:"/pages/Console/"},{name:"v-1d2ccb1c",path:"/pages/Validator/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1d2ccb1c").then(n)}},{path:"https://doc.hutool.cn/pages/Validator/index.html",redirect:"/pages/Validator/"},{path:"/01.指南/02.核心（Hutool-core）/06.语言特性/07.字段验证器-Validator.html",redirect:"/pages/Validator/"},{name:"v-0bff2622",path:"/pages/StrFormatter/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-0bff2622").then(n)}},{path:"https://doc.hutool.cn/pages/StrFormatter/index.html",redirect:"/pages/StrFormatter/"},{path:"/01.指南/02.核心（Hutool-core）/06.语言特性/08.字符串格式化-StrFormatter.html",redirect:"/pages/StrFormatter/"},{name:"v-e85c093a",path:"/pages/CreditCodeUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-e85c093a").then(n)}},{path:"https://doc.hutool.cn/pages/CreditCodeUtil/index.html",redirect:"/pages/CreditCodeUtil/"},{path:"/01.指南/02.核心（Hutool-core）/05.工具类/25.社会信用代码工具-CreditCodeUtil.html",redirect:"/pages/CreditCodeUtil/"},{name:"v-6d760620",path:"/pages/TreeUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-6d760620").then(n)}},{path:"https://doc.hutool.cn/pages/TreeUtil/index.html",redirect:"/pages/TreeUtil/"},{path:"/01.指南/02.核心（Hutool-core）/06.语言特性/09.树结构/10.树结构工具-TreeUtil.html",redirect:"/pages/TreeUtil/"},{name:"v-21bff5d0",path:"/pages/javaBean/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-21bff5d0").then(n)}},{path:"https://doc.hutool.cn/pages/javaBean/index.html",redirect:"/pages/javaBean/"},{path:"/01.指南/02.核心（Hutool-core）/07.JavaBean/01.概述.html",redirect:"/pages/javaBean/"},{name:"v-e698f07e",path:"/pages/DynaBean/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-e698f07e").then(n)}},{path:"https://doc.hutool.cn/pages/DynaBean/index.html",redirect:"/pages/DynaBean/"},{path:"/01.指南/02.核心（Hutool-core）/07.JavaBean/03.DynaBean.html",redirect:"/pages/DynaBean/"},{name:"v-52327694",path:"/pages/BeanUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-52327694").then(n)}},{path:"https://doc.hutool.cn/pages/BeanUtil/index.html",redirect:"/pages/BeanUtil/"},{path:"/01.指南/02.核心（Hutool-core）/07.JavaBean/02.Bean工具-BeanUtil.html",redirect:"/pages/BeanUtil/"},{name:"v-2f4ae390",path:"/pages/BeanDesc/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2f4ae390").then(n)}},{path:"https://doc.hutool.cn/pages/BeanDesc/index.html",redirect:"/pages/BeanDesc/"},{path:"/01.指南/02.核心（Hutool-core）/07.JavaBean/05.Bean描述-BeanDesc.html",redirect:"/pages/BeanDesc/"},{name:"v-c0b5a14a",path:"/pages/Coll/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-c0b5a14a").then(n)}},{path:"https://doc.hutool.cn/pages/Coll/index.html",redirect:"/pages/Coll/"},{path:"/01.指南/02.核心（Hutool-core）/08.集合类/01.概述.html",redirect:"/pages/Coll/"},{name:"v-542d6867",path:"/pages/CollUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-542d6867").then(n)}},{path:"https://doc.hutool.cn/pages/CollUtil/index.html",redirect:"/pages/CollUtil/"},{path:"/01.指南/02.核心（Hutool-core）/08.集合类/02.集合工具-CollUtil.html",redirect:"/pages/CollUtil/"},{name:"v-3808de6c",path:"/pages/ListUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-3808de6c").then(n)}},{path:"https://doc.hutool.cn/pages/ListUtil/index.html",redirect:"/pages/ListUtil/"},{path:"/01.指南/02.核心（Hutool-core）/08.集合类/03.列表工具-ListUtil.html",redirect:"/pages/ListUtil/"},{name:"v-aca3c1ea",path:"/pages/BeanPath/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-aca3c1ea").then(n)}},{path:"https://doc.hutool.cn/pages/BeanPath/index.html",redirect:"/pages/BeanPath/"},{path:"/01.指南/02.核心（Hutool-core）/07.JavaBean/04.表达式解析-BeanPath.html",redirect:"/pages/BeanPath/"},{name:"v-2a9d6a55",path:"/pages/IterUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2a9d6a55").then(n)}},{path:"https://doc.hutool.cn/pages/IterUtil/index.html",redirect:"/pages/IterUtil/"},{path:"/01.指南/02.核心（Hutool-core）/08.集合类/04.Iterator工具-IterUtil.html",redirect:"/pages/IterUtil/"},{name:"v-74b8d654",path:"/pages/BoundedPriorityQueue/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-74b8d654").then(n)}},{path:"https://doc.hutool.cn/pages/BoundedPriorityQueue/index.html",redirect:"/pages/BoundedPriorityQueue/"},{path:"/01.指南/02.核心（Hutool-core）/08.集合类/05.有界优先队列-BoundedPriorityQueue.html",redirect:"/pages/BoundedPriorityQueue/"},{name:"v-04450b9b",path:"/pages/ConcurrentHashSet/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-04450b9b").then(n)}},{path:"https://doc.hutool.cn/pages/ConcurrentHashSet/index.html",redirect:"/pages/ConcurrentHashSet/"},{path:"/01.指南/02.核心（Hutool-core）/08.集合类/06.线程安全的HashSet-ConcurrentHashSet.html",redirect:"/pages/ConcurrentHashSet/"},{name:"v-e4981322",path:"/pages/Opt/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-e4981322").then(n)}},{path:"https://doc.hutool.cn/pages/Opt/index.html",redirect:"/pages/Opt/"},{path:"/01.指南/02.核心（Hutool-core）/07.JavaBean/06.空检查属性获取-Opt.html",redirect:"/pages/Opt/"},{name:"v-1d7176e4",path:"/pages/LineIter/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1d7176e4").then(n)}},{path:"https://doc.hutool.cn/pages/LineIter/index.html",redirect:"/pages/LineIter/"},{path:"/01.指南/02.核心（Hutool-core）/08.集合类/08.行遍历器-LineIter.html",redirect:"/pages/LineIter/"},{name:"v-db2b878c",path:"/pages/map/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-db2b878c").then(n)}},{path:"https://doc.hutool.cn/pages/map/index.html",redirect:"/pages/map/"},{path:"/01.指南/02.核心（Hutool-core）/09.Map/01.概述.html",redirect:"/pages/map/"},{name:"v-e23094cc",path:"/pages/TableMap/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-e23094cc").then(n)}},{path:"https://doc.hutool.cn/pages/TableMap/index.html",redirect:"/pages/TableMap/"},{path:"/01.指南/02.核心（Hutool-core）/09.Map/04.可重复键值Map-TableMap.html",redirect:"/pages/TableMap/"},{name:"v-184ae15c",path:"/pages/BiMap/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-184ae15c").then(n)}},{path:"https://doc.hutool.cn/pages/BiMap/index.html",redirect:"/pages/BiMap/"},{path:"/01.指南/02.核心（Hutool-core）/09.Map/03.双向查找Map-BiMap.html",redirect:"/pages/BiMap/"},{name:"v-0a783e44",path:"/pages/MapUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-0a783e44").then(n)}},{path:"https://doc.hutool.cn/pages/MapUtil/index.html",redirect:"/pages/MapUtil/"},{path:"/01.指南/02.核心（Hutool-core）/09.Map/02.Map工具-MapUtil.html",redirect:"/pages/MapUtil/"},{name:"v-d73b26c8",path:"/pages/MapBuilder/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-d73b26c8").then(n)}},{path:"https://doc.hutool.cn/pages/MapBuilder/index.html",redirect:"/pages/MapBuilder/"},{path:"/01.指南/02.核心（Hutool-core）/09.Map/05.Map流式构建器-MapBuilder copy.html",redirect:"/pages/MapBuilder/"},{name:"v-24b05c4c",path:"/pages/Base64/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-24b05c4c").then(n)}},{path:"https://doc.hutool.cn/pages/Base64/index.html",redirect:"/pages/Base64/"},{path:"/01.指南/02.核心（Hutool-core）/10.Codec编码/02.Base64编码解码-Base64.html",redirect:"/pages/Base64/"},{name:"v-cbdc4a6c",path:"/pages/Base32/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-cbdc4a6c").then(n)}},{path:"https://doc.hutool.cn/pages/Base32/index.html",redirect:"/pages/Base32/"},{path:"/01.指南/02.核心（Hutool-core）/10.Codec编码/03.Base32编码解码-Base32.html",redirect:"/pages/Base32/"},{name:"v-7e4025a8",path:"/pages/Morse/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7e4025a8").then(n)}},{path:"https://doc.hutool.cn/pages/Morse/index.html",redirect:"/pages/Morse/"},{path:"/01.指南/02.核心（Hutool-core）/10.Codec编码/04.莫尔斯电码-Morse.html",redirect:"/pages/Morse/"},{name:"v-5d0726e4",path:"/pages/Base62/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-5d0726e4").then(n)}},{path:"https://doc.hutool.cn/pages/Base62/index.html",redirect:"/pages/Base62/"},{path:"/01.指南/02.核心（Hutool-core）/10.Codec编码/01.Base62编码解码-Base62.html",redirect:"/pages/Base62/"},{name:"v-3feacd60",path:"/pages/codec/BCD/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-3feacd60").then(n)}},{path:"https://doc.hutool.cn/pages/codec/BCD/index.html",redirect:"/pages/codec/BCD/"},{path:"/01.指南/02.核心（Hutool-core）/10.Codec编码/05.BCD码-BCD.html",redirect:"/pages/codec/BCD/"},{name:"v-d4d865d6",path:"/pages/Rot/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-d4d865d6").then(n)}},{path:"https://doc.hutool.cn/pages/Rot/index.html",redirect:"/pages/Rot/"},{path:"/01.指南/02.核心（Hutool-core）/10.Codec编码/06.回转N位密码-Rot.html",redirect:"/pages/Rot/"},{name:"v-5a1660c6",path:"/pages/CollStreamUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-5a1660c6").then(n)}},{path:"https://doc.hutool.cn/pages/CollStreamUtil/index.html",redirect:"/pages/CollStreamUtil/"},{path:"/01.指南/02.核心（Hutool-core）/08.集合类/07.集合串行流工具-CollStreamUtil.html",redirect:"/pages/CollStreamUtil/"},{name:"v-7be59aea",path:"/pages/PunyCode/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7be59aea").then(n)}},{path:"https://doc.hutool.cn/pages/PunyCode/index.html",redirect:"/pages/PunyCode/"},{path:"/01.指南/02.核心（Hutool-core）/10.Codec编码/07.Punycode实现-PunyCode.html",redirect:"/pages/PunyCode/"},{name:"v-cf40e806",path:"/pages/CsvUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-cf40e806").then(n)}},{path:"https://doc.hutool.cn/pages/CsvUtil/index.html",redirect:"/pages/CsvUtil/"},{path:"/01.指南/02.核心（Hutool-core）/11.文本操作/01.CSV文件处理工具-CsvUtil.html",redirect:"/pages/CsvUtil/"},{name:"v-c06956a8",path:"/pages/UnicodeUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-c06956a8").then(n)}},{path:"https://doc.hutool.cn/pages/UnicodeUtil/index.html",redirect:"/pages/UnicodeUtil/"},{path:"/01.指南/02.核心（Hutool-core）/11.文本操作/02.Unicode编码转换工具-UnicodeUtil.html",redirect:"/pages/UnicodeUtil/"},{name:"v-1842494e",path:"/pages/AnnotationUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1842494e").then(n)}},{path:"https://doc.hutool.cn/pages/AnnotationUtil/index.html",redirect:"/pages/AnnotationUtil/"},{path:"/01.指南/02.核心（Hutool-core）/12.注解/01.注解工具-AnnotationUtil.html",redirect:"/pages/AnnotationUtil/"},{name:"v-1e66006d",path:"/pages/StrSplitter/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1e66006d").then(n)}},{path:"https://doc.hutool.cn/pages/StrSplitter/index.html",redirect:"/pages/StrSplitter/"},{path:"/01.指南/02.核心（Hutool-core）/11.文本操作/04.字符串切割-StrSplitter.html",redirect:"/pages/StrSplitter/"},{name:"v-4798df2b",path:"/pages/Comparator/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4798df2b").then(n)}},{path:"https://doc.hutool.cn/pages/Comparator/index.html",redirect:"/pages/Comparator/"},{path:"/01.指南/02.核心（Hutool-core）/13.比较器/01.概述.html",redirect:"/pages/Comparator/"},{name:"v-25beb49e",path:"/pages/StrBuilder/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-25beb49e").then(n)}},{path:"https://doc.hutool.cn/pages/StrBuilder/index.html",redirect:"/pages/StrBuilder/"},{path:"/01.指南/02.核心（Hutool-core）/11.文本操作/03.可复用字符串生成器-StrBuilder.html",redirect:"/pages/StrBuilder/"},{name:"v-7881bc68",path:"/pages/CompareUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7881bc68").then(n)}},{path:"https://doc.hutool.cn/pages/CompareUtil/index.html",redirect:"/pages/CompareUtil/"},{path:"/01.指南/02.核心（Hutool-core）/13.比较器/02.比较工具-CompareUtil.html",redirect:"/pages/CompareUtil/"},{name:"v-6ddee54a",path:"/pages/VersionComparator/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-6ddee54a").then(n)}},{path:"https://doc.hutool.cn/pages/VersionComparator/index.html",redirect:"/pages/VersionComparator/"},{path:"/01.指南/02.核心（Hutool-core）/13.比较器/03.版本比较器-VersionComparator.html",redirect:"/pages/VersionComparator/"},{name:"v-06f6cec8",path:"/pages/ExceptionUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-06f6cec8").then(n)}},{path:"https://doc.hutool.cn/pages/ExceptionUtil/index.html",redirect:"/pages/ExceptionUtil/"},{path:"/01.指南/02.核心（Hutool-core）/14.异常/01.异常工具-ExceptionUtil.html",redirect:"/pages/ExceptionUtil/"},{name:"v-2913be89",path:"/pages/MathUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2913be89").then(n)}},{path:"https://doc.hutool.cn/pages/MathUtil/index.html",redirect:"/pages/MathUtil/"},{path:"/01.指南/02.核心（Hutool-core）/15.数学/01.数学相关-MathUtil.html",redirect:"/pages/MathUtil/"},{name:"v-584ec5fd",path:"/pages/Exception/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-584ec5fd").then(n)}},{path:"https://doc.hutool.cn/pages/Exception/index.html",redirect:"/pages/Exception/"},{path:"/01.指南/02.核心（Hutool-core）/14.异常/02.其它异常封装.html",redirect:"/pages/Exception/"},{name:"v-563b470c",path:"/pages/AsyncUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-563b470c").then(n)}},{path:"https://doc.hutool.cn/pages/AsyncUtil/index.html",redirect:"/pages/AsyncUtil/"},{path:"/01.指南/02.核心（Hutool-core）/16.线程和并发/02.异步工具类-AsyncUtil.html",redirect:"/pages/AsyncUtil/"},{name:"v-10bd6e8e",path:"/pages/ConcurrencyTester/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-10bd6e8e").then(n)}},{path:"https://doc.hutool.cn/pages/ConcurrencyTester/index.html",redirect:"/pages/ConcurrencyTester/"},{path:"/01.指南/02.核心（Hutool-core）/16.线程和并发/04.高并发测试-ConcurrencyTester.html",redirect:"/pages/ConcurrencyTester/"},{name:"v-e9d6fd42",path:"/pages/ThreadUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-e9d6fd42").then(n)}},{path:"https://doc.hutool.cn/pages/ThreadUtil/index.html",redirect:"/pages/ThreadUtil/"},{path:"/01.指南/02.核心（Hutool-core）/16.线程和并发/01.线程工具-ThreadUtil.html",redirect:"/pages/ThreadUtil/"},{name:"v-45514f4e",path:"/pages/ExecutorBuilder/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-45514f4e").then(n)}},{path:"https://doc.hutool.cn/pages/ExecutorBuilder/index.html",redirect:"/pages/ExecutorBuilder/"},{path:"/01.指南/02.核心（Hutool-core）/16.线程和并发/03.自定义线程池-ExecutorBuilder.html",redirect:"/pages/ExecutorBuilder/"},{name:"v-51b8eafc",path:"/pages/Img/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-51b8eafc").then(n)}},{path:"https://doc.hutool.cn/pages/Img/index.html",redirect:"/pages/Img/"},{path:"/01.指南/02.核心（Hutool-core）/17.图片/02.图片编辑器-Img.html",redirect:"/pages/Img/"},{name:"v-90d3aa78",path:"/pages/NetUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-90d3aa78").then(n)}},{path:"https://doc.hutool.cn/pages/NetUtil/index.html",redirect:"/pages/NetUtil/"},{path:"/01.指南/02.核心（Hutool-core）/18.网络/01.网络工具-NetUtil.html",redirect:"/pages/NetUtil/"},{name:"v-7d37ac67",path:"/pages/UrlBuilder/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7d37ac67").then(n)}},{path:"https://doc.hutool.cn/pages/UrlBuilder/index.html",redirect:"/pages/UrlBuilder/"},{path:"/01.指南/02.核心（Hutool-core）/18.网络/02.URL生成器-UrlBuilder.html",redirect:"/pages/UrlBuilder/"},{name:"v-5f2251f2",path:"/pages/CompilerUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-5f2251f2").then(n)}},{path:"https://doc.hutool.cn/pages/CompilerUtil/index.html",redirect:"/pages/CompilerUtil/"},{path:"/01.指南/02.核心（Hutool-core）/19.源码编译/01.源码编译工具-CompilerUtil.html",redirect:"/pages/CompilerUtil/"},{name:"v-01a9c769",path:"/pages/setting/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-01a9c769").then(n)}},{path:"https://doc.hutool.cn/pages/setting/index.html",redirect:"/pages/setting/"},{path:"/01.指南/03.配置文件(Hutool-setting）/01.概述.html",redirect:"/pages/setting/"},{name:"v-2e6b19f9",path:"/pages/Props/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2e6b19f9").then(n)}},{path:"https://doc.hutool.cn/pages/Props/index.html",redirect:"/pages/Props/"},{path:"/01.指南/03.配置文件(Hutool-setting）/02.Properties扩展-Props.html",redirect:"/pages/Props/"},{name:"v-2bc4bcf4",path:"/pages/log/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2bc4bcf4").then(n)}},{path:"https://doc.hutool.cn/pages/log/index.html",redirect:"/pages/log/"},{path:"/01.指南/04.日志（Hutool-log）/01.概述.html",redirect:"/pages/log/"},{name:"v-05ca86ef",path:"/pages/setting/example/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-05ca86ef").then(n)}},{path:"https://doc.hutool.cn/pages/setting/example/index.html",redirect:"/pages/setting/example/"},{path:"/01.指南/03.配置文件(Hutool-setting）/03.设置文件-Setting.html",redirect:"/pages/setting/example/"},{name:"v-59d3a274",path:"/pages/log/faq/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-59d3a274").then(n)}},{path:"https://doc.hutool.cn/pages/log/faq/index.html",redirect:"/pages/log/faq/"},{path:"/01.指南/04.日志（Hutool-log）/03.疑惑解答.html",redirect:"/pages/log/faq/"},{name:"v-9e552d54",path:"/pages/ImgUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-9e552d54").then(n)}},{path:"https://doc.hutool.cn/pages/ImgUtil/index.html",redirect:"/pages/ImgUtil/"},{path:"/01.指南/02.核心（Hutool-core）/17.图片/01.图片工具-ImgUtil.html",redirect:"/pages/ImgUtil/"},{name:"v-359610e4",path:"/pages/StaticLog/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-359610e4").then(n)}},{path:"https://doc.hutool.cn/pages/StaticLog/index.html",redirect:"/pages/StaticLog/"},{path:"/01.指南/04.日志（Hutool-log）/04.静态调用日志-StaticLog.html",redirect:"/pages/StaticLog/"},{name:"v-014f3d3b",path:"/pages/cache/index/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-014f3d3b").then(n)}},{path:"https://doc.hutool.cn/pages/cache/index/index.html",redirect:"/pages/cache/index/"},{path:"/01.指南/05.缓存（Hutool-cache）/01.概述.html",redirect:"/pages/cache/index/"},{name:"v-7ad66091",path:"/pages/CacheUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7ad66091").then(n)}},{path:"https://doc.hutool.cn/pages/CacheUtil/index.html",redirect:"/pages/CacheUtil/"},{path:"/01.指南/05.缓存（Hutool-cache）/02.缓存工具-CacheUtil.html",redirect:"/pages/CacheUtil/"},{name:"v-9eabf29c",path:"/pages/FIFOCache/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-9eabf29c").then(n)}},{path:"https://doc.hutool.cn/pages/FIFOCache/index.html",redirect:"/pages/FIFOCache/"},{path:"/01.指南/05.缓存（Hutool-cache）/03.先入先出-FIFOCache.html",redirect:"/pages/FIFOCache/"},{name:"v-7e7a2096",path:"/pages/LFUCache/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7e7a2096").then(n)}},{path:"https://doc.hutool.cn/pages/LFUCache/index.html",redirect:"/pages/LFUCache/"},{path:"/01.指南/05.缓存（Hutool-cache）/05.最少使用-LFUCache.html",redirect:"/pages/LFUCache/"},{name:"v-3c7bf13c",path:"/pages/LRUCache/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-3c7bf13c").then(n)}},{path:"https://doc.hutool.cn/pages/LRUCache/index.html",redirect:"/pages/LRUCache/"},{path:"/01.指南/05.缓存（Hutool-cache）/06.最近最久未使用-LRUCache.html",redirect:"/pages/LRUCache/"},{name:"v-7b681b77",path:"/pages/FileCache/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7b681b77").then(n)}},{path:"https://doc.hutool.cn/pages/FileCache/index.html",redirect:"/pages/FileCache/"},{path:"/01.指南/05.缓存（Hutool-cache）/04.文件缓存-FileCache.html",redirect:"/pages/FileCache/"},{name:"v-7037c498",path:"/pages/TimedCache/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7037c498").then(n)}},{path:"https://doc.hutool.cn/pages/TimedCache/index.html",redirect:"/pages/TimedCache/"},{path:"/01.指南/05.缓存（Hutool-cache）/07.超时-TimedCache.html",redirect:"/pages/TimedCache/"},{name:"v-f79652fc",path:"/pages/WeakCache/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-f79652fc").then(n)}},{path:"https://doc.hutool.cn/pages/WeakCache/index.html",redirect:"/pages/WeakCache/"},{path:"/01.指南/05.缓存（Hutool-cache）/08.弱引用-WeakCache.html",redirect:"/pages/WeakCache/"},{name:"v-c17338aa",path:"/pages/JSONUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-c17338aa").then(n)}},{path:"https://doc.hutool.cn/pages/JSONUtil/index.html",redirect:"/pages/JSONUtil/"},{path:"/01.指南/06.JSON（Hutool-json）/02.JSON工具-JSONUtil.html",redirect:"/pages/JSONUtil/"},{name:"v-3a342a82",path:"/pages/json/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-3a342a82").then(n)}},{path:"https://doc.hutool.cn/pages/json/index.html",redirect:"/pages/json/"},{path:"/01.指南/06.JSON（Hutool-json）/01.概述.html",redirect:"/pages/json/"},{name:"v-f24d97ba",path:"/pages/JSONArray/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-f24d97ba").then(n)}},{path:"https://doc.hutool.cn/pages/JSONArray/index.html",redirect:"/pages/JSONArray/"},{path:"/01.指南/06.JSON（Hutool-json）/04.JSON数组-JSONArray.html",redirect:"/pages/JSONArray/"},{name:"v-0b721a8b",path:"/pages/SecureUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-0b721a8b").then(n)}},{path:"https://doc.hutool.cn/pages/SecureUtil/index.html",redirect:"/pages/SecureUtil/"},{path:"/01.指南/07.加密解密（Hutool-crypto）/02.加密解密工具-SecureUtil.html",redirect:"/pages/SecureUtil/"},{name:"v-993a05a0",path:"/pages/SmUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-993a05a0").then(n)}},{path:"https://doc.hutool.cn/pages/SmUtil/index.html",redirect:"/pages/SmUtil/"},{path:"/01.指南/07.加密解密（Hutool-crypto）/03.国密算法工具-SmUtil.html",redirect:"/pages/SmUtil/"},{name:"v-8eb9d4fc",path:"/pages/SymmetricCrypto/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-8eb9d4fc").then(n)}},{path:"https://doc.hutool.cn/pages/SymmetricCrypto/index.html",redirect:"/pages/SymmetricCrypto/"},{path:"/01.指南/07.加密解密（Hutool-crypto）/04.对称加密-SymmetricCrypto.html",redirect:"/pages/SymmetricCrypto/"},{name:"v-a210187a",path:"/pages/Digester/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-a210187a").then(n)}},{path:"https://doc.hutool.cn/pages/Digester/index.html",redirect:"/pages/Digester/"},{path:"/01.指南/07.加密解密（Hutool-crypto）/05.摘要加密-Digester.html",redirect:"/pages/Digester/"},{name:"v-78db46f9",path:"/pages/LogFactory/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-78db46f9").then(n)}},{path:"https://doc.hutool.cn/pages/LogFactory/index.html",redirect:"/pages/LogFactory/"},{path:"/01.指南/04.日志（Hutool-log）/02.日志工厂-LogFactory.html",redirect:"/pages/LogFactory/"},{name:"v-300f8496",path:"/pages/crypto/index/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-300f8496").then(n)}},{path:"https://doc.hutool.cn/pages/crypto/index/index.html",redirect:"/pages/crypto/index/"},{path:"/01.指南/07.加密解密（Hutool-crypto）/01.概述.html",redirect:"/pages/crypto/index/"},{name:"v-1bff50da",path:"/pages/HMac/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1bff50da").then(n)}},{path:"https://doc.hutool.cn/pages/HMac/index.html",redirect:"/pages/HMac/"},{path:"/01.指南/07.加密解密（Hutool-crypto）/06.消息认证码算法-HMac.html",redirect:"/pages/HMac/"},{name:"v-57c6ee20",path:"/pages/Sign/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-57c6ee20").then(n)}},{path:"https://doc.hutool.cn/pages/Sign/index.html",redirect:"/pages/Sign/"},{path:"/01.指南/07.加密解密（Hutool-crypto）/07.签名和验证-Sign.html",redirect:"/pages/Sign/"},{name:"v-76cd8bd2",path:"/pages/db/index/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-76cd8bd2").then(n)}},{path:"https://doc.hutool.cn/pages/db/index/index.html",redirect:"/pages/db/index/"},{path:"/01.指南/09.数据库（Hutool-db）/01.概述.html",redirect:"/pages/db/index/"},{name:"v-5ac4680a",path:"/pages/SqlExecutor/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-5ac4680a").then(n)}},{path:"https://doc.hutool.cn/pages/SqlExecutor/index.html",redirect:"/pages/SqlExecutor/"},{path:"/01.指南/09.数据库（Hutool-db）/02.SQL执行器-SqlExecutor.html",redirect:"/pages/SqlExecutor/"},{name:"v-2f953151",path:"/pages/Session/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2f953151").then(n)}},{path:"https://doc.hutool.cn/pages/Session/index.html",redirect:"/pages/Session/"},{path:"/01.指南/09.数据库（Hutool-db）/03.支持事务的CRUD-Session.html",redirect:"/pages/Session/"},{name:"v-fcf54dac",path:"/pages/Db/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-fcf54dac").then(n)}},{path:"https://doc.hutool.cn/pages/Db/index.html",redirect:"/pages/Db/"},{path:"/01.指南/09.数据库（Hutool-db）/04.数据库简单操作-Db.html",redirect:"/pages/Db/"},{name:"v-41e2f6ee",path:"/pages/JSONObject/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-41e2f6ee").then(n)}},{path:"https://doc.hutool.cn/pages/JSONObject/index.html",redirect:"/pages/JSONObject/"},{path:"/01.指南/06.JSON（Hutool-json）/03.JSON对象-JSONObject.html",redirect:"/pages/JSONObject/"},{name:"v-07a84ac0",path:"/pages/DsFactory/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-07a84ac0").then(n)}},{path:"https://doc.hutool.cn/pages/DsFactory/index.html",redirect:"/pages/DsFactory/"},{path:"/01.指南/09.数据库（Hutool-db）/05.数据源工厂-DsFactory.html",redirect:"/pages/DsFactory/"},{name:"v-2d01b0d8",path:"/pages/blob/example/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2d01b0d8").then(n)}},{path:"https://doc.hutool.cn/pages/blob/example/index.html",redirect:"/pages/blob/example/"},{path:"/01.指南/09.数据库（Hutool-db）/07.案例1-导出Blob字段图像.html",redirect:"/pages/blob/example/"},{name:"v-ba965380",path:"/pages/db/setting/example/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-ba965380").then(n)}},{path:"https://doc.hutool.cn/pages/db/setting/example/index.html",redirect:"/pages/db/setting/example/"},{path:"/01.指南/09.数据库（Hutool-db）/06.数据源配置db.setting样例.html",redirect:"/pages/db/setting/example/"},{name:"v-116c32ea",path:"/pages/dfa/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-116c32ea").then(n)}},{path:"https://doc.hutool.cn/pages/dfa/index.html",redirect:"/pages/dfa/"},{path:"/01.指南/08.DFA查找（Hutool-dfa）/02.DFA查找.html",redirect:"/pages/dfa/"},{name:"v-754889d9",path:"/pages/RedisDS/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-754889d9").then(n)}},{path:"https://doc.hutool.cn/pages/RedisDS/index.html",redirect:"/pages/RedisDS/"},{path:"/01.指南/09.数据库（Hutool-db）/09.NoSQL/01.Redis客户端封装-RedisDS.html",redirect:"/pages/RedisDS/"},{name:"v-73b83b96",path:"/pages/http/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-73b83b96").then(n)}},{path:"https://doc.hutool.cn/pages/http/index.html",redirect:"/pages/http/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/00.概述.html",redirect:"/pages/http/"},{name:"v-72ff0920",path:"/pages/AsymmetricCrypto/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-72ff0920").then(n)}},{path:"https://doc.hutool.cn/pages/AsymmetricCrypto/index.html",redirect:"/pages/AsymmetricCrypto/"},{path:"/01.指南/07.加密解密（Hutool-crypto）/08.非对称加密-AsymmetricCrypto.html",redirect:"/pages/AsymmetricCrypto/"},{name:"v-a075a47e",path:"/pages/dfa/index/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-a075a47e").then(n)}},{path:"https://doc.hutool.cn/pages/dfa/index/index.html",redirect:"/pages/dfa/index/"},{path:"/01.指南/08.DFA查找（Hutool-dfa）/01.概述.html",redirect:"/pages/dfa/index/"},{name:"v-7a2ddb60",path:"/pages/db/faq/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7a2ddb60").then(n)}},{path:"https://doc.hutool.cn/pages/db/faq/index.html",redirect:"/pages/db/faq/"},{path:"/01.指南/09.数据库（Hutool-db）/08.常见问题.html",redirect:"/pages/db/faq/"},{name:"v-4d53113a",path:"/pages/HttpUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4d53113a").then(n)}},{path:"https://doc.hutool.cn/pages/HttpUtil/index.html",redirect:"/pages/HttpUtil/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/01.Http客户端工具类-HttpUtil.html",redirect:"/pages/HttpUtil/"},{name:"v-be476018",path:"/pages/HtmlUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-be476018").then(n)}},{path:"https://doc.hutool.cn/pages/HtmlUtil/index.html",redirect:"/pages/HtmlUtil/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/02.HTML工具类-HtmlUtil.html",redirect:"/pages/HtmlUtil/"},{name:"v-348eef76",path:"/pages/HttpStatus/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-348eef76").then(n)}},{path:"https://doc.hutool.cn/pages/HttpStatus/index.html",redirect:"/pages/HttpStatus/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/06.常用Http状态码-HttpStatus.html",redirect:"/pages/HttpStatus/"},{name:"v-255e37bd",path:"/pages/HttpResponse/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-255e37bd").then(n)}},{path:"https://doc.hutool.cn/pages/HttpResponse/index.html",redirect:"/pages/HttpResponse/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/03.Http响应-HttpResponse.html",redirect:"/pages/HttpResponse/"},{name:"v-6c230934",path:"/pages/UserAgentUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-6c230934").then(n)}},{path:"https://doc.hutool.cn/pages/UserAgentUtil/index.html",redirect:"/pages/UserAgentUtil/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/05.UA工具类-UserAgentUtil.html",redirect:"/pages/UserAgentUtil/"},{name:"v-4a528fa0",path:"/pages/http/example/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4a528fa0").then(n)}},{path:"https://doc.hutool.cn/pages/http/example/index.html",redirect:"/pages/http/example/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/07.案例1-爬取开源中国的开源资讯.html",redirect:"/pages/http/example/"},{name:"v-0092eada",path:"/pages/http/faq/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-0092eada").then(n)}},{path:"https://doc.hutool.cn/pages/http/faq/index.html",redirect:"/pages/http/faq/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/08.常见问题.html",redirect:"/pages/http/faq/"},{name:"v-79b77597",path:"/pages/MongoDS/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-79b77597").then(n)}},{path:"https://doc.hutool.cn/pages/MongoDS/index.html",redirect:"/pages/MongoDS/"},{path:"/01.指南/09.数据库（Hutool-db）/09.NoSQL/02.MongoDB客户端封装-MongoDS.html",redirect:"/pages/MongoDS/"},{name:"v-65e26362",path:"/pages/SimpleServer/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-65e26362").then(n)}},{path:"https://doc.hutool.cn/pages/SimpleServer/index.html",redirect:"/pages/SimpleServer/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/09.Server/10.简易Http服务器-SimpleServer.html",redirect:"/pages/SimpleServer/"},{name:"v-23f50ec4",path:"/pages/cron/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-23f50ec4").then(n)}},{path:"https://doc.hutool.cn/pages/cron/index.html",redirect:"/pages/cron/"},{path:"/01.指南/11.定时任务（Hutool-cron）/01.概述.html",redirect:"/pages/cron/"},{name:"v-58438bce",path:"/pages/SoapClient/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-58438bce").then(n)}},{path:"https://doc.hutool.cn/pages/SoapClient/index.html",redirect:"/pages/SoapClient/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/11.WebService/12.Soap客户端-SoapClient.html",redirect:"/pages/SoapClient/"},{name:"v-1b2ebac0",path:"/pages/HttpRequest/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1b2ebac0").then(n)}},{path:"https://doc.hutool.cn/pages/HttpRequest/index.html",redirect:"/pages/HttpRequest/"},{path:"/01.指南/10.HTTP客户端（Hutool-http）/04.Http请求-HttpRequest.html",redirect:"/pages/HttpRequest/"},{name:"v-0cc20b5b",path:"/pages/CronUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-0cc20b5b").then(n)}},{path:"https://doc.hutool.cn/pages/CronUtil/index.html",redirect:"/pages/CronUtil/"},{path:"/01.指南/11.定时任务（Hutool-cron）/02.全局定时任务-CronUtil.html",redirect:"/pages/CronUtil/"},{name:"v-7243a964",path:"/pages/extra/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7243a964").then(n)}},{path:"https://doc.hutool.cn/pages/extra/index.html",redirect:"/pages/extra/"},{path:"/01.指南/12.扩展（Hutool-extra）/01.概述.html",redirect:"/pages/extra/"},{name:"v-5b368820",path:"/pages/ServletUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-5b368820").then(n)}},{path:"https://doc.hutool.cn/pages/ServletUtil/index.html",redirect:"/pages/ServletUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/02.Servlet工具-ServletUtil.html",redirect:"/pages/ServletUtil/"},{name:"v-f70ddca6",path:"/pages/CglibUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-f70ddca6").then(n)}},{path:"https://doc.hutool.cn/pages/CglibUtil/index.html",redirect:"/pages/CglibUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/05.cglib/01.Cglib工具-CglibUtil.html",redirect:"/pages/CglibUtil/"},{name:"v-cf8973a6",path:"/pages/EmojiUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-cf8973a6").then(n)}},{path:"https://doc.hutool.cn/pages/EmojiUtil/index.html",redirect:"/pages/EmojiUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/06.emoji/01.Emoji工具-EmojiUtil.html",redirect:"/pages/EmojiUtil/"},{name:"v-2a36dce3",path:"/pages/Ftp/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2a36dce3").then(n)}},{path:"https://doc.hutool.cn/pages/Ftp/index.html",redirect:"/pages/Ftp/"},{path:"/01.指南/12.扩展（Hutool-extra）/07.FTP/01.FTP客户端封装-Ftp.html",redirect:"/pages/Ftp/"},{name:"v-a93f2dbe",path:"/pages/SimpleFtpServer/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-a93f2dbe").then(n)}},{path:"https://doc.hutool.cn/pages/SimpleFtpServer/index.html",redirect:"/pages/SimpleFtpServer/"},{path:"/01.指南/12.扩展（Hutool-extra）/07.FTP/02.简易FTP服务器-SimpleFtpServer.html",redirect:"/pages/SimpleFtpServer/"},{name:"v-3519994e",path:"/pages/Sftp/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-3519994e").then(n)}},{path:"https://doc.hutool.cn/pages/Sftp/index.html",redirect:"/pages/Sftp/"},{path:"/01.指南/12.扩展（Hutool-extra）/08.Jsch封装/00.SFTP封装-Sftp.html",redirect:"/pages/Sftp/"},{name:"v-c06c8f68",path:"/pages/JschUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-c06c8f68").then(n)}},{path:"https://doc.hutool.cn/pages/JschUtil/index.html",redirect:"/pages/JschUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/08.Jsch封装/01.Jsch工具-JschUtil.html",redirect:"/pages/JschUtil/"},{name:"v-12c3508d",path:"/pages/QrCodeUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-12c3508d").then(n)}},{path:"https://doc.hutool.cn/pages/QrCodeUtil/index.html",redirect:"/pages/QrCodeUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/03.二维码工具-QrCodeUtil.html",redirect:"/pages/QrCodeUtil/"},{name:"v-8467c352",path:"/pages/TokenizerUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-8467c352").then(n)}},{path:"https://doc.hutool.cn/pages/TokenizerUtil/index.html",redirect:"/pages/TokenizerUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/10.中文分词/01.中文分词封装-TokenizerUtil.html",redirect:"/pages/TokenizerUtil/"},{name:"v-1bec1f01",path:"/pages/MailUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1bec1f01").then(n)}},{path:"https://doc.hutool.cn/pages/MailUtil/index.html",redirect:"/pages/MailUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/04.邮件工具-MailUtil.html",redirect:"/pages/MailUtil/"},{name:"v-d10ed3b6",path:"/pages/CompressUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-d10ed3b6").then(n)}},{path:"https://doc.hutool.cn/pages/CompressUtil/index.html",redirect:"/pages/CompressUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/11.压缩/01.压缩封装-CompressUtil.html",redirect:"/pages/CompressUtil/"},{name:"v-59892333",path:"/pages/PinyinUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-59892333").then(n)}},{path:"https://doc.hutool.cn/pages/PinyinUtil/index.html",redirect:"/pages/PinyinUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/12.拼音/01.拼音工具-PinyinUtil.html",redirect:"/pages/PinyinUtil/"},{name:"v-7ef938c3",path:"/pages/ExpressionUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7ef938c3").then(n)}},{path:"https://doc.hutool.cn/pages/ExpressionUtil/index.html",redirect:"/pages/ExpressionUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/13.表达式引擎/01.表达式引擎封装-ExpressionUtil.html",redirect:"/pages/ExpressionUtil/"},{name:"v-ea1b2768",path:"/pages/bloomFilter/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-ea1b2768").then(n)}},{path:"https://doc.hutool.cn/pages/bloomFilter/index.html",redirect:"/pages/bloomFilter/"},{path:"/01.指南/13.布隆过滤（Hutool-bloomFilter）/01.概述.html",redirect:"/pages/bloomFilter/"},{name:"v-b429df4a",path:"/pages/TemplateUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-b429df4a").then(n)}},{path:"https://doc.hutool.cn/pages/TemplateUtil/index.html",redirect:"/pages/TemplateUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/14.模板引擎/01.模板引擎封装-TemplateUtil.html",redirect:"/pages/TemplateUtil/"},{name:"v-7af52ea7",path:"/pages/aop/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7af52ea7").then(n)}},{path:"https://doc.hutool.cn/pages/aop/index.html",redirect:"/pages/aop/"},{path:"/01.指南/14.切面（Hutool-aop）/01.概述.html",redirect:"/pages/aop/"},{name:"v-9e8c3118",path:"/pages/ProxyUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-9e8c3118").then(n)}},{path:"https://doc.hutool.cn/pages/ProxyUtil/index.html",redirect:"/pages/ProxyUtil/"},{path:"/01.指南/14.切面（Hutool-aop）/02.切面代理工具-ProxyUtil.html",redirect:"/pages/ProxyUtil/"},{name:"v-239deada",path:"/pages/ScriptUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-239deada").then(n)}},{path:"https://doc.hutool.cn/pages/ScriptUtil/index.html",redirect:"/pages/ScriptUtil/"},{path:"/01.指南/15.脚本（Hutool-script）/02.Script工具-ScriptUtil.html",redirect:"/pages/ScriptUtil/"},{name:"v-5e64f3d6",path:"/pages/script/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-5e64f3d6").then(n)}},{path:"https://doc.hutool.cn/pages/script/index.html",redirect:"/pages/script/"},{path:"/01.指南/15.脚本（Hutool-script）/01.概述.html",redirect:"/pages/script/"},{name:"v-ff92bc58",path:"/pages/ExcelWriter/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-ff92bc58").then(n)}},{path:"https://doc.hutool.cn/pages/ExcelWriter/index.html",redirect:"/pages/ExcelWriter/"},{path:"/01.指南/16.Office文档操作（Hutool-poi）/03.Excel生成-ExcelWriter.html",redirect:"/pages/ExcelWriter/"},{name:"v-a71be36a",path:"/pages/BigExcelWriter/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-a71be36a").then(n)}},{path:"https://doc.hutool.cn/pages/BigExcelWriter/index.html",redirect:"/pages/BigExcelWriter/"},{path:"/01.指南/16.Office文档操作（Hutool-poi）/04.Excel大数据生成-BigExcelWriter.html",redirect:"/pages/BigExcelWriter/"},{name:"v-5f57ddce",path:"/pages/poi/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-5f57ddce").then(n)}},{path:"https://doc.hutool.cn/pages/poi/index.html",redirect:"/pages/poi/"},{path:"/01.指南/16.Office文档操作（Hutool-poi）/01.概述.html",redirect:"/pages/poi/"},{name:"v-42fa0b81",path:"/pages/SpringUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-42fa0b81").then(n)}},{path:"https://doc.hutool.cn/pages/SpringUtil/index.html",redirect:"/pages/SpringUtil/"},{path:"/01.指南/12.扩展（Hutool-extra）/09.Spring/01.Spring工具-SpringUtil.html",redirect:"/pages/SpringUtil/"},{name:"v-42809042",path:"/pages/ExcelUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-42809042").then(n)}},{path:"https://doc.hutool.cn/pages/ExcelUtil/index.html",redirect:"/pages/ExcelUtil/"},{path:"/01.指南/16.Office文档操作（Hutool-poi）/02.Excel工具-ExcelUtil.html",redirect:"/pages/ExcelUtil/"},{name:"v-b690a60e",path:"/pages/ExcelReader/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-b690a60e").then(n)}},{path:"https://doc.hutool.cn/pages/ExcelReader/index.html",redirect:"/pages/ExcelReader/"},{path:"/01.指南/16.Office文档操作（Hutool-poi）/05.Excel读取-ExcelReader.html",redirect:"/pages/ExcelReader/"},{name:"v-a51c0314",path:"/pages/Excel07SaxReader/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-a51c0314").then(n)}},{path:"https://doc.hutool.cn/pages/Excel07SaxReader/index.html",redirect:"/pages/Excel07SaxReader/"},{path:"/01.指南/16.Office文档操作（Hutool-poi）/08.流方式读取Excel2007-Excel07SaxReader.html",redirect:"/pages/Excel07SaxReader/"},{name:"v-edbd1a1c",path:"/pages/Word07Writer/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-edbd1a1c").then(n)}},{path:"https://doc.hutool.cn/pages/Word07Writer/index.html",redirect:"/pages/Word07Writer/"},{path:"/01.指南/16.Office文档操作（Hutool-poi）/06.Word生成-Word07Writer.html",redirect:"/pages/Word07Writer/"},{name:"v-e026e1c6",path:"/pages/SystemUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-e026e1c6").then(n)}},{path:"https://doc.hutool.cn/pages/SystemUtil/index.html",redirect:"/pages/SystemUtil/"},{path:"/01.指南/17.系统调用（Hutool-system）/01.系统属性调用-SystemUtil.html",redirect:"/pages/SystemUtil/"},{name:"v-61a4e700",path:"/pages/OshiUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-61a4e700").then(n)}},{path:"https://doc.hutool.cn/pages/OshiUtil/index.html",redirect:"/pages/OshiUtil/"},{path:"/01.指南/17.系统调用（Hutool-system）/02.Oshi封装-OshiUtil.html",redirect:"/pages/OshiUtil/"},{name:"v-4d9946c2",path:"/pages/captcha/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4d9946c2").then(n)}},{path:"https://doc.hutool.cn/pages/captcha/index.html",redirect:"/pages/captcha/"},{path:"/01.指南/18.图形验证码（Hutool-captcha）/01.概述.html",redirect:"/pages/captcha/"},{name:"v-10cdf0c6",path:"/pages/socket/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-10cdf0c6").then(n)}},{path:"https://doc.hutool.cn/pages/socket/index.html",redirect:"/pages/socket/"},{path:"/01.指南/19.网络Socket（Hutool-socket）/01.概述.html",redirect:"/pages/socket/"},{name:"v-ce732f52",path:"/pages/NioServer/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-ce732f52").then(n)}},{path:"https://doc.hutool.cn/pages/NioServer/index.html",redirect:"/pages/NioServer/"},{path:"/01.指南/19.网络Socket（Hutool-socket）/03.NIO封装-NioServer和NioClient.html",redirect:"/pages/NioServer/"},{name:"v-6bf762c9",path:"/pages/jwt/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-6bf762c9").then(n)}},{path:"https://doc.hutool.cn/pages/jwt/index.html",redirect:"/pages/jwt/"},{path:"/01.指南/20.JWT（Hutool-jwt）/01.概述.html",redirect:"/pages/jwt/"},{name:"v-69a41f30",path:"/pages/Excel03SaxReader/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-69a41f30").then(n)}},{path:"https://doc.hutool.cn/pages/Excel03SaxReader/index.html",redirect:"/pages/Excel03SaxReader/"},{path:"/01.指南/16.Office文档操作（Hutool-poi）/07.流方式读取Excel2003-Excel03SaxReader.html",redirect:"/pages/Excel03SaxReader/"},{name:"v-655373ba",path:"/pages/JWTUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-655373ba").then(n)}},{path:"https://doc.hutool.cn/pages/JWTUtil/index.html",redirect:"/pages/JWTUtil/"},{path:"/01.指南/20.JWT（Hutool-jwt）/02.JWT工具-JWTUtil.html",redirect:"/pages/JWTUtil/"},{name:"v-2556fd3f",path:"/pages/JWTSignerUtil/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2556fd3f").then(n)}},{path:"https://doc.hutool.cn/pages/JWTSignerUtil/index.html",redirect:"/pages/JWTSignerUtil/"},{path:"/01.指南/20.JWT（Hutool-jwt）/03.JWT签名工具-JWTSignerUtil.html",redirect:"/pages/JWTSignerUtil/"},{name:"v-798cb182",path:"/pages/JWTValidator/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-798cb182").then(n)}},{path:"https://doc.hutool.cn/pages/JWTValidator/index.html",redirect:"/pages/JWTValidator/"},{path:"/01.指南/20.JWT（Hutool-jwt）/04.JWT验证-JWTValidator.html",redirect:"/pages/JWTValidator/"},{name:"v-9ec23b3a",path:"/module/core/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-9ec23b3a").then(n)}},{path:"https://doc.hutool.cn/module/core/index.html",redirect:"/module/core/"},{path:"/02.模块/02.核心（Hutool-core）.html",redirect:"/module/core/"},{name:"v-2fd09e57",path:"/pages/AioServer/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-2fd09e57").then(n)}},{path:"https://doc.hutool.cn/pages/AioServer/index.html",redirect:"/pages/AioServer/"},{path:"/01.指南/19.网络Socket（Hutool-socket）/02.AIO封装-AioServer和AioClient.html",redirect:"/pages/AioServer/"},{name:"v-f72692ce",path:"/module/setting/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-f72692ce").then(n)}},{path:"https://doc.hutool.cn/module/setting/index.html",redirect:"/module/setting/"},{path:"/02.模块/03.配置文件(Hutool-setting）.html",redirect:"/module/setting/"},{name:"v-874a2d94",path:"/module/log/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-874a2d94").then(n)}},{path:"https://doc.hutool.cn/module/log/index.html",redirect:"/module/log/"},{path:"/02.模块/04.日志（Hutool-log）.html",redirect:"/module/log/"},{name:"v-7be0cdab",path:"/module/cache/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7be0cdab").then(n)}},{path:"https://doc.hutool.cn/module/cache/index.html",redirect:"/module/cache/"},{path:"/02.模块/05.缓存（Hutool-cache）.html",redirect:"/module/cache/"},{name:"v-1237f2a3",path:"/module/json/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-1237f2a3").then(n)}},{path:"https://doc.hutool.cn/module/json/index.html",redirect:"/module/json/"},{path:"/02.模块/06.JSON（Hutool-json）.html",redirect:"/module/json/"},{name:"v-cd5eb84e",path:"/module/crypto/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-cd5eb84e").then(n)}},{path:"https://doc.hutool.cn/module/crypto/index.html",redirect:"/module/crypto/"},{path:"/02.模块/07.加密解密（Hutool-crypto）.html",redirect:"/module/crypto/"},{name:"v-ef8cee36",path:"/module/dfa/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-ef8cee36").then(n)}},{path:"https://doc.hutool.cn/module/dfa/index.html",redirect:"/module/dfa/"},{path:"/02.模块/08.DFA查找（Hutool-dfa）.html",redirect:"/module/dfa/"},{name:"v-503f4502",path:"/module/db/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-503f4502").then(n)}},{path:"https://doc.hutool.cn/module/db/index.html",redirect:"/module/db/"},{path:"/02.模块/09.数据库（Hutool-db）.html",redirect:"/module/db/"},{name:"v-7f839c76",path:"/module/http/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7f839c76").then(n)}},{path:"https://doc.hutool.cn/module/http/index.html",redirect:"/module/http/"},{path:"/02.模块/10.HTTP客户端（Hutool-http）.html",redirect:"/module/http/"},{name:"v-573468e8",path:"/module/cron/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-573468e8").then(n)}},{path:"https://doc.hutool.cn/module/cron/index.html",redirect:"/module/cron/"},{path:"/02.模块/11.定时任务（Hutool-cron）.html",redirect:"/module/cron/"},{name:"v-4a94ddbe",path:"/module/extra/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-4a94ddbe").then(n)}},{path:"https://doc.hutool.cn/module/extra/index.html",redirect:"/module/extra/"},{path:"/02.模块/12.扩展（Hutool-extra）.html",redirect:"/module/extra/"},{name:"v-034cfd88",path:"/module/bloomFilter/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-034cfd88").then(n)}},{path:"https://doc.hutool.cn/module/bloomFilter/index.html",redirect:"/module/bloomFilter/"},{path:"/02.模块/13.布隆过滤（Hutool-bloomFilter）.html",redirect:"/module/bloomFilter/"},{name:"v-755203b9",path:"/module/script/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-755203b9").then(n)}},{path:"https://doc.hutool.cn/module/script/index.html",redirect:"/module/script/"},{path:"/02.模块/15.脚本（Hutool-script）.html",redirect:"/module/script/"},{name:"v-6565e77a",path:"/module/captcha/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-6565e77a").then(n)}},{path:"https://doc.hutool.cn/module/captcha/index.html",redirect:"/module/captcha/"},{path:"/02.模块/18.图形验证码（Hutool-captcha）.html",redirect:"/module/captcha/"},{name:"v-559e6da6",path:"/module/jwt/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-559e6da6").then(n)}},{path:"https://doc.hutool.cn/module/jwt/index.html",redirect:"/module/jwt/"},{path:"/02.模块/20.JWT（Hutool-jwt）.html",redirect:"/module/jwt/"},{name:"v-7930af96",path:"/module/system/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7930af96").then(n)}},{path:"https://doc.hutool.cn/module/system/index.html",redirect:"/module/system/"},{path:"/02.模块/17.系统调用（Hutool-system）.html",redirect:"/module/system/"},{name:"v-71bbe5a6",path:"/pages/support/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-71bbe5a6").then(n)}},{path:"https://doc.hutool.cn/pages/support/index.html",redirect:"/pages/support/"},{path:"/03.支持/01.支持.html",redirect:"/pages/support/"},{name:"v-e35e4bc0",path:"/pages/KnowledgePlanet/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-e35e4bc0").then(n)}},{path:"https://doc.hutool.cn/pages/KnowledgePlanet/index.html",redirect:"/pages/KnowledgePlanet/"},{path:"https://doc.hutool.cn/04.知识星球/01.知识星球.html",redirect:"/pages/KnowledgePlanet/"},{name:"v-7d9c622a",path:"/module/socket/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-7d9c622a").then(n)}},{path:"https://doc.hutool.cn/module/socket/index.html",redirect:"/module/socket/"},{path:"/02.模块/19.网络Socket（Hutool-socket）.html",redirect:"/module/socket/"},{name:"v-73864004",path:"/module/poi/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-73864004").then(n)}},{path:"https://doc.hutool.cn/module/poi/index.html",redirect:"/module/poi/"},{path:"/02.模块/16.Office文档操作（Hutool-poi）.html",redirect:"/module/poi/"},{name:"v-5f539617",path:"/module/aop/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-5f539617").then(n)}},{path:"https://doc.hutool.cn/module/aop/index.html",redirect:"/module/aop/"},{path:"/02.模块/14.切面（Hutool-aop）.html",redirect:"/module/aop/"},{name:"v-39a42cf8",path:"/blog/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-39a42cf8").then(n)}},{path:"https://doc.hutool.cn/blog/index.html",redirect:"/blog/"},{path:"https://doc.hutool.cn/@pages/archivesPage.html",redirect:"/blog/"},{name:"v-61189df0",path:"/",component:ys,beforeEnter:(e,t,n)=>{uo("Layout","v-61189df0").then(n)}},{path:"https://doc.hutool.cn/index.html",redirect:"/"},{path:"*",component:ys}],Es={title:"Hutool",description:"Hutool 官方文档",base:"/",headTags:[["link",{rel:"icon",href:"../../img/favicon.ico"/*tpa=https://doc.hutool.cn/img/favicon.ico*/}],["meta",{name:"keywords",content:"hutool,Java工具集,java,orm,tools,工具"}],["meta",{name:"theme-color",content:"#11a8cd"}],["script",{src:"https://cdn.wwads.cn/js/makemoney.js",async:!0,type:"text/javascript"}]],pages:[{title:"简介",frontmatter:{title:"简介",date:"2024-02-27T15:13:10.000Z",permalink:"/pages/index/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/01.%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01.%E7%AE%80%E4%BB%8B.html",relativePath:"01.指南/01.快速入门/01.简介.md",key:"v-5e192e06",path:"/pages/index/",headers:[{level:2,title:"📚简介",slug:"📚简介",normalizedTitle:"📚简介",charIndex:2},{level:3,title:"🎁Hutool名称的由来",slug:"🎁hutool名称的由来",normalizedTitle:"🎁hutool名称的由来",charIndex:261},{level:3,title:"🍺Hutool如何改变我们的coding方式",slug:"🍺hutool如何改变我们的coding方式",normalizedTitle:"🍺hutool如何改变我们的coding方式",charIndex:373},{level:2,title:"🛠️包含组件",slug:"🛠️包含组件",normalizedTitle:"🛠️包含组件",charIndex:659},{level:2,title:"引入",slug:"引入",normalizedTitle:"引入",charIndex:539},{level:3,title:"import方式",slug:"import方式",normalizedTitle:"import方式",charIndex:2176},{level:3,title:"exclude方式",slug:"exclude方式",normalizedTitle:"exclude方式",charIndex:2854},{level:2,title:"📝其它文档",slug:"📝其它文档",normalizedTitle:"📝其它文档",charIndex:3540},{level:2,title:"🪙支持Hutool",slug:"🪙支持hutool",normalizedTitle:"🪙支持hutool",charIndex:3610},{level:3,title:"💳捐赠",slug:"💳捐赠",normalizedTitle:"💳捐赠",charIndex:3625},{level:2,title:"📦安装",slug:"📦安装",normalizedTitle:"📦安装",charIndex:3740},{level:3,title:"🍊Maven",slug:"🍊maven",normalizedTitle:"🍊maven",charIndex:3749},{level:3,title:"🍐Gradle",slug:"🍐gradle",normalizedTitle:"🍐gradle",charIndex:3928},{level:3,title:"📥下载jar",slug:"📥下载jar",normalizedTitle:"📥下载jar",charIndex:3988},{level:3,title:"🚽编译安装",slug:"🚽编译安装",normalizedTitle:"🚽编译安装",charIndex:4142},{level:2,title:"🏗️添砖加瓦",slug:"🏗️添砖加瓦",normalizedTitle:"🏗️添砖加瓦",charIndex:4334},{level:3,title:"🎋分支说明",slug:"🎋分支说明",normalizedTitle:"🎋分支说明",charIndex:4346},{level:3,title:"🐞提供bug反馈或建议",slug:"🐞提供bug反馈或建议",normalizedTitle:"🐞提供bug反馈或建议",charIndex:4495},{level:3,title:"🧬贡献代码的步骤",slug:"🧬贡献代码的步骤",normalizedTitle:"🧬贡献代码的步骤",charIndex:4584},{level:3,title:"📐PR遵照的原则",slug:"📐pr遵照的原则",normalizedTitle:"📐pr遵照的原则",charIndex:4800},{level:2,title:"⭐Star Hutool",slug:"⭐star-hutool",normalizedTitle:"⭐star hutool",charIndex:5354},{level:2,title:"📌 知识星球",slug:"📌-知识星球",normalizedTitle:"📌 知识星球",charIndex:5373},{level:4,title:"Hutool为什么要搞知识星球？",slug:"hutool为什么要搞知识星球",normalizedTitle:"hutool为什么要搞知识星球？",charIndex:5384},{level:4,title:"Hutool 知识星球提供什么服务？",slug:"hutool-知识星球提供什么服务",normalizedTitle:"hutool 知识星球提供什么服务？",charIndex:5471},{level:4,title:"谁需要加入星球？",slug:"谁需要加入星球",normalizedTitle:"谁需要加入星球？",charIndex:5639},{level:4,title:"谁不需要加入星球",slug:"谁不需要加入星球",normalizedTitle:"谁不需要加入星球",charIndex:5778},{level:4,title:"最后给小白一点点建议",slug:"最后给小白一点点建议",normalizedTitle:"最后给小白一点点建议",charIndex:5885}],headersStr:"📚简介 🎁Hutool名称的由来 🍺Hutool如何改变我们的coding方式 🛠️包含组件 引入 import方式 exclude方式 📝其它文档 🪙支持Hutool 💳捐赠 📦安装 🍊Maven 🍐Gradle 📥下载jar 🚽编译安装 🏗️添砖加瓦 🎋分支说明 🐞提供bug反馈或建议 🧬贡献代码的步骤 📐PR遵照的原则 ⭐Star Hutool 📌 知识星球 Hutool为什么要搞知识星球？ Hutool 知识星球提供什么服务？ 谁需要加入星球？ 谁不需要加入星球 最后给小白一点点建议",content:"# 📚简介\n\nHutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。\n\nHutool中的工具方法来自每个用户的精雕细琢，它涵盖了Java开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；\n\nHutool是项目中“util”包友好的替代，它节省了开发人员对项目中公用类和公用工具方法的封装时间，使开发专注于业务，同时可以最大限度的避免封装不完善带来的bug。\n\n\n# 🎁Hutool名称的由来\n\nHutool = Hu + tool，是原公司项目底层代码剥离后的开源库，“Hu”是公司名称的表示，tool表示工具。Hutool谐音“糊涂”，一方面简洁易懂，一方面寓意“难得糊涂”。\n\n\n# 🍺Hutool如何改变我们的coding方式\n\nHutool的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。\n\n以计算MD5为例：\n\n * 👴【以前】打开搜索引擎 -> 搜“Java MD5加密” -> 打开某篇博客-> 复制粘贴 -> 改改好用\n * 👦【现在】引入Hutool -> SecureUtil.md5()\n\nHutool的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的bug。\n\n----------------------------------------\n\n\n# 🛠️包含组件\n\n一个Java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件：\n\n模块                   介绍\nhutool-aop           JDK动态代理封装，提供非IOC下的切面支持\nhutool-bloomFilter   布隆过滤，提供一些Hash算法的布隆过滤\nhutool-cache         简单缓存实现\nhutool-core          核心，包括Bean操作、日期、各种Util等\nhutool-cron          定时任务模块，提供类Crontab表达式的定时任务\nhutool-crypto        加密解密模块，提供对称、非对称和摘要算法封装\nhutool-db            JDBC封装后的数据操作，基于ActiveRecord思想\nhutool-dfa           基于DFA模型的多关键字查找\nhutool-extra         扩展模块，对第三方封装（模板引擎、邮件、Servlet、二维码、Emoji、FTP、分词等）\nhutool-http          基于HttpUrlConnection的Http客户端封装\nhutool-log           自动识别日志实现的日志门面\nhutool-script        脚本执行封装，例如Javascript\nhutool-setting       功能更强大的Setting配置文件和Properties封装\nhutool-system        系统参数调用封装（JVM信息等）\nhutool-json          JSON实现\nhutool-captcha       图片验证码实现\nhutool-poi           针对POI中Excel和Word的封装\nhutool-socket        基于Java的NIO和AIO的Socket封装\nhutool-jwt           JSON Web Token (JWT)封装实现\n\n\n# 引入\n\nHutool-all是一个Hutool的集成打包产品，由于考虑到“懒人”用户及分不清各个模块作用的用户，“无脑”引入hutool-all模块是快速开始和深入应用的最佳方式。\n\n起初Hutool只提供了两种引入方式：\n\n 1. 引入hutool-all以便使用所有工具类功能\n\n 2. 引入hutool-xxx单独模块使用\n\n后来t-io的作者谭总提出是否可以引入一个bom包，一次性引入所有子模块，然后将不用的模块排除掉。起初我是排斥的，认为这种方式用处不大（其实是我不会写……）\n\n再后来接触了Maven的这部分，于是有了hutool-bom模块！\n\n当然这个模块的存在一直有争议，因为真正的bom包是一个模块管理包，正确的打开方式是可以引入，再引入需要的模块（只是不用重复版本号而已），Hutool中\"排除\"方式就变得非常异类，真是让人头大。\n\n当然转机来自于一个issue：BOM should be declared in dependencyManagement for import\n\n@JasonMing 大神给了一个非常棒的方案，可以两者兼得，于是纠结症的我终于释怀了，现在的bom模块变得异常灵活！\n\n整个bom模块只由一个pom.xml组成，同时提供了dependencyManagement和dependencies两种声明。于是我们就可以针对不同需要完成引入。\n\n\n# import方式\n\n如果你想像Spring-Boot一样引入Hutool，再由子模块决定用到哪些模块，你可以在父模块中加入：\n\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-bom</artifactId>\n            <version>${hutool.version}</version>\n            <type>pom</type>\n            \x3c!-- 注意这里是import --\x3e\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n\n在子模块中就可以引入自己需要的模块了：\n\n<dependencies>\n    <dependency>\n        <groupId>cn.hutool</groupId>\n        <artifactId>hutool-http</artifactId>\n    </dependency>\n</dependencies>\n\n\n> 使用import的方式，只会引入hutool-bom内的dependencyManagement的配置，其它配置在这个引用方式下完全不起作用。\n\n\n# exclude方式\n\n如果你引入的模块比较多，但是某几个模块没用，你可以：\n\n<dependencies>\n    <dependency>\n        <groupId>cn.hutool</groupId>\n        <artifactId>hutool-bom</artifactId>\n        <version>${hutool.version}</version>\n        \x3c!-- 加不加这句都能跑，区别只有是否告警  --\x3e\n        <type>pom</type>\n        <exclusions>\n            <exclusion>\n                    <groupId>cn.hutool</groupId>\n                    <artifactId>hutool-system</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n\n\n> 这个配置会传递依赖hutool-bom内所有dependencies的内容，当前hutool-bom内的dependencies全部设置了version，就意味着在maven resolve的时候hutool-bom内就算存在dependencyManagement也不会产生任何作用。\n\n----------------------------------------\n\n\n# 📝其它文档\n\n📙参考API\n\n🎬视频介绍\n\n----------------------------------------\n\n\n# 🪙支持Hutool\n\n\n# 💳捐赠\n\n如果你觉得Hutool不错，可以捐赠请维护者吃包辣条~，在此表示感谢^_^。\n\nGitee上捐赠\n\n捐赠给Dromara组织\n\n----------------------------------------\n\n\n# 📦安装\n\n\n# 🍊Maven\n\n在项目的pom.xml的dependencies中加入以下内容:\n\n\n<dependency>\n    <groupId>cn.hutool</groupId>\n    <artifactId>hutool-all</artifactId>\n    <version>5.8.26</version>\n</dependency>\n\n\n\n# 🍐Gradle\n\nimplementation 'cn.hutool:hutool-all:5.8.26'\n\n\n\n# 📥下载jar\n\n点击以下链接，下载hutool-all-X.X.X.jar即可：\n\n * Maven中央库\n\n> 🔔️注意 Hutool 5.x支持JDK8+，对Android平台没有测试，不能保证所有工具类或工具方法可用。 如果你的项目使用JDK7，请使用Hutool 4.x版本（不再更新）\n\n\n# 🚽编译安装\n\n访问Hutool的Gitee主页：https://gitee.com/dromara/hutool 下载整个项目源码（v5-master或v5-dev分支都可）然后进入Hutool项目目录执行：\n\n./hutool.sh install\n\n\n然后就可以使用Maven引入了。\n\n----------------------------------------\n\n\n# 🏗️添砖加瓦\n\n\n# 🎋分支说明\n\nHutool的源码分为两个分支，功能如下：\n\n分支          作用\nv5-master   主分支，release版本使用的分支，与中央库提交的jar一致，不接收任何pr或修改\nv5-dev      开发分支，默认为下个版本的SNAPSHOT版本，接受修改或pr\n\n\n# 🐞提供bug反馈或建议\n\n提交问题反馈请说明正在使用的JDK版本呢、Hutool版本和相关依赖库版本。\n\n * Gitee issue\n * Github issue\n\n\n# 🧬贡献代码的步骤\n\n 1. 在Gitee或者Github上fork项目到自己的repo\n 2. 把fork过去的项目也就是你的项目clone到你的本地\n 3. 修改代码（记得一定要修改v5-dev分支）\n 4. commit后push到自己的库（v5-dev分支）\n 5. 登录Gitee或Github在你首页可以看到一个 pull request 按钮，点击它，填写一些说明信息，然后提交即可。\n 6. 等待维护者合并\n\n\n# 📐PR遵照的原则\n\nHutool欢迎任何人为Hutool添砖加瓦，贡献代码，不过维护者是一个强迫症患者，为了照顾病人，需要提交的pr（pull request）符合一些规范，规范如下：\n\n 1. 注释完备，尤其每个新增的方法应按照Java文档规范标明方法说明、参数说明、返回值说明等信息，必要时请添加单元测试，如果愿意，也可以加上你的大名。\n 2. Hutool的缩进按照Eclipse（不要跟我说IDEA多好用，维护者非常懒，学不会 ，IDEA真香，改了Eclipse快捷键后舒服多了）默认（tab）缩进，所以请遵守（不要和我争执空格与tab的问题，这是一个病人的习惯）。\n 3. 新加的方法不要使用第三方库的方法，Hutool遵循无依赖原则（除非在extra模块中加方法工具）。\n 4. 请pull request到v5-dev分支。Hutool在5.x版本后使用了新的分支：v5-master是主分支，表示已经发布中央库的版本，这个分支不允许pr，也不允许修改。\n 5. 我们如果关闭了你的issue或pr，请不要诧异，这是我们保持问题处理整洁的一种方式，你依旧可以继续讨论，当有讨论结果时我们会重新打开。\n\n----------------------------------------\n\n\n# ⭐Star Hutool\n\n\n\n\n# 📌 知识星球\n\n# Hutool为什么要搞知识星球？\n\nHutool是一个开源软件，目前只有官网广告收入。 我们软件开源了， 也需要在收入上进行“开源节流“。\n\n因此开通了付费知识星球。\n\n# Hutool 知识星球提供什么服务？\n\n 1. Hutool使用方法问答。 经常有程序员在群里问Hutool有没有某某功能，Hutool某某功能怎么使用等等。 星球可以提供这方面的服务。\n 2. Sloth脚手架，现在正在开发中。 https://sloth.hutool.cn 为预览地址，代码在星球中。 我们会一直迭代开发。\n\n# 谁需要加入星球？\n\n 1. 愿意支持Hutool的朋友们，可以把他看作一种捐赠行为。如果你觉得Hutool不错，可以给我们捐赠一下。\n 2. 开发新人使用Hutool过程不是很顺利，可以加入星球寻求帮助。\n 3. 想要使用一个脚手架开发项目，Sloth可以做为一个选择。\n\n# 谁不需要加入星球\n\n 1. Hutool有比较完整的文档和免费的QQ群，如果你能够正常使用Hutool完成工作就不需要加入星球。\n 2. 对星球期望过高的小伙伴， 我们不是万能的，没有办法给你解决所有问题。\n\n# 最后给小白一点点建议\n\n近年知识付费很火，但水平参差不齐， 如果你想从零入门java开发。 B站是一个很好的平台， 一些传统大型的机构都在上面开课。他们在教育行业深耕多年，还是非常有水平的。 希望大家擦亮双眼。\n\n最近祝大家2024年大吉大利，身体健康，万事如意。\n\n",normalizedContent:"# 📚简介\n\nhutool是一个小而全的java工具类库，通过静态方法封装，降低相关api的学习成本，提高工作效率，使java拥有函数式语言般的优雅，让java语言也可以“甜甜的”。\n\nhutool中的工具方法来自每个用户的精雕细琢，它涵盖了java开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；\n\nhutool是项目中“util”包友好的替代，它节省了开发人员对项目中公用类和公用工具方法的封装时间，使开发专注于业务，同时可以最大限度的避免封装不完善带来的bug。\n\n\n# 🎁hutool名称的由来\n\nhutool = hu + tool，是原公司项目底层代码剥离后的开源库，“hu”是公司名称的表示，tool表示工具。hutool谐音“糊涂”，一方面简洁易懂，一方面寓意“难得糊涂”。\n\n\n# 🍺hutool如何改变我们的coding方式\n\nhutool的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。\n\n以计算md5为例：\n\n * 👴【以前】打开搜索引擎 -> 搜“java md5加密” -> 打开某篇博客-> 复制粘贴 -> 改改好用\n * 👦【现在】引入hutool -> secureutil.md5()\n\nhutool的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的bug。\n\n----------------------------------------\n\n\n# 🛠️包含组件\n\n一个java基础工具类，对文件、流、加密解密、转码、正则、线程、xml等jdk方法进行封装，组成各种util工具类，同时提供以下组件：\n\n模块                   介绍\nhutool-aop           jdk动态代理封装，提供非ioc下的切面支持\nhutool-bloomfilter   布隆过滤，提供一些hash算法的布隆过滤\nhutool-cache         简单缓存实现\nhutool-core          核心，包括bean操作、日期、各种util等\nhutool-cron          定时任务模块，提供类crontab表达式的定时任务\nhutool-crypto        加密解密模块，提供对称、非对称和摘要算法封装\nhutool-db            jdbc封装后的数据操作，基于activerecord思想\nhutool-dfa           基于dfa模型的多关键字查找\nhutool-extra         扩展模块，对第三方封装（模板引擎、邮件、servlet、二维码、emoji、ftp、分词等）\nhutool-http          基于httpurlconnection的http客户端封装\nhutool-log           自动识别日志实现的日志门面\nhutool-script        脚本执行封装，例如javascript\nhutool-setting       功能更强大的setting配置文件和properties封装\nhutool-system        系统参数调用封装（jvm信息等）\nhutool-json          json实现\nhutool-captcha       图片验证码实现\nhutool-poi           针对poi中excel和word的封装\nhutool-socket        基于java的nio和aio的socket封装\nhutool-jwt           json web token (jwt)封装实现\n\n\n# 引入\n\nhutool-all是一个hutool的集成打包产品，由于考虑到“懒人”用户及分不清各个模块作用的用户，“无脑”引入hutool-all模块是快速开始和深入应用的最佳方式。\n\n起初hutool只提供了两种引入方式：\n\n 1. 引入hutool-all以便使用所有工具类功能\n\n 2. 引入hutool-xxx单独模块使用\n\n后来t-io的作者谭总提出是否可以引入一个bom包，一次性引入所有子模块，然后将不用的模块排除掉。起初我是排斥的，认为这种方式用处不大（其实是我不会写……）\n\n再后来接触了maven的这部分，于是有了hutool-bom模块！\n\n当然这个模块的存在一直有争议，因为真正的bom包是一个模块管理包，正确的打开方式是可以引入，再引入需要的模块（只是不用重复版本号而已），hutool中\"排除\"方式就变得非常异类，真是让人头大。\n\n当然转机来自于一个issue：bom should be declared in dependencymanagement for import\n\n@jasonming 大神给了一个非常棒的方案，可以两者兼得，于是纠结症的我终于释怀了，现在的bom模块变得异常灵活！\n\n整个bom模块只由一个pom.xml组成，同时提供了dependencymanagement和dependencies两种声明。于是我们就可以针对不同需要完成引入。\n\n\n# import方式\n\n如果你想像spring-boot一样引入hutool，再由子模块决定用到哪些模块，你可以在父模块中加入：\n\n<dependencymanagement>\n    <dependencies>\n        <dependency>\n            <groupid>cn.hutool</groupid>\n            <artifactid>hutool-bom</artifactid>\n            <version>${hutool.version}</version>\n            <type>pom</type>\n            \x3c!-- 注意这里是import --\x3e\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencymanagement>\n\n\n在子模块中就可以引入自己需要的模块了：\n\n<dependencies>\n    <dependency>\n        <groupid>cn.hutool</groupid>\n        <artifactid>hutool-http</artifactid>\n    </dependency>\n</dependencies>\n\n\n> 使用import的方式，只会引入hutool-bom内的dependencymanagement的配置，其它配置在这个引用方式下完全不起作用。\n\n\n# exclude方式\n\n如果你引入的模块比较多，但是某几个模块没用，你可以：\n\n<dependencies>\n    <dependency>\n        <groupid>cn.hutool</groupid>\n        <artifactid>hutool-bom</artifactid>\n        <version>${hutool.version}</version>\n        \x3c!-- 加不加这句都能跑，区别只有是否告警  --\x3e\n        <type>pom</type>\n        <exclusions>\n            <exclusion>\n                    <groupid>cn.hutool</groupid>\n                    <artifactid>hutool-system</artifactid>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n\n\n> 这个配置会传递依赖hutool-bom内所有dependencies的内容，当前hutool-bom内的dependencies全部设置了version，就意味着在maven resolve的时候hutool-bom内就算存在dependencymanagement也不会产生任何作用。\n\n----------------------------------------\n\n\n# 📝其它文档\n\n📙参考api\n\n🎬视频介绍\n\n----------------------------------------\n\n\n# 🪙支持hutool\n\n\n# 💳捐赠\n\n如果你觉得hutool不错，可以捐赠请维护者吃包辣条~，在此表示感谢^_^。\n\ngitee上捐赠\n\n捐赠给dromara组织\n\n----------------------------------------\n\n\n# 📦安装\n\n\n# 🍊maven\n\n在项目的pom.xml的dependencies中加入以下内容:\n\n\n<dependency>\n    <groupid>cn.hutool</groupid>\n    <artifactid>hutool-all</artifactid>\n    <version>5.8.26</version>\n</dependency>\n\n\n\n# 🍐gradle\n\nimplementation 'cn.hutool:hutool-all:5.8.26'\n\n\n\n# 📥下载jar\n\n点击以下链接，下载hutool-all-x.x.x.jar即可：\n\n * maven中央库\n\n> 🔔️注意 hutool 5.x支持jdk8+，对android平台没有测试，不能保证所有工具类或工具方法可用。 如果你的项目使用jdk7，请使用hutool 4.x版本（不再更新）\n\n\n# 🚽编译安装\n\n访问hutool的gitee主页：https://gitee.com/dromara/hutool 下载整个项目源码（v5-master或v5-dev分支都可）然后进入hutool项目目录执行：\n\n./hutool.sh install\n\n\n然后就可以使用maven引入了。\n\n----------------------------------------\n\n\n# 🏗️添砖加瓦\n\n\n# 🎋分支说明\n\nhutool的源码分为两个分支，功能如下：\n\n分支          作用\nv5-master   主分支，release版本使用的分支，与中央库提交的jar一致，不接收任何pr或修改\nv5-dev      开发分支，默认为下个版本的snapshot版本，接受修改或pr\n\n\n# 🐞提供bug反馈或建议\n\n提交问题反馈请说明正在使用的jdk版本呢、hutool版本和相关依赖库版本。\n\n * gitee issue\n * github issue\n\n\n# 🧬贡献代码的步骤\n\n 1. 在gitee或者github上fork项目到自己的repo\n 2. 把fork过去的项目也就是你的项目clone到你的本地\n 3. 修改代码（记得一定要修改v5-dev分支）\n 4. commit后push到自己的库（v5-dev分支）\n 5. 登录gitee或github在你首页可以看到一个 pull request 按钮，点击它，填写一些说明信息，然后提交即可。\n 6. 等待维护者合并\n\n\n# 📐pr遵照的原则\n\nhutool欢迎任何人为hutool添砖加瓦，贡献代码，不过维护者是一个强迫症患者，为了照顾病人，需要提交的pr（pull request）符合一些规范，规范如下：\n\n 1. 注释完备，尤其每个新增的方法应按照java文档规范标明方法说明、参数说明、返回值说明等信息，必要时请添加单元测试，如果愿意，也可以加上你的大名。\n 2. hutool的缩进按照eclipse（不要跟我说idea多好用，维护者非常懒，学不会 ，idea真香，改了eclipse快捷键后舒服多了）默认（tab）缩进，所以请遵守（不要和我争执空格与tab的问题，这是一个病人的习惯）。\n 3. 新加的方法不要使用第三方库的方法，hutool遵循无依赖原则（除非在extra模块中加方法工具）。\n 4. 请pull request到v5-dev分支。hutool在5.x版本后使用了新的分支：v5-master是主分支，表示已经发布中央库的版本，这个分支不允许pr，也不允许修改。\n 5. 我们如果关闭了你的issue或pr，请不要诧异，这是我们保持问题处理整洁的一种方式，你依旧可以继续讨论，当有讨论结果时我们会重新打开。\n\n----------------------------------------\n\n\n# ⭐star hutool\n\n\n\n\n# 📌 知识星球\n\n# hutool为什么要搞知识星球？\n\nhutool是一个开源软件，目前只有官网广告收入。 我们软件开源了， 也需要在收入上进行“开源节流“。\n\n因此开通了付费知识星球。\n\n# hutool 知识星球提供什么服务？\n\n 1. hutool使用方法问答。 经常有程序员在群里问hutool有没有某某功能，hutool某某功能怎么使用等等。 星球可以提供这方面的服务。\n 2. sloth脚手架，现在正在开发中。 https://sloth.hutool.cn 为预览地址，代码在星球中。 我们会一直迭代开发。\n\n# 谁需要加入星球？\n\n 1. 愿意支持hutool的朋友们，可以把他看作一种捐赠行为。如果你觉得hutool不错，可以给我们捐赠一下。\n 2. 开发新人使用hutool过程不是很顺利，可以加入星球寻求帮助。\n 3. 想要使用一个脚手架开发项目，sloth可以做为一个选择。\n\n# 谁不需要加入星球\n\n 1. hutool有比较完整的文档和免费的qq群，如果你能够正常使用hutool完成工作就不需要加入星球。\n 2. 对星球期望过高的小伙伴， 我们不是万能的，没有办法给你解决所有问题。\n\n# 最后给小白一点点建议\n\n近年知识付费很火，但水平参差不齐， 如果你想从零入门java开发。 b站是一个很好的平台， 一些传统大型的机构都在上面开课。他们在教育行业深耕多年，还是非常有水平的。 希望大家擦亮双眼。\n\n最近祝大家2024年大吉大利，身体健康，万事如意。\n\n",charsets:{cjk:!0},lastUpdated:"2024/03/13, 20:53:26",lastUpdatedTimestamp:1710334406e3},{title:"自定义类型转换-ConverterRegistry",frontmatter:{title:"自定义类型转换-ConverterRegistry",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ConverterRegistry/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/02.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/02.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-ConverterRegistry.html",relativePath:"01.指南/02.核心（Hutool-core）/02.类型转换/02.自定义类型转换-ConverterRegistry.md",key:"v-3df1eca8",path:"/pages/ConverterRegistry/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"解决",slug:"解决",normalizedTitle:"解决",charIndex:111},{level:3,title:"自定义转换",slug:"自定义转换",normalizedTitle:"自定义转换",charIndex:301},{level:3,title:"ConverterRegistry单例和对象模式",slug:"converterregistry单例和对象模式",normalizedTitle:"converterregistry单例和对象模式",charIndex:1485}],headersStr:"由来 解决 自定义转换 ConverterRegistry单例和对象模式",content:'# 由来\n\nHutool中类型转换最早只是一个工具类，叫做“Convert”，对于每一种类型转换都是用一个静态方法表示，但是这种方式有一个潜在问题，那就是扩展性不足，这导致Hutool只能满足部分类型转换的需求。\n\n\n# 解决\n\n为了解决这些问题，我对Hutool中这个类做了扩展。思想如下：\n\n * Converter 类型转换接口，通过实现这个接口，重写convert方法，以实现不同类型的对象转换\n * ConverterRegistry 类型转换登记中心。将各种类型Convert对象放入登记中心，通过convert方法查找目标类型对应的转换器，将被转换对象转换之。在此类中，存放着默认转换器和自定义转换器，默认转换器是Hutool中预定义的一些转换器，自定义转换器存放用户自定的转换器。\n\n通过这种方式，实现类灵活的类型转换。使用方式如下：\n\nint a = 3423;\nConverterRegistry converterRegistry = ConverterRegistry.getInstance();\nString result = converterRegistry.convert(String.class, a);\nAssert.assertEquals("3423", result);\n\n\n\n# 自定义转换\n\nHutool的默认转换有时候并不能满足我们自定义对象的一些需求，这时我们可以使用ConverterRegistry.getInstance().putCustom()方法自定义类型转换。\n\n 1. 自定义转换器\n\npublic static class CustomConverter implements Converter<String>{\n\t@Override\n\tpublic String convert(Object value, String defaultValue) throws IllegalArgumentException {\n\t\treturn "Custom: " + value.toString();\n\t}\n}\n\n\n 2. 注册转换器\n\nConverterRegistry converterRegistry = ConverterRegistry.getInstance();\n//此处做为示例自定义String转换，因为Hutool中已经提供String转换，请尽量不要替换\n//替换可能引发关联转换异常（例如覆盖String转换会影响全局）\nconverterRegistry.putCustom(String.class, CustomConverter.class);\n\n\n 3. 执行转换\n\nint a = 454553;\nString result = converterRegistry.convert(String.class, a);\nAssert.assertEquals("Custom: 454553", result);\n\n\n> 注意： convert(Class type, Object value, T defaultValue, boolean isCustomFirst)方法的最后一个参数可以选择转换时优先使用自定义转换器还是默认转换器。convert(Class type, Object value, T defaultValue)和convert(Class type, Object value)两个重载方法都是使用自定义转换器优先的模式。\n\n\n# ConverterRegistry单例和对象模式\n\nConverterRegistry提供一个静态方法getInstance()返回全局单例对象，这也是推荐的使用方式，当然如果想在某个限定范围内自定义转换，可以实例化ConverterRegistry对象。',normalizedContent:'# 由来\n\nhutool中类型转换最早只是一个工具类，叫做“convert”，对于每一种类型转换都是用一个静态方法表示，但是这种方式有一个潜在问题，那就是扩展性不足，这导致hutool只能满足部分类型转换的需求。\n\n\n# 解决\n\n为了解决这些问题，我对hutool中这个类做了扩展。思想如下：\n\n * converter 类型转换接口，通过实现这个接口，重写convert方法，以实现不同类型的对象转换\n * converterregistry 类型转换登记中心。将各种类型convert对象放入登记中心，通过convert方法查找目标类型对应的转换器，将被转换对象转换之。在此类中，存放着默认转换器和自定义转换器，默认转换器是hutool中预定义的一些转换器，自定义转换器存放用户自定的转换器。\n\n通过这种方式，实现类灵活的类型转换。使用方式如下：\n\nint a = 3423;\nconverterregistry converterregistry = converterregistry.getinstance();\nstring result = converterregistry.convert(string.class, a);\nassert.assertequals("3423", result);\n\n\n\n# 自定义转换\n\nhutool的默认转换有时候并不能满足我们自定义对象的一些需求，这时我们可以使用converterregistry.getinstance().putcustom()方法自定义类型转换。\n\n 1. 自定义转换器\n\npublic static class customconverter implements converter<string>{\n\t@override\n\tpublic string convert(object value, string defaultvalue) throws illegalargumentexception {\n\t\treturn "custom: " + value.tostring();\n\t}\n}\n\n\n 2. 注册转换器\n\nconverterregistry converterregistry = converterregistry.getinstance();\n//此处做为示例自定义string转换，因为hutool中已经提供string转换，请尽量不要替换\n//替换可能引发关联转换异常（例如覆盖string转换会影响全局）\nconverterregistry.putcustom(string.class, customconverter.class);\n\n\n 3. 执行转换\n\nint a = 454553;\nstring result = converterregistry.convert(string.class, a);\nassert.assertequals("custom: 454553", result);\n\n\n> 注意： convert(class type, object value, t defaultvalue, boolean iscustomfirst)方法的最后一个参数可以选择转换时优先使用自定义转换器还是默认转换器。convert(class type, object value, t defaultvalue)和convert(class type, object value)两个重载方法都是使用自定义转换器优先的模式。\n\n\n# converterregistry单例和对象模式\n\nconverterregistry提供一个静态方法getinstance()返回全局单例对象，这也是推荐的使用方式，当然如果想在某个限定范围内自定义转换，可以实例化converterregistry对象。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Date/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/03.%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/02.核心（Hutool-core）/03.日期时间/01.概述.md",key:"v-4e830bce",path:"/pages/Date/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"日期时间工具",slug:"日期时间工具",normalizedTitle:"日期时间工具",charIndex:64},{level:2,title:"日期枚举",slug:"日期枚举",normalizedTitle:"日期枚举",charIndex:488},{level:3,title:"月份枚举",slug:"月份枚举",normalizedTitle:"月份枚举",charIndex:792},{level:2,title:"时间枚举",slug:"时间枚举",normalizedTitle:"时间枚举",charIndex:970}],headersStr:"介绍 日期时间工具 日期枚举 月份枚举 时间枚举",content:"# 介绍\n\n日期时间包是Hutool的核心包之一，提供针对JDK中Date和Calendar对象的封装，封装对象如下：\n\n\n# 日期时间工具\n\n * DateUtil 针对日期时间操作提供一系列静态方法\n * DateTime 提供类似于Joda-Time中日期时间对象的封装，继承自Date类，并提供更加丰富的对象方法。\n * FastDateFormat 提供线程安全的针对Date对象的格式化和日期字符串解析支持。此对象在实际使用中并不需要感知，相关操作已经封装在DateUtil和DateTime的相关方法中。\n * DateBetween 计算两个时间间隔的类，除了通过构造新对象使用外，相关操作也已封装在DateUtil和DateTime的相关方法中。\n * TimeInterval 一个简单的计时器类，常用于计算某段代码的执行时间，提供包括毫秒、秒、分、时、天、周等各种单位的花费时长计算，对象的静态构造已封装在DateUtil中。\n * DatePattern 提供常用的日期格式化模式，包括String类型和FastDateFormat两种类型。\n\n\n# 日期枚举\n\n考虑到Calendar类中表示时间的字段（field）都是使用int表示，在使用中非常不便，因此针对这些int字段，封装了与之对应的Enum枚举类，这些枚举类在DateUtil和DateTime相关方法中做为参数使用，可以更大限度的缩小参数限定范围。\n\n这些定义的枚举值可以通过getValue()方法获得其与Calendar类对应的int值，通过of(int)方法从Calendar中int值转为枚举对象。\n\n与Calendar对应的这些枚举包括：\n\n * Month 表示月份，与Calendar中的int值一一对应。\n * Week 表示周，与Calendar中的int值一一对应\n\n\n# 月份枚举\n\n通过月份枚举可以获得某个月的最后一天\n\n// 31\nint lastDay = Month.of(Calendar.JANUARY).getLastDay(false);\n\n\n另外，Hutool还定义了季度枚举。Season.SPRING为第一季度，表示1~3月。季度的概念并不等同于季节，因为季节与月份并不对应，季度常用于统计概念。\n\n\n# 时间枚举\n\n时间枚举DateUnit主要表示某个时间单位对应的毫秒数，常用于计算时间差。\n\n例如：DateUnit.MINUTE表示分，也表示一分钟的毫秒数，可以通过调用其getMillis()方法获得其毫秒数。",normalizedContent:"# 介绍\n\n日期时间包是hutool的核心包之一，提供针对jdk中date和calendar对象的封装，封装对象如下：\n\n\n# 日期时间工具\n\n * dateutil 针对日期时间操作提供一系列静态方法\n * datetime 提供类似于joda-time中日期时间对象的封装，继承自date类，并提供更加丰富的对象方法。\n * fastdateformat 提供线程安全的针对date对象的格式化和日期字符串解析支持。此对象在实际使用中并不需要感知，相关操作已经封装在dateutil和datetime的相关方法中。\n * datebetween 计算两个时间间隔的类，除了通过构造新对象使用外，相关操作也已封装在dateutil和datetime的相关方法中。\n * timeinterval 一个简单的计时器类，常用于计算某段代码的执行时间，提供包括毫秒、秒、分、时、天、周等各种单位的花费时长计算，对象的静态构造已封装在dateutil中。\n * datepattern 提供常用的日期格式化模式，包括string类型和fastdateformat两种类型。\n\n\n# 日期枚举\n\n考虑到calendar类中表示时间的字段（field）都是使用int表示，在使用中非常不便，因此针对这些int字段，封装了与之对应的enum枚举类，这些枚举类在dateutil和datetime相关方法中做为参数使用，可以更大限度的缩小参数限定范围。\n\n这些定义的枚举值可以通过getvalue()方法获得其与calendar类对应的int值，通过of(int)方法从calendar中int值转为枚举对象。\n\n与calendar对应的这些枚举包括：\n\n * month 表示月份，与calendar中的int值一一对应。\n * week 表示周，与calendar中的int值一一对应\n\n\n# 月份枚举\n\n通过月份枚举可以获得某个月的最后一天\n\n// 31\nint lastday = month.of(calendar.january).getlastday(false);\n\n\n另外，hutool还定义了季度枚举。season.spring为第一季度，表示1~3月。季度的概念并不等同于季节，因为季节与月份并不对应，季度常用于统计概念。\n\n\n# 时间枚举\n\n时间枚举dateunit主要表示某个时间单位对应的毫秒数，常用于计算时间差。\n\n例如：dateunit.minute表示分，也表示一分钟的毫秒数，可以通过调用其getmillis()方法获得其毫秒数。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"日期时间工具-DateUtil",frontmatter:{title:"日期时间工具-DateUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/DateUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/03.%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/02.%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7-DateUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/03.日期时间/02.日期时间工具-DateUtil.md",key:"v-ae8b4f00",path:"/pages/DateUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:50},{level:3,title:"转换",slug:"转换",normalizedTitle:"转换",charIndex:90},{level:4,title:"Date、long、Calendar之间的相互转换",slug:"date、long、calendar之间的相互转换",normalizedTitle:"date、long、calendar之间的相互转换",charIndex:283},{level:4,title:"字符串转日期",slug:"字符串转日期",normalizedTitle:"字符串转日期",charIndex:590},{level:3,title:"格式化日期输出",slug:"格式化日期输出",normalizedTitle:"格式化日期输出",charIndex:1246},{level:3,title:"获取Date对象的某个部分",slug:"获取date对象的某个部分",normalizedTitle:"获取date对象的某个部分",charIndex:1614},{level:3,title:"开始和结束时间",slug:"开始和结束时间",normalizedTitle:"开始和结束时间",charIndex:1772},{level:3,title:"日期时间偏移",slug:"日期时间偏移",normalizedTitle:"日期时间偏移",charIndex:2068},{level:3,title:"日期时间差",slug:"日期时间差",normalizedTitle:"日期时间差",charIndex:2659},{level:3,title:"格式化时间差",slug:"格式化时间差",normalizedTitle:"格式化时间差",charIndex:2969},{level:3,title:"星座和属相",slug:"星座和属相",normalizedTitle:"星座和属相",charIndex:3176},{level:3,title:"日期范围",slug:"日期范围",normalizedTitle:"日期范围",charIndex:3327},{level:3,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:4213}],headersStr:"由来 方法 转换 Date、long、Calendar之间的相互转换 字符串转日期 格式化日期输出 获取Date对象的某个部分 开始和结束时间 日期时间偏移 日期时间差 格式化时间差 星座和属相 日期范围 其它",content:'# 由来\n\n考虑到Java本身对日期时间的支持有限，并且Date和Calendar对象的并存导致各种方法使用混乱和复杂，故使用此工具类做了封装。这其中的封装主要是日期和字符串之间的转换，以及提供对日期的定位（一个月前等等）。\n\n对于Date对象，为了便捷，使用了一个DateTime类来代替之，继承自Date对象，主要的便利在于，覆盖了toString()方法，返回yyyy-MM-dd HH:mm:ss形式的字符串，方便在输出时的调用（例如日志记录等），提供了众多便捷的方法对日期对象操作，关于DateTime会在相关章节介绍。\n\n\n# 方法\n\n\n# 转换\n\n# Date、long、Calendar之间的相互转换\n\n//当前时间\nDate date = DateUtil.date();\n//当前时间\nDate date2 = DateUtil.date(Calendar.getInstance());\n//当前时间\nDate date3 = DateUtil.date(System.currentTimeMillis());\n//当前时间字符串，格式：yyyy-MM-dd HH:mm:ss\nString now = DateUtil.now();\n//当前日期字符串，格式：yyyy-MM-dd\nString today= DateUtil.today();\n\n\n# 字符串转日期\n\nDateUtil.parse方法会自动识别一些常用格式，包括：\n\n * yyyy-MM-dd HH:mm:ss\n * yyyy/MM/dd HH:mm:ss\n * yyyy.MM.dd HH:mm:ss\n * yyyy年MM月dd日 HH时mm分ss秒\n * yyyy-MM-dd\n * yyyy/MM/dd\n * yyyy.MM.dd\n * HH:mm:ss\n * HH时mm分ss秒\n * yyyy-MM-dd HH:mm\n * yyyy-MM-dd HH:mm:ss.SSS\n * yyyyMMddHHmmss\n * yyyyMMddHHmmssSSS\n * yyyyMMdd\n * EEE, dd MMM yyyy HH:mm:ss z\n * EEE MMM dd HH:mm:ss zzz yyyy\n * yyyy-MM-dd\'T\'HH:mm:ss\'Z\'\n * yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'\n * yyyy-MM-dd\'T\'HH:mm:ssZ\n * yyyy-MM-dd\'T\'HH:mm:ss.SSSZ\n\nString dateStr = "2017-03-01";\nDate date = DateUtil.parse(dateStr);\n\n\n我们也可以使用自定义日期格式转化：\n\nString dateStr = "2017-03-01";\nDate date = DateUtil.parse(dateStr, "yyyy-MM-dd");\n\n\n\n# 格式化日期输出\n\nString dateStr = "2017-03-01";\nDate date = DateUtil.parse(dateStr);\n\n//结果 2017/03/01\nString format = DateUtil.format(date, "yyyy/MM/dd");\n\n//常用格式的格式化，结果：2017-03-01\nString formatDate = DateUtil.formatDate(date);\n\n//结果：2017-03-01 00:00:00\nString formatDateTime = DateUtil.formatDateTime(date);\n\n//结果：00:00:00\nString formatTime = DateUtil.formatTime(date);\n\n\n\n# 获取Date对象的某个部分\n\nDate date = DateUtil.date();\n//获得年的部分\nDateUtil.year(date);\n//获得月份，从0开始计数\nDateUtil.month(date);\n//获得月份枚举\nDateUtil.monthEnum(date);\n//.....\n\n\n\n# 开始和结束时间\n\n有的时候我们需要获得每天的开始时间、结束时间，每月的开始和结束时间等等，DateUtil也提供了相关方法：\n\nString dateStr = "2017-03-01 22:33:23";\nDate date = DateUtil.parse(dateStr);\n\n//一天的开始，结果：2017-03-01 00:00:00\nDate beginOfDay = DateUtil.beginOfDay(date);\n\n//一天的结束，结果：2017-03-01 23:59:59\nDate endOfDay = DateUtil.endOfDay(date);\n\n\n\n# 日期时间偏移\n\n日期或时间的偏移指针对某个日期增加或减少分、小时、天等等，达到日期变更的目的。Hutool也针对其做了大量封装\n\nString dateStr = "2017-03-01 22:33:23";\nDate date = DateUtil.parse(dateStr);\n\n//结果：2017-03-03 22:33:23\nDate newDate = DateUtil.offset(date, DateField.DAY_OF_MONTH, 2);\n\n//常用偏移，结果：2017-03-04 22:33:23\nDateTime newDate2 = DateUtil.offsetDay(date, 3);\n\n//常用偏移，结果：2017-03-01 19:33:23\nDateTime newDate3 = DateUtil.offsetHour(date, -3);\n\n\n针对当前时间，提供了简化的偏移方法（例如昨天、上周、上个月等）：\n\n//昨天\nDateUtil.yesterday()\n//明天\nDateUtil.tomorrow()\n//上周\nDateUtil.lastWeek()\n//下周\nDateUtil.nextWeek()\n//上个月\nDateUtil.lastMonth()\n//下个月\nDateUtil.nextMonth()\n\n\n\n# 日期时间差\n\n有时候我们需要计算两个日期之间的时间差（相差天数、相差小时数等等），Hutool将此类方法封装为between方法：\n\nString dateStr1 = "2017-03-01 22:33:23";\nDate date1 = DateUtil.parse(dateStr1);\n\nString dateStr2 = "2017-04-01 23:33:23";\nDate date2 = DateUtil.parse(dateStr2);\n\n//相差一个月，31天\nlong betweenDay = DateUtil.between(date1, date2, DateUnit.DAY);\n\n\n\n# 格式化时间差\n\n有时候我们希望看到易读的时间差，比如XX天XX小时XX分XX秒，此时使用DateUtil.formatBetween方法：\n\n//Level.MINUTE表示精确到分\nString formatBetween = DateUtil.formatBetween(between, Level.MINUTE);\n//输出：31天1小时\nConsole.log(formatBetween);\n\n\n\n# 星座和属相\n\n// "摩羯座"\nString zodiac = DateUtil.getZodiac(Month.JANUARY.getValue(), 19);\n\n// "狗"\nString chineseZodiac = DateUtil.getChineseZodiac(1994);\n\n\n\n# 日期范围\n\n// 创建日期范围生成器\nDateTime start = DateUtil.parse("2021-01-31");\nDateTime end = DateUtil.parse("2021-03-31");\nDateRange range = DateUtil.range(start, end, DateField.MONTH);\n\n// 简单使用\n// 开始时间\nDateRange startRange = DateUtil.range(DateUtil.parse("2017-01-01"), DateUtil.parse("2017-01-31"), DateField.DAY_OF_YEAR);\n// 结束时间\nDateRange endRange = DateUtil.range(DateUtil.parse("2017-01-31"), DateUtil.parse("2017-02-02"), DateField.DAY_OF_YEAR);\n// 交集 返回 [2017-01-31 00:00:00]\nList<DateTime> dateTimes = DateUtil.rangeContains(startRange, endRange);\n// 差集 返回 [2017-02-01 00:00:00, 2017-02-02 00:00:00]\nList<DateTime> dateNotTimes = DateUtil.rangeNotContains(startRange,endRange);\n// 区间 返回[2017-01-01 00:00:00, 2017-01-02 00:00:00, 2017-01-03 00:00:00]\nList<DateTime> rangeToList = DateUtil.rangeToList(DateUtil.parse("2017-01-01"), DateUtil.parse("2017-01-03"), DateField.DAY_OF_YEAR);\n\n\n\n# 其它\n\n//年龄\nDateUtil.ageOfNow("1990-01-30");\n\n//是否闰年\nDateUtil.isLeapYear(2017);\n',normalizedContent:'# 由来\n\n考虑到java本身对日期时间的支持有限，并且date和calendar对象的并存导致各种方法使用混乱和复杂，故使用此工具类做了封装。这其中的封装主要是日期和字符串之间的转换，以及提供对日期的定位（一个月前等等）。\n\n对于date对象，为了便捷，使用了一个datetime类来代替之，继承自date对象，主要的便利在于，覆盖了tostring()方法，返回yyyy-mm-dd hh:mm:ss形式的字符串，方便在输出时的调用（例如日志记录等），提供了众多便捷的方法对日期对象操作，关于datetime会在相关章节介绍。\n\n\n# 方法\n\n\n# 转换\n\n# date、long、calendar之间的相互转换\n\n//当前时间\ndate date = dateutil.date();\n//当前时间\ndate date2 = dateutil.date(calendar.getinstance());\n//当前时间\ndate date3 = dateutil.date(system.currenttimemillis());\n//当前时间字符串，格式：yyyy-mm-dd hh:mm:ss\nstring now = dateutil.now();\n//当前日期字符串，格式：yyyy-mm-dd\nstring today= dateutil.today();\n\n\n# 字符串转日期\n\ndateutil.parse方法会自动识别一些常用格式，包括：\n\n * yyyy-mm-dd hh:mm:ss\n * yyyy/mm/dd hh:mm:ss\n * yyyy.mm.dd hh:mm:ss\n * yyyy年mm月dd日 hh时mm分ss秒\n * yyyy-mm-dd\n * yyyy/mm/dd\n * yyyy.mm.dd\n * hh:mm:ss\n * hh时mm分ss秒\n * yyyy-mm-dd hh:mm\n * yyyy-mm-dd hh:mm:ss.sss\n * yyyymmddhhmmss\n * yyyymmddhhmmsssss\n * yyyymmdd\n * eee, dd mmm yyyy hh:mm:ss z\n * eee mmm dd hh:mm:ss zzz yyyy\n * yyyy-mm-dd\'t\'hh:mm:ss\'z\'\n * yyyy-mm-dd\'t\'hh:mm:ss.sss\'z\'\n * yyyy-mm-dd\'t\'hh:mm:ssz\n * yyyy-mm-dd\'t\'hh:mm:ss.sssz\n\nstring datestr = "2017-03-01";\ndate date = dateutil.parse(datestr);\n\n\n我们也可以使用自定义日期格式转化：\n\nstring datestr = "2017-03-01";\ndate date = dateutil.parse(datestr, "yyyy-mm-dd");\n\n\n\n# 格式化日期输出\n\nstring datestr = "2017-03-01";\ndate date = dateutil.parse(datestr);\n\n//结果 2017/03/01\nstring format = dateutil.format(date, "yyyy/mm/dd");\n\n//常用格式的格式化，结果：2017-03-01\nstring formatdate = dateutil.formatdate(date);\n\n//结果：2017-03-01 00:00:00\nstring formatdatetime = dateutil.formatdatetime(date);\n\n//结果：00:00:00\nstring formattime = dateutil.formattime(date);\n\n\n\n# 获取date对象的某个部分\n\ndate date = dateutil.date();\n//获得年的部分\ndateutil.year(date);\n//获得月份，从0开始计数\ndateutil.month(date);\n//获得月份枚举\ndateutil.monthenum(date);\n//.....\n\n\n\n# 开始和结束时间\n\n有的时候我们需要获得每天的开始时间、结束时间，每月的开始和结束时间等等，dateutil也提供了相关方法：\n\nstring datestr = "2017-03-01 22:33:23";\ndate date = dateutil.parse(datestr);\n\n//一天的开始，结果：2017-03-01 00:00:00\ndate beginofday = dateutil.beginofday(date);\n\n//一天的结束，结果：2017-03-01 23:59:59\ndate endofday = dateutil.endofday(date);\n\n\n\n# 日期时间偏移\n\n日期或时间的偏移指针对某个日期增加或减少分、小时、天等等，达到日期变更的目的。hutool也针对其做了大量封装\n\nstring datestr = "2017-03-01 22:33:23";\ndate date = dateutil.parse(datestr);\n\n//结果：2017-03-03 22:33:23\ndate newdate = dateutil.offset(date, datefield.day_of_month, 2);\n\n//常用偏移，结果：2017-03-04 22:33:23\ndatetime newdate2 = dateutil.offsetday(date, 3);\n\n//常用偏移，结果：2017-03-01 19:33:23\ndatetime newdate3 = dateutil.offsethour(date, -3);\n\n\n针对当前时间，提供了简化的偏移方法（例如昨天、上周、上个月等）：\n\n//昨天\ndateutil.yesterday()\n//明天\ndateutil.tomorrow()\n//上周\ndateutil.lastweek()\n//下周\ndateutil.nextweek()\n//上个月\ndateutil.lastmonth()\n//下个月\ndateutil.nextmonth()\n\n\n\n# 日期时间差\n\n有时候我们需要计算两个日期之间的时间差（相差天数、相差小时数等等），hutool将此类方法封装为between方法：\n\nstring datestr1 = "2017-03-01 22:33:23";\ndate date1 = dateutil.parse(datestr1);\n\nstring datestr2 = "2017-04-01 23:33:23";\ndate date2 = dateutil.parse(datestr2);\n\n//相差一个月，31天\nlong betweenday = dateutil.between(date1, date2, dateunit.day);\n\n\n\n# 格式化时间差\n\n有时候我们希望看到易读的时间差，比如xx天xx小时xx分xx秒，此时使用dateutil.formatbetween方法：\n\n//level.minute表示精确到分\nstring formatbetween = dateutil.formatbetween(between, level.minute);\n//输出：31天1小时\nconsole.log(formatbetween);\n\n\n\n# 星座和属相\n\n// "摩羯座"\nstring zodiac = dateutil.getzodiac(month.january.getvalue(), 19);\n\n// "狗"\nstring chinesezodiac = dateutil.getchinesezodiac(1994);\n\n\n\n# 日期范围\n\n// 创建日期范围生成器\ndatetime start = dateutil.parse("2021-01-31");\ndatetime end = dateutil.parse("2021-03-31");\ndaterange range = dateutil.range(start, end, datefield.month);\n\n// 简单使用\n// 开始时间\ndaterange startrange = dateutil.range(dateutil.parse("2017-01-01"), dateutil.parse("2017-01-31"), datefield.day_of_year);\n// 结束时间\ndaterange endrange = dateutil.range(dateutil.parse("2017-01-31"), dateutil.parse("2017-02-02"), datefield.day_of_year);\n// 交集 返回 [2017-01-31 00:00:00]\nlist<datetime> datetimes = dateutil.rangecontains(startrange, endrange);\n// 差集 返回 [2017-02-01 00:00:00, 2017-02-02 00:00:00]\nlist<datetime> datenottimes = dateutil.rangenotcontains(startrange,endrange);\n// 区间 返回[2017-01-01 00:00:00, 2017-01-02 00:00:00, 2017-01-03 00:00:00]\nlist<datetime> rangetolist = dateutil.rangetolist(dateutil.parse("2017-01-01"), dateutil.parse("2017-01-03"), datefield.day_of_year);\n\n\n\n# 其它\n\n//年龄\ndateutil.ageofnow("1990-01-30");\n\n//是否闰年\ndateutil.isleapyear(2017);\n',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"类型转换工具类-Convert",frontmatter:{title:"类型转换工具类-Convert",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Convert/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/02.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/01.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%E7%B1%BB-Convert.html",relativePath:"01.指南/02.核心（Hutool-core）/02.类型转换/01.类型转换工具类-Convert.md",key:"v-106de6f7",path:"/pages/Convert/",headers:[{level:2,title:"痛点",slug:"痛点",normalizedTitle:"痛点",charIndex:2},{level:2,title:"Convert类",slug:"convert类",normalizedTitle:"convert类",charIndex:189},{level:3,title:"Java常见类型转换",slug:"java常见类型转换",normalizedTitle:"java常见类型转换",charIndex:340},{level:3,title:"其它类型转换",slug:"其它类型转换",normalizedTitle:"其它类型转换",charIndex:927},{level:3,title:"半角和全角转换",slug:"半角和全角转换",normalizedTitle:"半角和全角转换",charIndex:1449},{level:3,title:"16进制（Hex）",slug:"_16进制-hex",normalizedTitle:"16进制（hex）",charIndex:1665},{level:3,title:"Unicode和字符串转换",slug:"unicode和字符串转换",normalizedTitle:"unicode和字符串转换",charIndex:2402},{level:3,title:"编码转换",slug:"编码转换",normalizedTitle:"编码转换",charIndex:2744},{level:3,title:"时间单位转换",slug:"时间单位转换",normalizedTitle:"时间单位转换",charIndex:3139},{level:3,title:"金额大小写转换",slug:"金额大小写转换",normalizedTitle:"金额大小写转换",charIndex:3319},{level:3,title:"数字转换",slug:"数字转换",normalizedTitle:"数字转换",charIndex:3511},{level:3,title:"原始类和包装类转换",slug:"原始类和包装类转换",normalizedTitle:"原始类和包装类转换",charIndex:3947}],headersStr:"痛点 Convert类 Java常见类型转换 其它类型转换 半角和全角转换 16进制（Hex） Unicode和字符串转换 编码转换 时间单位转换 金额大小写转换 数字转换 原始类和包装类转换",content:'# 痛点\n\n在Java开发中我们要面对各种各样的类型转换问题，尤其是从命令行获取的用户参数、从HttpRequest获取的Parameter等等，这些参数类型多种多样，我们怎么去转换他们呢？常用的办法是先整成String，然后调用XXX.parseXXX方法，还要承受转换失败的风险，不得不加一层try catch，这个小小的过程混迹在业务代码中会显得非常难看和臃肿。\n\n\n# Convert类\n\nConvert类可以说是一个工具方法类，里面封装了针对Java常见类型的转换，用于简化类型转换。Convert类中大部分方法为toXXX，参数为Object，可以实现将任意可能的类型转换为指定类型。同时支持第二个参数defaultValue用于在转换失败时返回一个默认值。\n\n\n# Java常见类型转换\n\n 1. 转换为字符串：\n\nint a = 1;\n//aStr为"1"\nString aStr = Convert.toStr(a);\n\nlong[] b = {1,2,3,4,5};\n//bStr为："[1, 2, 3, 4, 5]"\nString bStr = Convert.toStr(b);\n\n\n 2. 转换为指定类型数组：\n\nString[] b = { "1", "2", "3", "4" };\n//结果为Integer数组\nInteger[] intArray = Convert.toIntArray(b);\n\nlong[] c = {1,2,3,4,5};\n//结果为Integer数组\nInteger[] intArray2 = Convert.toIntArray(c);\n\n\n 3. 转换为日期对象：\n\nString a = "2017-05-06";\nDate value = Convert.toDate(a);\n\n\n 4. 转换为集合\n\nObject[] a = {"a", "你", "好", "", 1};\nList<?> list = Convert.convert(List.class, a);\n//从4.1.11开始可以这么用\nList<?> list = Convert.toList(a);\n\n\n\n# 其它类型转换\n\n 1. 标准类型\n\n通过Convert.convert(Class<T>, Object)方法可以将任意类型转换为指定类型，Hutool中预定义了许多类型转换，例如转换为URI、URL、Calendar等等，这些类型的转换都依托于ConverterRegistry类。通过这个类和Converter接口，我们可以自定义一些类型转换。详细的使用请参阅“自定义类型转换”一节。\n\n 2. 泛型类型\n\n通过convert(TypeReference<T> reference, Object value)方法，自行new一个TypeReference对象可以对嵌套泛型进行类型转换。例如，我们想转换一个对象为List<String>类型，此时传入的标准Class就无法满足要求，此时我们可以这样：\n\nObject[] a = { "a", "你", "好", "", 1 };\nList<String> list = Convert.convert(new TypeReference<List<String>>() {}, a);\n\n\n通过TypeReference实例化后制定泛型类型，即可转换对象为我们想要的目标类型。\n\n\n# 半角和全角转换\n\n在很多文本的统一化中这两个方法非常有用，主要对标点符号的全角半角转换。\n\n半角转全角：\n\nString a = "123456789";\n\n//结果为："１２３４５６７８９"\nString sbc = Convert.toSBC(a);\n\n\n全角转半角：\n\nString a = "１２３４５６７８９";\n\n//结果为"123456789"\nString dbc = Convert.toDBC(a);\n\n\n\n# 16进制（Hex）\n\n在很多加密解密，以及中文字符串传输（比如表单提交）的时候，会用到16进制转换，就是Hex转换，为此Hutool中专门封装了HexUtil工具类，考虑到16进制转换也是转换的一部分，因此将其方法也放在Convert类中，便于理解和查找，使用同样非常简单：\n\n转为16进制（Hex）字符串\n\nString a = "我是一个小小的可爱的字符串";\n\n//结果："e68891e698afe4b880e4b8aae5b08fe5b08fe79a84e58fafe788b1e79a84e5ad97e7aca6e4b8b2"\nString hex = Convert.toHex(a, CharsetUtil.CHARSET_UTF_8);\n\n\n将16进制（Hex）字符串转为普通字符串:\n\nString hex = "e68891e698afe4b880e4b8aae5b08fe5b08fe79a84e58fafe788b1e79a84e5ad97e7aca6e4b8b2";\n\n//结果为："我是一个小小的可爱的字符串"\nString raw = Convert.hexStrToStr(hex, CharsetUtil.CHARSET_UTF_8);\n\n//注意：在4.1.11之后hexStrToStr将改名为hexToStr\nString raw = Convert.hexToStr(hex, CharsetUtil.CHARSET_UTF_8);\n\n\n> 因为字符串牵涉到编码问题，因此必须传入编码对象，此处使用UTF-8编码。 toHex方法同样支持传入byte[]，同样也可以使用hexToBytes方法将16进制转为byte[]\n\n\n# Unicode和字符串转换\n\n与16进制类似，Convert类同样可以在字符串和Unicode之间轻松转换：\n\nString a = "我是一个小小的可爱的字符串";\n\n//结果为："\\\\u6211\\\\u662f\\\\u4e00\\\\u4e2a\\\\u5c0f\\\\u5c0f\\\\u7684\\\\u53ef\\\\u7231\\\\u7684\\\\u5b57\\\\u7b26\\\\u4e32"\t\nString unicode = Convert.strToUnicode(a);\n\n//结果为："我是一个小小的可爱的字符串"\nString raw = Convert.unicodeToStr(unicode);\n\n\n很熟悉吧？如果你在properties文件中写过中文，你会明白这个方法的重要性。\n\n\n# 编码转换\n\n在接收表单的时候，我们常常被中文乱码所困扰，其实大多数原因是使用了不正确的编码方式解码了数据。于是Convert.convertCharset方法便派上用场了，它可以把乱码转为正确的编码方式：\n\nString a = "我不是乱码";\n//转换后result为乱码\nString result = Convert.convertCharset(a, CharsetUtil.UTF_8, CharsetUtil.ISO_8859_1);\nString raw = Convert.convertCharset(result, CharsetUtil.ISO_8859_1, "UTF-8");\nAssert.assertEquals(raw, a);\n\n\n> 注意 经过测试，UTF-8编码后用GBK解码，再用GBK编码后用UTF-8解码会存在某些中文转换失败的问题。\n\n\n# 时间单位转换\n\nConvert.convertTime方法主要用于转换时长单位，比如一个很大的毫秒，我想获得这个毫秒数对应多少分：\n\nlong a = 4535345;\n\n//结果为：75\nlong minutes = Convert.convertTime(a, TimeUnit.MILLISECONDS, TimeUnit.MINUTES);\n\n\n\n# 金额大小写转换\n\n面对财务类需求，Convert.digitToChinese将金钱数转换为大写形式：\n\ndouble a = 67556.32;\n\n//结果为："陆万柒仟伍佰伍拾陆元叁角贰分"\nString digitUppercase = Convert.digitToChinese(a);\n\n\n> 注意 转换为大写只能精确到分（小数点儿后两位），之后的数字会被忽略。\n\n\n# 数字转换\n\n 1. 数字转为英文表达\n\n// ONE HUNDRED AND CENTS TWENTY THREE ONLY\nString format = Convert.numberToWord(100.23);\n\n\n 2. 数字简化\n\n// 1.2k\nString format1 = Convert.numberToSimple(1200, false);\n\n\n 3. 数字转中文\n\n数字转中文方法中，只保留两位小数\n\n// 一万零八百八十九点七二\nString f1 = Convert.numberToChinese(10889.72356, false);\n\n// 使用金额大写\n// 壹万贰仟陆佰伍拾叁\nString f1 = Convert.numberToChinese(12653, true);\n\n\n 4. 数字中文表示转换为数字\n\n// 1012\nint f1 = Convert.chineseToNumber("一千零一十二");\n\n\n\n# 原始类和包装类转换\n\n有的时候，我们需要将包装类和原始类相互转换（比如Integer.class 和 int.class），这时候我们可以：\n\n//去包装\nClass<?> wrapClass = Integer.class;\n\n//结果为：int.class\nClass<?> unWraped = Convert.unWrap(wrapClass);\n\n//包装\nClass<?> primitiveClass = long.class;\n\n//结果为：Long.class\nClass<?> wraped = Convert.wrap(primitiveClass);\n',normalizedContent:'# 痛点\n\n在java开发中我们要面对各种各样的类型转换问题，尤其是从命令行获取的用户参数、从httprequest获取的parameter等等，这些参数类型多种多样，我们怎么去转换他们呢？常用的办法是先整成string，然后调用xxx.parsexxx方法，还要承受转换失败的风险，不得不加一层try catch，这个小小的过程混迹在业务代码中会显得非常难看和臃肿。\n\n\n# convert类\n\nconvert类可以说是一个工具方法类，里面封装了针对java常见类型的转换，用于简化类型转换。convert类中大部分方法为toxxx，参数为object，可以实现将任意可能的类型转换为指定类型。同时支持第二个参数defaultvalue用于在转换失败时返回一个默认值。\n\n\n# java常见类型转换\n\n 1. 转换为字符串：\n\nint a = 1;\n//astr为"1"\nstring astr = convert.tostr(a);\n\nlong[] b = {1,2,3,4,5};\n//bstr为："[1, 2, 3, 4, 5]"\nstring bstr = convert.tostr(b);\n\n\n 2. 转换为指定类型数组：\n\nstring[] b = { "1", "2", "3", "4" };\n//结果为integer数组\ninteger[] intarray = convert.tointarray(b);\n\nlong[] c = {1,2,3,4,5};\n//结果为integer数组\ninteger[] intarray2 = convert.tointarray(c);\n\n\n 3. 转换为日期对象：\n\nstring a = "2017-05-06";\ndate value = convert.todate(a);\n\n\n 4. 转换为集合\n\nobject[] a = {"a", "你", "好", "", 1};\nlist<?> list = convert.convert(list.class, a);\n//从4.1.11开始可以这么用\nlist<?> list = convert.tolist(a);\n\n\n\n# 其它类型转换\n\n 1. 标准类型\n\n通过convert.convert(class<t>, object)方法可以将任意类型转换为指定类型，hutool中预定义了许多类型转换，例如转换为uri、url、calendar等等，这些类型的转换都依托于converterregistry类。通过这个类和converter接口，我们可以自定义一些类型转换。详细的使用请参阅“自定义类型转换”一节。\n\n 2. 泛型类型\n\n通过convert(typereference<t> reference, object value)方法，自行new一个typereference对象可以对嵌套泛型进行类型转换。例如，我们想转换一个对象为list<string>类型，此时传入的标准class就无法满足要求，此时我们可以这样：\n\nobject[] a = { "a", "你", "好", "", 1 };\nlist<string> list = convert.convert(new typereference<list<string>>() {}, a);\n\n\n通过typereference实例化后制定泛型类型，即可转换对象为我们想要的目标类型。\n\n\n# 半角和全角转换\n\n在很多文本的统一化中这两个方法非常有用，主要对标点符号的全角半角转换。\n\n半角转全角：\n\nstring a = "123456789";\n\n//结果为："１２３４５６７８９"\nstring sbc = convert.tosbc(a);\n\n\n全角转半角：\n\nstring a = "１２３４５６７８９";\n\n//结果为"123456789"\nstring dbc = convert.todbc(a);\n\n\n\n# 16进制（hex）\n\n在很多加密解密，以及中文字符串传输（比如表单提交）的时候，会用到16进制转换，就是hex转换，为此hutool中专门封装了hexutil工具类，考虑到16进制转换也是转换的一部分，因此将其方法也放在convert类中，便于理解和查找，使用同样非常简单：\n\n转为16进制（hex）字符串\n\nstring a = "我是一个小小的可爱的字符串";\n\n//结果："e68891e698afe4b880e4b8aae5b08fe5b08fe79a84e58fafe788b1e79a84e5ad97e7aca6e4b8b2"\nstring hex = convert.tohex(a, charsetutil.charset_utf_8);\n\n\n将16进制（hex）字符串转为普通字符串:\n\nstring hex = "e68891e698afe4b880e4b8aae5b08fe5b08fe79a84e58fafe788b1e79a84e5ad97e7aca6e4b8b2";\n\n//结果为："我是一个小小的可爱的字符串"\nstring raw = convert.hexstrtostr(hex, charsetutil.charset_utf_8);\n\n//注意：在4.1.11之后hexstrtostr将改名为hextostr\nstring raw = convert.hextostr(hex, charsetutil.charset_utf_8);\n\n\n> 因为字符串牵涉到编码问题，因此必须传入编码对象，此处使用utf-8编码。 tohex方法同样支持传入byte[]，同样也可以使用hextobytes方法将16进制转为byte[]\n\n\n# unicode和字符串转换\n\n与16进制类似，convert类同样可以在字符串和unicode之间轻松转换：\n\nstring a = "我是一个小小的可爱的字符串";\n\n//结果为："\\\\u6211\\\\u662f\\\\u4e00\\\\u4e2a\\\\u5c0f\\\\u5c0f\\\\u7684\\\\u53ef\\\\u7231\\\\u7684\\\\u5b57\\\\u7b26\\\\u4e32"\t\nstring unicode = convert.strtounicode(a);\n\n//结果为："我是一个小小的可爱的字符串"\nstring raw = convert.unicodetostr(unicode);\n\n\n很熟悉吧？如果你在properties文件中写过中文，你会明白这个方法的重要性。\n\n\n# 编码转换\n\n在接收表单的时候，我们常常被中文乱码所困扰，其实大多数原因是使用了不正确的编码方式解码了数据。于是convert.convertcharset方法便派上用场了，它可以把乱码转为正确的编码方式：\n\nstring a = "我不是乱码";\n//转换后result为乱码\nstring result = convert.convertcharset(a, charsetutil.utf_8, charsetutil.iso_8859_1);\nstring raw = convert.convertcharset(result, charsetutil.iso_8859_1, "utf-8");\nassert.assertequals(raw, a);\n\n\n> 注意 经过测试，utf-8编码后用gbk解码，再用gbk编码后用utf-8解码会存在某些中文转换失败的问题。\n\n\n# 时间单位转换\n\nconvert.converttime方法主要用于转换时长单位，比如一个很大的毫秒，我想获得这个毫秒数对应多少分：\n\nlong a = 4535345;\n\n//结果为：75\nlong minutes = convert.converttime(a, timeunit.milliseconds, timeunit.minutes);\n\n\n\n# 金额大小写转换\n\n面对财务类需求，convert.digittochinese将金钱数转换为大写形式：\n\ndouble a = 67556.32;\n\n//结果为："陆万柒仟伍佰伍拾陆元叁角贰分"\nstring digituppercase = convert.digittochinese(a);\n\n\n> 注意 转换为大写只能精确到分（小数点儿后两位），之后的数字会被忽略。\n\n\n# 数字转换\n\n 1. 数字转为英文表达\n\n// one hundred and cents twenty three only\nstring format = convert.numbertoword(100.23);\n\n\n 2. 数字简化\n\n// 1.2k\nstring format1 = convert.numbertosimple(1200, false);\n\n\n 3. 数字转中文\n\n数字转中文方法中，只保留两位小数\n\n// 一万零八百八十九点七二\nstring f1 = convert.numbertochinese(10889.72356, false);\n\n// 使用金额大写\n// 壹万贰仟陆佰伍拾叁\nstring f1 = convert.numbertochinese(12653, true);\n\n\n 4. 数字中文表示转换为数字\n\n// 1012\nint f1 = convert.chinesetonumber("一千零一十二");\n\n\n\n# 原始类和包装类转换\n\n有的时候，我们需要将包装类和原始类相互转换（比如integer.class 和 int.class），这时候我们可以：\n\n//去包装\nclass<?> wrapclass = integer.class;\n\n//结果为：int.class\nclass<?> unwraped = convert.unwrap(wrapclass);\n\n//包装\nclass<?> primitiveclass = long.class;\n\n//结果为：long.class\nclass<?> wraped = convert.wrap(primitiveclass);\n',charsets:{cjk:!0},lastUpdated:"2024/06/18, 19:10:34",lastUpdatedTimestamp:1718709034e3},{title:"日期时间对象-DateTime",frontmatter:{title:"日期时间对象-DateTime",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/DateTime/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/03.%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/03.%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%AF%B9%E8%B1%A1-DateTime.html",relativePath:"01.指南/02.核心（Hutool-core）/03.日期时间/03.日期时间对象-DateTime.md",key:"v-cf3375fa",path:"/pages/DateTime/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:22},{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:151},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:42},{level:3,title:"新建对象",slug:"新建对象",normalizedTitle:"新建对象",charIndex:268},{level:3,title:"使用对象",slug:"使用对象",normalizedTitle:"使用对象",charIndex:580},{level:3,title:"对象的可变性",slug:"对象的可变性",normalizedTitle:"对象的可变性",charIndex:990},{level:3,title:"格式化为字符串",slug:"格式化为字符串",normalizedTitle:"格式化为字符串",charIndex:1481}],headersStr:"由来 说明 使用 新建对象 使用对象 对象的可变性 格式化为字符串",content:'# 日期时间对象-DateTime\n\n\n# 由来\n\n考虑工具类的局限性，在某些情况下使用并不简便，于是DateTime类诞生。DateTime对象充分吸取Joda-Time库的优点，并提供更多的便捷方法，这样我们在开发时不必再单独导入Joda-Time库便可以享受简单快速的日期时间处理过程。\n\n\n# 说明\n\nDateTime类继承于java.util.Date类，为Date类扩展了众多简便方法，这些方法多是DateUtil静态方法的对象表现形式，使用DateTime对象可以完全替代开发中Date对象的使用。\n\n\n# 使用\n\n\n# 新建对象\n\nDateTime对象包含众多的构造方法，构造方法支持的参数有：\n\n * Date\n * Calendar\n * String(日期字符串，第二个参数是日期格式)\n * long 毫秒数\n\n构建对象有两种方式：DateTime.of()和new DateTime()：\n\nDate date = new Date();\n\t\t\n//new方式创建\nDateTime time = new DateTime(date);\nConsole.log(time);\n\n//of方式创建\nDateTime dt = DateTime.of(date);\nDateTime now = DateTime.now();\n\n\n\n# 使用对象\n\nDateTime的成员方法与DateUtil中的静态方法所对应，因为是成员方法，因此可以使用更少的参数操作日期时间。\n\n示例：获取日期成员（年、月、日等）\n\nDateTime dateTime = new DateTime("2017-01-05 12:34:23", DatePattern.NORM_DATETIME_FORMAT);\n\t\t\n//年，结果：2017\nint year = dateTime.year();\n\n//季度（非季节），结果：Season.SPRING\nSeason season = dateTime.seasonEnum();\n\n//月份，结果：Month.JANUARY\nMonth month = dateTime.monthEnum();\n\n//日，结果：5\nint day = dateTime.dayOfMonth();\n\n\n更多成员方法请参阅API文档。\n\n\n# 对象的可变性\n\nDateTime对象默认是可变对象（调用offset、setField、setTime方法默认变更自身），但是这种可变性有时候会引起很多问题（例如多个地方共用DateTime对象）。我们可以调用setMutable(false)方法使其变为不可变对象。在不可变模式下，offset、setField方法返回一个新对象，setTime方法抛出异常。\n\nDateTime dateTime = new DateTime("2017-01-05 12:34:23", DatePattern.NORM_DATETIME_FORMAT);\n\n//默认情况下DateTime为可变对象，此时offset == dateTime\nDateTime offset = dateTime.offset(DateField.YEAR, 0);\n\n//设置为不可变对象后变动将返回新对象，此时offset != dateTime\ndateTime.setMutable(false);\noffset = dateTime.offset(DateField.YEAR, 0);\n\n\n\n# 格式化为字符串\n\n调用toString()方法即可返回格式为yyyy-MM-dd HH:mm:ss的字符串，调用toString(String format)可以返回指定格式的字符串。\n\nDateTime dateTime = new DateTime("2017-01-05 12:34:23", DatePattern.NORM_DATETIME_FORMAT);\n//结果：2017-01-05 12:34:23\nString dateStr = dateTime.toString();\n\n//结果：2017/01/05\nString dateStr = dateTime.toString("yyyy/MM/dd");\n',normalizedContent:'# 日期时间对象-datetime\n\n\n# 由来\n\n考虑工具类的局限性，在某些情况下使用并不简便，于是datetime类诞生。datetime对象充分吸取joda-time库的优点，并提供更多的便捷方法，这样我们在开发时不必再单独导入joda-time库便可以享受简单快速的日期时间处理过程。\n\n\n# 说明\n\ndatetime类继承于java.util.date类，为date类扩展了众多简便方法，这些方法多是dateutil静态方法的对象表现形式，使用datetime对象可以完全替代开发中date对象的使用。\n\n\n# 使用\n\n\n# 新建对象\n\ndatetime对象包含众多的构造方法，构造方法支持的参数有：\n\n * date\n * calendar\n * string(日期字符串，第二个参数是日期格式)\n * long 毫秒数\n\n构建对象有两种方式：datetime.of()和new datetime()：\n\ndate date = new date();\n\t\t\n//new方式创建\ndatetime time = new datetime(date);\nconsole.log(time);\n\n//of方式创建\ndatetime dt = datetime.of(date);\ndatetime now = datetime.now();\n\n\n\n# 使用对象\n\ndatetime的成员方法与dateutil中的静态方法所对应，因为是成员方法，因此可以使用更少的参数操作日期时间。\n\n示例：获取日期成员（年、月、日等）\n\ndatetime datetime = new datetime("2017-01-05 12:34:23", datepattern.norm_datetime_format);\n\t\t\n//年，结果：2017\nint year = datetime.year();\n\n//季度（非季节），结果：season.spring\nseason season = datetime.seasonenum();\n\n//月份，结果：month.january\nmonth month = datetime.monthenum();\n\n//日，结果：5\nint day = datetime.dayofmonth();\n\n\n更多成员方法请参阅api文档。\n\n\n# 对象的可变性\n\ndatetime对象默认是可变对象（调用offset、setfield、settime方法默认变更自身），但是这种可变性有时候会引起很多问题（例如多个地方共用datetime对象）。我们可以调用setmutable(false)方法使其变为不可变对象。在不可变模式下，offset、setfield方法返回一个新对象，settime方法抛出异常。\n\ndatetime datetime = new datetime("2017-01-05 12:34:23", datepattern.norm_datetime_format);\n\n//默认情况下datetime为可变对象，此时offset == datetime\ndatetime offset = datetime.offset(datefield.year, 0);\n\n//设置为不可变对象后变动将返回新对象，此时offset != datetime\ndatetime.setmutable(false);\noffset = datetime.offset(datefield.year, 0);\n\n\n\n# 格式化为字符串\n\n调用tostring()方法即可返回格式为yyyy-mm-dd hh:mm:ss的字符串，调用tostring(string format)可以返回指定格式的字符串。\n\ndatetime datetime = new datetime("2017-01-05 12:34:23", datepattern.norm_datetime_format);\n//结果：2017-01-05 12:34:23\nstring datestr = datetime.tostring();\n\n//结果：2017/01/05\nstring datestr = datetime.tostring("yyyy/mm/dd");\n',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"农历日期-ChineseDate",frontmatter:{title:"农历日期-ChineseDate",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ChineseDate/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/03.%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/04.%E5%86%9C%E5%8E%86%E6%97%A5%E6%9C%9F-ChineseDate.html",relativePath:"01.指南/02.核心（Hutool-core）/03.日期时间/04.农历日期-ChineseDate.md",key:"v-fc017312",path:"/pages/ChineseDate/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:35}],headersStr:"介绍 使用",content:'# 介绍\n\n农历日期，提供了生肖、天干地支、传统节日等方法。\n\n\n# 使用\n\n 1. 构建ChineseDate对象\n\nChineseDate表示了农历的对象，构建此对象既可以使用公历的日期，也可以使用农历的日期。\n\n//通过农历构建\nChineseDate chineseDate = new ChineseDate(1992,12,14);\n\n//通过公历构建\nChineseDate chineseDate = new ChineseDate(DateUtil.parseDate("1993-01-06"));\n\n\n 2. 基本使用\n\n//通过公历构建\nChineseDate date = new ChineseDate(DateUtil.parseDate("2020-01-25"));\n// 一月\ndate.getChineseMonth();\n// 正月\ndate.getChineseMonthName();\n// 初一\ndate.getChineseDay();\n// 庚子\ndate.getCyclical();\n// 生肖：鼠\ndate.getChineseZodiac();\n// 传统节日（部分支持，逗号分隔）：春节\ndate.getFestivals();\n// 庚子鼠年 正月初一\ndate.toString();\n\n\n 3. 获取天干地支\n\n从5.4.1开始，Hutool支持天干地支的获取：\n\n//通过公历构建\nChineseDate chineseDate = new ChineseDate(DateUtil.parseDate("2020-08-28"));\n\n// 庚子年甲申月癸卯日\nString cyclicalYMD = chineseDate.getCyclicalYMD();\n',normalizedContent:'# 介绍\n\n农历日期，提供了生肖、天干地支、传统节日等方法。\n\n\n# 使用\n\n 1. 构建chinesedate对象\n\nchinesedate表示了农历的对象，构建此对象既可以使用公历的日期，也可以使用农历的日期。\n\n//通过农历构建\nchinesedate chinesedate = new chinesedate(1992,12,14);\n\n//通过公历构建\nchinesedate chinesedate = new chinesedate(dateutil.parsedate("1993-01-06"));\n\n\n 2. 基本使用\n\n//通过公历构建\nchinesedate date = new chinesedate(dateutil.parsedate("2020-01-25"));\n// 一月\ndate.getchinesemonth();\n// 正月\ndate.getchinesemonthname();\n// 初一\ndate.getchineseday();\n// 庚子\ndate.getcyclical();\n// 生肖：鼠\ndate.getchinesezodiac();\n// 传统节日（部分支持，逗号分隔）：春节\ndate.getfestivals();\n// 庚子鼠年 正月初一\ndate.tostring();\n\n\n 3. 获取天干地支\n\n从5.4.1开始，hutool支持天干地支的获取：\n\n//通过公历构建\nchinesedate chinesedate = new chinesedate(dateutil.parsedate("2020-08-28"));\n\n// 庚子年甲申月癸卯日\nstring cyclicalymd = chinesedate.getcyclicalymd();\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"LocalDateTime工具-LocalDateTimeUtil",frontmatter:{title:"LocalDateTime工具-LocalDateTimeUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/LocalDateTimeUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/03.%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/05.LocalDateTime%E5%B7%A5%E5%85%B7-LocalDateTimeUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/03.日期时间/05.LocalDateTime工具-LocalDateTimeUtil.md",key:"v-05b64988",path:"/pages/LocalDateTimeUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:98}],headersStr:"介绍 使用",content:'# 介绍\n\n从Hutool的5.4.x开始，Hutool加入了针对JDK8+日期API的封装，此工具类的功能包括LocalDateTime和LocalDate的解析、格式化、转换等操作。\n\n\n# 使用\n\n 1. 日期转换\n\nString dateStr = "2020-01-23T12:23:56";\nDateTime dt = DateUtil.parse(dateStr);\n\n// Date对象转换为LocalDateTime\nLocalDateTime of = LocalDateTimeUtil.of(dt);\n\n// 时间戳转换为LocalDateTime\nof = LocalDateTimeUtil.ofUTC(dt.getTime());\n\n\n 2. 日期字符串解析\n\n// 解析ISO时间\nLocalDateTime localDateTime = LocalDateTimeUtil.parse("2020-01-23T12:23:56");\n\n\n// 解析自定义格式时间\nlocalDateTime = LocalDateTimeUtil.parse("2020-01-23", DatePattern.NORM_DATE_PATTERN);\n\n\n解析同样支持LocalDate：\n\nLocalDate localDate = LocalDateTimeUtil.parseDate("2020-01-23");\n\n// 解析日期时间为LocalDate，时间部分舍弃\nlocalDate = LocalDateTimeUtil.parseDate("2020-01-23T12:23:56", DateTimeFormatter.ISO_DATE_TIME);\n\n\n 3. 日期格式化\n\nLocalDateTime localDateTime = LocalDateTimeUtil.parse("2020-01-23T12:23:56");\n\n// "2020-01-23 12:23:56"\nString format = LocalDateTimeUtil.format(localDateTime, DatePattern.NORM_DATETIME_PATTERN);\n\n\n 4. 日期偏移\n\nfinal LocalDateTime localDateTime = LocalDateTimeUtil.parse("2020-01-23T12:23:56");\n\n// 增加一天\n// "2020-01-24T12:23:56"\nLocalDateTime offset = LocalDateTimeUtil.offset(localDateTime, 1, ChronoUnit.DAYS);\n\n\n如果是减少时间，offset第二个参数传负数即可：\n\n// "2020-01-22T12:23:56"\noffset = LocalDateTimeUtil.offset(localDateTime, -1, ChronoUnit.DAYS);\n\n\n 5. 计算时间间隔\n\nLocalDateTime start = LocalDateTimeUtil.parse("2019-02-02T00:00:00");\nLocalDateTime end = LocalDateTimeUtil.parse("2020-02-02T00:00:00");\n\nDuration between = LocalDateTimeUtil.between(start, end);\n\n// 365\nbetween.toDays();\n\n\n 6. 一天的开始和结束\n\nLocalDateTime localDateTime = LocalDateTimeUtil.parse("2020-01-23T12:23:56");\n\n// "2020-01-23T00:00"\nLocalDateTime beginOfDay = LocalDateTimeUtil.beginOfDay(localDateTime);\n\n// "2020-01-23T23:59:59.999999999"\nLocalDateTime endOfDay = LocalDateTimeUtil.endOfDay(localDateTime);\n',normalizedContent:'# 介绍\n\n从hutool的5.4.x开始，hutool加入了针对jdk8+日期api的封装，此工具类的功能包括localdatetime和localdate的解析、格式化、转换等操作。\n\n\n# 使用\n\n 1. 日期转换\n\nstring datestr = "2020-01-23t12:23:56";\ndatetime dt = dateutil.parse(datestr);\n\n// date对象转换为localdatetime\nlocaldatetime of = localdatetimeutil.of(dt);\n\n// 时间戳转换为localdatetime\nof = localdatetimeutil.ofutc(dt.gettime());\n\n\n 2. 日期字符串解析\n\n// 解析iso时间\nlocaldatetime localdatetime = localdatetimeutil.parse("2020-01-23t12:23:56");\n\n\n// 解析自定义格式时间\nlocaldatetime = localdatetimeutil.parse("2020-01-23", datepattern.norm_date_pattern);\n\n\n解析同样支持localdate：\n\nlocaldate localdate = localdatetimeutil.parsedate("2020-01-23");\n\n// 解析日期时间为localdate，时间部分舍弃\nlocaldate = localdatetimeutil.parsedate("2020-01-23t12:23:56", datetimeformatter.iso_date_time);\n\n\n 3. 日期格式化\n\nlocaldatetime localdatetime = localdatetimeutil.parse("2020-01-23t12:23:56");\n\n// "2020-01-23 12:23:56"\nstring format = localdatetimeutil.format(localdatetime, datepattern.norm_datetime_pattern);\n\n\n 4. 日期偏移\n\nfinal localdatetime localdatetime = localdatetimeutil.parse("2020-01-23t12:23:56");\n\n// 增加一天\n// "2020-01-24t12:23:56"\nlocaldatetime offset = localdatetimeutil.offset(localdatetime, 1, chronounit.days);\n\n\n如果是减少时间，offset第二个参数传负数即可：\n\n// "2020-01-22t12:23:56"\noffset = localdatetimeutil.offset(localdatetime, -1, chronounit.days);\n\n\n 5. 计算时间间隔\n\nlocaldatetime start = localdatetimeutil.parse("2019-02-02t00:00:00");\nlocaldatetime end = localdatetimeutil.parse("2020-02-02t00:00:00");\n\nduration between = localdatetimeutil.between(start, end);\n\n// 365\nbetween.todays();\n\n\n 6. 一天的开始和结束\n\nlocaldatetime localdatetime = localdatetimeutil.parse("2020-01-23t12:23:56");\n\n// "2020-01-23t00:00"\nlocaldatetime beginofday = localdatetimeutil.beginofday(localdatetime);\n\n// "2020-01-23t23:59:59.999999999"\nlocaldatetime endofday = localdatetimeutil.endofday(localdatetime);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/io/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/00.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/00.概述.md",key:"v-366b2c35",path:"/pages/io/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:181},{level:2,title:"流扩展",slug:"流扩展",normalizedTitle:"流扩展",charIndex:432}],headersStr:"由来 封装 流扩展",content:"# 由来\n\nIO的操作包括读和写，应用场景包括网络操作和文件操作。IO操作在Java中是一个较为复杂的过程，我们在面对不同的场景时，要选择不同的InputStream和OutputStream实现来完成这些操作。而如果想读写字符流，还需要Reader和Writer的各种实现类。这些繁杂的实现类，一方面给我们提供了更多的灵活性，另一方面也增加了复杂性。\n\n\n# 封装\n\nio包的封装主要针对流、文件的读写封装，主要以工具类为主，提供常用功能的封装，这包括：\n\n * IoUtil 流操作工具类\n * FileUtil 文件读写和操作的工具类。\n * FileTypeUtil 文件类型判断工具类\n * WatchMonitor 目录、文件监听，封装了JDK1.7中的WatchService\n * ClassPathResource针对ClassPath中资源的访问封装\n * FileReader 封装文件读取\n * FileWriter 封装文件写入\n\n\n# 流扩展\n\n除了针对JDK的读写封装外，还针对特定环境和文件扩展了流实现。\n\n包括：\n\n * BOMInputStream针对含有BOM头的流读取\n * FastByteArrayOutputStream 基于快速缓冲FastByteBuffer的OutputStream，随着数据的增长自动扩充缓冲区（from blade）\n * FastByteBuffer 快速缓冲，将数据存放在缓冲集中，取代以往的单一数组（from blade）",normalizedContent:"# 由来\n\nio的操作包括读和写，应用场景包括网络操作和文件操作。io操作在java中是一个较为复杂的过程，我们在面对不同的场景时，要选择不同的inputstream和outputstream实现来完成这些操作。而如果想读写字符流，还需要reader和writer的各种实现类。这些繁杂的实现类，一方面给我们提供了更多的灵活性，另一方面也增加了复杂性。\n\n\n# 封装\n\nio包的封装主要针对流、文件的读写封装，主要以工具类为主，提供常用功能的封装，这包括：\n\n * ioutil 流操作工具类\n * fileutil 文件读写和操作的工具类。\n * filetypeutil 文件类型判断工具类\n * watchmonitor 目录、文件监听，封装了jdk1.7中的watchservice\n * classpathresource针对classpath中资源的访问封装\n * filereader 封装文件读取\n * filewriter 封装文件写入\n\n\n# 流扩展\n\n除了针对jdk的读写封装外，还针对特定环境和文件扩展了流实现。\n\n包括：\n\n * bominputstream针对含有bom头的流读取\n * fastbytearrayoutputstream 基于快速缓冲fastbytebuffer的outputstream，随着数据的增长自动扩充缓冲区（from blade）\n * fastbytebuffer 快速缓冲，将数据存放在缓冲集中，取代以往的单一数组（from blade）",charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"IO工具类-IoUtil",frontmatter:{title:"IO工具类-IoUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/IoUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/01.IO%E5%B7%A5%E5%85%B7%E7%B1%BB-IoUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/01.IO工具类-IoUtil.md",key:"v-c8d8cb58",path:"/pages/IoUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:133},{level:3,title:"拷贝",slug:"拷贝",normalizedTitle:"拷贝",charIndex:140},{level:3,title:"Stream转Reader、Writer",slug:"stream转reader、writer",normalizedTitle:"stream转reader、writer",charIndex:645},{level:3,title:"读取流中的内容",slug:"读取流中的内容",normalizedTitle:"读取流中的内容",charIndex:946},{level:3,title:"写入到流",slug:"写入到流",normalizedTitle:"写入到流",charIndex:1342},{level:3,title:"关闭",slug:"关闭",normalizedTitle:"关闭",charIndex:1529}],headersStr:"由来 方法 拷贝 Stream转Reader、Writer 读取流中的内容 写入到流 关闭",content:'# 由来\n\nIO工具类的存在主要针对InputStream、OutputStream、Reader、Writer封装简化，并对NIO相关操作做封装简化。总体来说，Hutool对IO的封装，主要是工具层面，我们努力做到在便捷、性能和灵活之间找到最好的平衡点。\n\n\n# 方法\n\n\n# 拷贝\n\n流的读写可以总结为从输入流读取，从输出流写出，这个过程我们定义为拷贝。这是一个基本过程，也是文件、流操作的基础。\n\n以文件流拷贝为例：\n\nBufferedInputStream in = FileUtil.getInputStream("d:/test.txt");\nBufferedOutputStream out = FileUtil.getOutputStream("d:/test2.txt");\nlong copySize = IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE);\n\n\ncopy方法同样针对Reader、Writer、Channel等对象有一些重载方法，并提供可选的缓存大小。默认的，缓存大小为1024个字节，如果拷贝大文件或流数据较大，可以适当调整这个参数。\n\n针对NIO，提供了copyByNIO方法，以便和BIO有所区别。我查阅过一些资料，使用NIO对文件流的操作有一定的提升，我并没有做具体实验。相关测试请参阅博客：http://www.cnblogs.com/gaopeng527/p/4896783.html\n\n\n# Stream转Reader、Writer\n\n * IoUtil.getReader：将InputStream转为BufferedReader用于读取字符流，它是部分readXXX方法的基础。\n * IoUtil.getWriter：将OutputStream转为OutputStreamWriter用于写入字符流，它是部分writeXXX的基础。\n\n本质上这两个方法只是简单new一个新的Reader或者Writer对象，但是封装为工具方法配合IDE的自动提示可以大大减少查阅次数（例如你对BufferedReader、OutputStreamWriter不熟悉，是不是需要搜索一下相关类？）\n\n\n# 读取流中的内容\n\n读取流中的内容总结下来，可以分为read方法和readXXX方法。\n\n 1. read方法有诸多的重载方法，根据参数不同，可以读取不同对象中的内容，这包括：\n\n * InputStream\n * Reader\n * FileChannel\n\n这三个重载大部分返回String字符串，为字符流读取提供极大便利。\n\n 2. readXXX方法主要针对返回值做一些处理，例如：\n\n * readBytes 返回byte数组（读取图片等）\n * readHex 读取16进制字符串\n * readObj 读取序列化对象（反序列化）\n * readLines 按行读取\n\n 3. toStream方法则是将某些对象转换为流对象，便于在某些情况下操作：\n\n * String 转换为ByteArrayInputStream\n * File 转换为FileInputStream\n\n\n# 写入到流\n\n * IoUtil.write方法有两个重载方法，一个直接调用OutputStream.write方法，另一个用于将对象转换为字符串（调用toString方法），然后写入到流中。\n * IoUtil.writeObjects 用于将可序列化对象序列化后写入到流中。\n\nwrite方法并没有提供writeXXX，需要自己转换为String或byte[]。\n\n\n# 关闭\n\n对于IO操作来说，使用频率最高（也是最容易被遗忘）的就是close操作，好在Java规范使用了优雅的Closeable接口，这样我们只需简单封装调用此接口的方法即可。\n\n关闭操作会面临两个问题：\n\n 1. 被关闭对象为空\n 2. 对象关闭失败（或对象已关闭）\n\nIoUtil.close方法很好的解决了这两个问题。\n\n在JDK1.7中，提供了AutoCloseable接口，在IoUtil中同样提供相应的重载方法，在使用中并不会感觉到有哪些不同。',normalizedContent:'# 由来\n\nio工具类的存在主要针对inputstream、outputstream、reader、writer封装简化，并对nio相关操作做封装简化。总体来说，hutool对io的封装，主要是工具层面，我们努力做到在便捷、性能和灵活之间找到最好的平衡点。\n\n\n# 方法\n\n\n# 拷贝\n\n流的读写可以总结为从输入流读取，从输出流写出，这个过程我们定义为拷贝。这是一个基本过程，也是文件、流操作的基础。\n\n以文件流拷贝为例：\n\nbufferedinputstream in = fileutil.getinputstream("d:/test.txt");\nbufferedoutputstream out = fileutil.getoutputstream("d:/test2.txt");\nlong copysize = ioutil.copy(in, out, ioutil.default_buffer_size);\n\n\ncopy方法同样针对reader、writer、channel等对象有一些重载方法，并提供可选的缓存大小。默认的，缓存大小为1024个字节，如果拷贝大文件或流数据较大，可以适当调整这个参数。\n\n针对nio，提供了copybynio方法，以便和bio有所区别。我查阅过一些资料，使用nio对文件流的操作有一定的提升，我并没有做具体实验。相关测试请参阅博客：http://www.cnblogs.com/gaopeng527/p/4896783.html\n\n\n# stream转reader、writer\n\n * ioutil.getreader：将inputstream转为bufferedreader用于读取字符流，它是部分readxxx方法的基础。\n * ioutil.getwriter：将outputstream转为outputstreamwriter用于写入字符流，它是部分writexxx的基础。\n\n本质上这两个方法只是简单new一个新的reader或者writer对象，但是封装为工具方法配合ide的自动提示可以大大减少查阅次数（例如你对bufferedreader、outputstreamwriter不熟悉，是不是需要搜索一下相关类？）\n\n\n# 读取流中的内容\n\n读取流中的内容总结下来，可以分为read方法和readxxx方法。\n\n 1. read方法有诸多的重载方法，根据参数不同，可以读取不同对象中的内容，这包括：\n\n * inputstream\n * reader\n * filechannel\n\n这三个重载大部分返回string字符串，为字符流读取提供极大便利。\n\n 2. readxxx方法主要针对返回值做一些处理，例如：\n\n * readbytes 返回byte数组（读取图片等）\n * readhex 读取16进制字符串\n * readobj 读取序列化对象（反序列化）\n * readlines 按行读取\n\n 3. tostream方法则是将某些对象转换为流对象，便于在某些情况下操作：\n\n * string 转换为bytearrayinputstream\n * file 转换为fileinputstream\n\n\n# 写入到流\n\n * ioutil.write方法有两个重载方法，一个直接调用outputstream.write方法，另一个用于将对象转换为字符串（调用tostring方法），然后写入到流中。\n * ioutil.writeobjects 用于将可序列化对象序列化后写入到流中。\n\nwrite方法并没有提供writexxx，需要自己转换为string或byte[]。\n\n\n# 关闭\n\n对于io操作来说，使用频率最高（也是最容易被遗忘）的就是close操作，好在java规范使用了优雅的closeable接口，这样我们只需简单封装调用此接口的方法即可。\n\n关闭操作会面临两个问题：\n\n 1. 被关闭对象为空\n 2. 对象关闭失败（或对象已关闭）\n\nioutil.close方法很好的解决了这两个问题。\n\n在jdk1.7中，提供了autocloseable接口，在ioutil中同样提供相应的重载方法，在使用中并不会感觉到有哪些不同。',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"文件工具类-FileUtil",frontmatter:{title:"文件工具类-FileUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/FileUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/02.%E6%96%87%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%B1%BB-FileUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/02.文件工具类-FileUtil.md",key:"v-3b5b2bd3",path:"/pages/FileUtil/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2}],headersStr:"简介",content:"# 简介\n\n在IO操作中，文件的操作相对来说是比较复杂的，但也是使用频率最高的部分，我们几乎所有的项目中都躺着一个叫做FileUtil或者FileUtils的工具类，我想Hutool应该将这个工具类纳入其中，用来解决大部分的文件操作问题。\n\n总体来说，FileUtil类包含以下几类操作工具：\n\n 1. 文件操作：包括文件目录的新建、删除、复制、移动、改名等\n 2. 文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等。\n 3. 绝对路径：针对ClassPath中的文件转换为绝对路径文件。\n 4. 文件名：主文件名，扩展名的获取\n 5. 读操作：包括类似IoUtil中的getReader、readXXX操作\n 6. 写操作：包括getWriter和writeXXX操作\n\n在FileUtil中，我努力让方法名与Linux相一致，例如创建文件的方法并不是createFile，而是touch，这种统一对于熟悉Linux的人来说，大大提高了上手速度。当然，如果你不熟悉Linux，那FileUtil工具类的使用则是在帮助你学习Linux命令。这些类Linux命令的方法包括：\n\n * ls 列出目录和文件\n * touch 创建文件，如果父目录不存在也自动创建\n * mkdir 创建目录，会递归创建每层目录\n * del 删除文件或目录（递归删除，不判断是否为空），这个方法相当于Linux的delete命令\n * copy 拷贝文件或目录\n\n这些方法提供了人性化的操作，例如touch方法，在创建文件的情况下会自动创建上层目录（我想对于使用者来说这也是大部分情况下的需求），同样mkdir也会创建父目录。\n\n> 需要注意的是，del方法会删除目录而不判断其是否为空，这一方面方便了使用，另一方面也可能造成一些预想不到的后果（比如拼写错路径而删除不应该删除的目录），所以请谨慎使用此方法。\n\n关于FileUtil中更多工具方法，请参阅API文档。",normalizedContent:"# 简介\n\n在io操作中，文件的操作相对来说是比较复杂的，但也是使用频率最高的部分，我们几乎所有的项目中都躺着一个叫做fileutil或者fileutils的工具类，我想hutool应该将这个工具类纳入其中，用来解决大部分的文件操作问题。\n\n总体来说，fileutil类包含以下几类操作工具：\n\n 1. 文件操作：包括文件目录的新建、删除、复制、移动、改名等\n 2. 文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等。\n 3. 绝对路径：针对classpath中的文件转换为绝对路径文件。\n 4. 文件名：主文件名，扩展名的获取\n 5. 读操作：包括类似ioutil中的getreader、readxxx操作\n 6. 写操作：包括getwriter和writexxx操作\n\n在fileutil中，我努力让方法名与linux相一致，例如创建文件的方法并不是createfile，而是touch，这种统一对于熟悉linux的人来说，大大提高了上手速度。当然，如果你不熟悉linux，那fileutil工具类的使用则是在帮助你学习linux命令。这些类linux命令的方法包括：\n\n * ls 列出目录和文件\n * touch 创建文件，如果父目录不存在也自动创建\n * mkdir 创建目录，会递归创建每层目录\n * del 删除文件或目录（递归删除，不判断是否为空），这个方法相当于linux的delete命令\n * copy 拷贝文件或目录\n\n这些方法提供了人性化的操作，例如touch方法，在创建文件的情况下会自动创建上层目录（我想对于使用者来说这也是大部分情况下的需求），同样mkdir也会创建父目录。\n\n> 需要注意的是，del方法会删除目录而不判断其是否为空，这一方面方便了使用，另一方面也可能造成一些预想不到的后果（比如拼写错路径而删除不应该删除的目录），所以请谨慎使用此方法。\n\n关于fileutil中更多工具方法，请参阅api文档。",charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"文件类型判断-FileTypeUtil",frontmatter:{title:"文件类型判断-FileTypeUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/FileTypeUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/04.%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD-FileTypeUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/04.文件类型判断-FileTypeUtil.md",key:"v-f2bbe9fe",path:"/pages/FileTypeUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:100},{level:2,title:"原理和局限性",slug:"原理和局限性",normalizedTitle:"原理和局限性",charIndex:303},{level:2,title:"自定义类型",slug:"自定义类型",normalizedTitle:"自定义类型",charIndex:527}],headersStr:"由来 使用 原理和局限性 自定义类型",content:'# 由来\n\n在文件上传时，有时候我们需要判断文件类型。但是又不能简单的通过扩展名来判断（防止恶意脚本等上传到服务器上），于是我们需要在服务端通过读取文件的首部几个字节值来判断常用的文件类型。\n\n\n# 使用\n\n这个工具类使用非常简单，通过调用FileTypeUtil.getType即可判断，这个方法同时提供众多的重载方法，用于读取不同的文件和流。\n\nFile file = FileUtil.file("d:/test.jpg");\nString type = FileTypeUtil.getType(file);\n//输出 jpg则说明确实为jpg文件\nConsole.log(type);\n\n\n\n# 原理和局限性\n\n这个类是通过读取文件流中前N个byte值来判断文件类型，在类中我们通过Map形式将常用的文件类型做了映射，这些映射都是网络上搜集而来。也就是说，我们只能识别有限的几种文件类型。但是这些类型已经涵盖了常用的图片、音频、视频、Office文档类型，可以应对大部分的使用场景。\n\n> 对于某些文本格式的文件我们并不能通过首部byte判断其类型，比如JSON，这类文件本质上是文本文件，我们应该读取其文本内容，通过其语法判断类型。\n\n\n# 自定义类型\n\n为了提高FileTypeUtil的扩展性，我们通过putFileType方法可以自定义文件类型。\n\nFileTypeUtil.putFileType("ffd8ffe000104a464946", "new_jpg");\n\n\n第一个参数是文件流的前N个byte的16进制表示，我们可以读取自定义文件查看，选取一定长度即可(长度越长越精确)，第二个参数就是文件类型，然后使用FileTypeUtil.getType即可。\n\n> 注意 xlsx、docx本质上是各种XML打包为zip的结果，因此会被识别为zip格式。',normalizedContent:'# 由来\n\n在文件上传时，有时候我们需要判断文件类型。但是又不能简单的通过扩展名来判断（防止恶意脚本等上传到服务器上），于是我们需要在服务端通过读取文件的首部几个字节值来判断常用的文件类型。\n\n\n# 使用\n\n这个工具类使用非常简单，通过调用filetypeutil.gettype即可判断，这个方法同时提供众多的重载方法，用于读取不同的文件和流。\n\nfile file = fileutil.file("d:/test.jpg");\nstring type = filetypeutil.gettype(file);\n//输出 jpg则说明确实为jpg文件\nconsole.log(type);\n\n\n\n# 原理和局限性\n\n这个类是通过读取文件流中前n个byte值来判断文件类型，在类中我们通过map形式将常用的文件类型做了映射，这些映射都是网络上搜集而来。也就是说，我们只能识别有限的几种文件类型。但是这些类型已经涵盖了常用的图片、音频、视频、office文档类型，可以应对大部分的使用场景。\n\n> 对于某些文本格式的文件我们并不能通过首部byte判断其类型，比如json，这类文件本质上是文本文件，我们应该读取其文本内容，通过其语法判断类型。\n\n\n# 自定义类型\n\n为了提高filetypeutil的扩展性，我们通过putfiletype方法可以自定义文件类型。\n\nfiletypeutil.putfiletype("ffd8ffe000104a464946", "new_jpg");\n\n\n第一个参数是文件流的前n个byte的16进制表示，我们可以读取自定义文件查看，选取一定长度即可(长度越长越精确)，第二个参数就是文件类型，然后使用filetypeutil.gettype即可。\n\n> 注意 xlsx、docx本质上是各种xml打包为zip的结果，因此会被识别为zip格式。',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"文件读取-FileReader",frontmatter:{title:"文件读取-FileReader",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/FileReader/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/05.%E6%96%87%E4%BB%B6/01.%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96-FileReader.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/05.文件/01.文件读取-FileReader.md",key:"v-24516993",path:"/pages/FileReader/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:81}],headersStr:"由来 使用",content:'# 由来\n\n在FileUtil中本来已经针对文件的读操作做了大量的静态封装，但是根据职责分离原则，我觉得有必要针对文件读取单独封装一个类，这样项目更加清晰。当然，使用FileUtil操作文件是最方便的。\n\n\n# 使用\n\n在JDK中，同样有一个FileReader类，但是并不如想象中的那样好用，于是Hutool便提供了更加便捷的FileReader类。\n\n//默认UTF-8编码，可以在构造中传入第二个参数做为编码\nFileReader fileReader = new FileReader("test.properties");\nString result = fileReader.readString();\n\n\nFileReader提供了以下方法来快速读取文件内容：\n\n * readBytes\n * readString\n * readLines\n\n同时，此类还提供了以下方法用于转换为流或者BufferedReader：\n\n * getReader\n * getInputStream',normalizedContent:'# 由来\n\n在fileutil中本来已经针对文件的读操作做了大量的静态封装，但是根据职责分离原则，我觉得有必要针对文件读取单独封装一个类，这样项目更加清晰。当然，使用fileutil操作文件是最方便的。\n\n\n# 使用\n\n在jdk中，同样有一个filereader类，但是并不如想象中的那样好用，于是hutool便提供了更加便捷的filereader类。\n\n//默认utf-8编码，可以在构造中传入第二个参数做为编码\nfilereader filereader = new filereader("test.properties");\nstring result = filereader.readstring();\n\n\nfilereader提供了以下方法来快速读取文件内容：\n\n * readbytes\n * readstring\n * readlines\n\n同时，此类还提供了以下方法用于转换为流或者bufferedreader：\n\n * getreader\n * getinputstream',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"计时器工具-TimeInterval",frontmatter:{title:"计时器工具-TimeInterval",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/TimeInterval/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/03.%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/06.%E8%AE%A1%E6%97%B6%E5%99%A8%E5%B7%A5%E5%85%B7-TimeInterval.html",relativePath:"01.指南/02.核心（Hutool-core）/03.日期时间/06.计时器工具-TimeInterval.md",key:"v-d4fe211e",path:"/pages/TimeInterval/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:85}],headersStr:"介绍 使用",content:'# 介绍\n\nHutool通过封装TimeInterval实现计时器功能，即可以计算方法或过程执行的时间。\n\nTimeInterval支持分组计时，方便对比时间。\n\n\n# 使用\n\nTimeInterval timer = DateUtil.timer();\n\n//---------------------------------\n//-------这是执行过程\n//---------------------------------\n\ntimer.interval();//花费毫秒数\ntimer.intervalRestart();//返回花费时间，并重置开始时间\ntimer.intervalMinute();//花费分钟数\n\n\n也可以实现分组计时：\n\nfinal TimeInterval timer = new TimeInterval();\n\n// 分组1\ntimer.start("1");\nThreadUtil.sleep(800);\n\n// 分组2\ntimer.start("2");\nThreadUtil.sleep(900);\n\nConsole.log("Timer 1 took {} ms", timer.intervalMs("1"));\nConsole.log("Timer 2 took {} ms", timer.intervalMs("2"));\n',normalizedContent:'# 介绍\n\nhutool通过封装timeinterval实现计时器功能，即可以计算方法或过程执行的时间。\n\ntimeinterval支持分组计时，方便对比时间。\n\n\n# 使用\n\ntimeinterval timer = dateutil.timer();\n\n//---------------------------------\n//-------这是执行过程\n//---------------------------------\n\ntimer.interval();//花费毫秒数\ntimer.intervalrestart();//返回花费时间，并重置开始时间\ntimer.intervalminute();//花费分钟数\n\n\n也可以实现分组计时：\n\nfinal timeinterval timer = new timeinterval();\n\n// 分组1\ntimer.start("1");\nthreadutil.sleep(800);\n\n// 分组2\ntimer.start("2");\nthreadutil.sleep(900);\n\nconsole.log("timer 1 took {} ms", timer.intervalms("1"));\nconsole.log("timer 2 took {} ms", timer.intervalms("2"));\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"文件监听-WatchMonitor",frontmatter:{title:"文件监听-WatchMonitor",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/WatchMonitor/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/03.%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC-WatchMonitor.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/03.文件监听-WatchMonitor.md",key:"v-610709fa",path:"/pages/WatchMonitor/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:3,title:"WatchMonitor",slug:"watchmonitor",normalizedTitle:"watchmonitor",charIndex:388},{level:3,title:"内部应用",slug:"内部应用",normalizedTitle:"内部应用",charIndex:507},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:531},{level:3,title:"监听指定事件",slug:"监听指定事件",normalizedTitle:"监听指定事件",charIndex:797},{level:3,title:"监听全部事件",slug:"监听全部事件",normalizedTitle:"监听全部事件",charIndex:1741},{level:3,title:"延迟处理监听事件",slug:"延迟处理监听事件",normalizedTitle:"延迟处理监听事件",charIndex:2072}],headersStr:"由来 WatchMonitor 内部应用 使用 监听指定事件 监听全部事件 延迟处理监听事件",content:'# 由来\n\n很多时候我们需要监听一个文件的变化或者目录的变动，包括文件的创建、修改、删除，以及目录下文件的创建、修改和删除，在JDK7前我们只能靠轮询方式遍历目录或者定时检查文件的修改事件，这样效率非常低，性能也很差。因此在JDK7中引入了WatchService。不过考虑到其API并不友好，于是Hutool便针对其做了简化封装，使监听更简单，也提供了更好的功能，这包括：\n\n * 支持多级目录的监听（WatchService只支持一级目录），可自定义监听目录深度\n * 延迟合并触发支持（文件变动时可能触发多次modify，支持在某个时间范围内的多次修改事件合并为一个修改事件）\n * 简洁易懂的API方法，一个方法即可搞定监听，无需理解复杂的监听注册机制。\n * 多观察者实现，可以根据业务实现多个Watcher来响应同一个事件（通过WatcherChain）\n\n\n# WatchMonitor\n\n在Hutool中，WatchMonitor主要针对JDK7中WatchService做了封装，针对文件和目录的变动（创建、更新、删除）做一个钩子，在Watcher中定义相应的逻辑来应对这些文件的变化。\n\n\n# 内部应用\n\n在hutool-setting模块，使用WatchMonitor监测配置文件变化，然后自动load到内存中。WatchMonitor的使用可以避免轮询，以事件响应的方式应对文件变化。\n\n\n# 使用\n\nWatchMonitor提供的事件有：\n\n * ENTRY_MODIFY 文件或目录的修改事件\n * ENTRY_CREATE 文件或目录的创建事件\n * ENTRY_DELETE 文件或目录的删除事件\n * OVERFLOW 丢失的事件\n\n这些事件对应StandardWatchEventKinds中的事件。\n\n下面我们介绍WatchMonitor的使用：\n\n\n# 监听指定事件\n\nFile file = FileUtil.file("example.properties");\n//这里只监听文件或目录的修改事件\nWatchMonitor watchMonitor = WatchMonitor.create(file, WatchMonitor.ENTRY_MODIFY);\nwatchMonitor.setWatcher(new Watcher(){\n\t@Override\n\tpublic void onCreate(WatchEvent<?> event, Path currentPath) {\n\t\tObject obj = event.context();\n\t\tConsole.log("创建：{}-> {}", currentPath, obj);\n\t}\n\n\t@Override\n\tpublic void onModify(WatchEvent<?> event, Path currentPath) {\n\t\tObject obj = event.context();\n\t\tConsole.log("修改：{}-> {}", currentPath, obj);\n\t}\n\n\t@Override\n\tpublic void onDelete(WatchEvent<?> event, Path currentPath) {\n\t\tObject obj = event.context();\n\t\tConsole.log("删除：{}-> {}", currentPath, obj);\n\t}\n\n\t@Override\n\tpublic void onOverflow(WatchEvent<?> event, Path currentPath) {\n\t\tObject obj = event.context();\n\t\tConsole.log("Overflow：{}-> {}", currentPath, obj);\n\t}\n});\n\n//设置监听目录的最大深入，目录层级大于制定层级的变更将不被监听，默认只监听当前层级目录\nwatchMonitor.setMaxDepth(3);\n//启动监听\nwatchMonitor.start();\n\n\n\n# 监听全部事件\n\n其实我们不必实现Watcher的所有接口方法，Hutool同时提供了SimpleWatcher类，只需重写对应方法即可。\n\n同样，如果我们想监听所有事件，可以：\n\nWatchMonitor.createAll(file, new SimpleWatcher(){\n\t@Override\n\tpublic void onModify(WatchEvent<?> event, Path currentPath) {\n\t\tConsole.log("EVENT modify");\n\t}\n}).start();\n\n\ncreateAll方法会创建一个监听所有事件的WatchMonitor，同时在第二个参数中定义Watcher来负责处理这些变动。\n\n\n# 延迟处理监听事件\n\n在监听目录或文件时，如果这个文件有修改操作，JDK会多次触发modify方法，为了解决这个问题，我们定义了DelayWatcher，此类通过维护一个Set将短时间内相同文件多次modify的事件合并处理触发，从而避免以上问题。\n\nWatchMonitor monitor = WatchMonitor.createAll("d:/", new DelayWatcher(watcher, 500));\nmonitor.start();\n',normalizedContent:'# 由来\n\n很多时候我们需要监听一个文件的变化或者目录的变动，包括文件的创建、修改、删除，以及目录下文件的创建、修改和删除，在jdk7前我们只能靠轮询方式遍历目录或者定时检查文件的修改事件，这样效率非常低，性能也很差。因此在jdk7中引入了watchservice。不过考虑到其api并不友好，于是hutool便针对其做了简化封装，使监听更简单，也提供了更好的功能，这包括：\n\n * 支持多级目录的监听（watchservice只支持一级目录），可自定义监听目录深度\n * 延迟合并触发支持（文件变动时可能触发多次modify，支持在某个时间范围内的多次修改事件合并为一个修改事件）\n * 简洁易懂的api方法，一个方法即可搞定监听，无需理解复杂的监听注册机制。\n * 多观察者实现，可以根据业务实现多个watcher来响应同一个事件（通过watcherchain）\n\n\n# watchmonitor\n\n在hutool中，watchmonitor主要针对jdk7中watchservice做了封装，针对文件和目录的变动（创建、更新、删除）做一个钩子，在watcher中定义相应的逻辑来应对这些文件的变化。\n\n\n# 内部应用\n\n在hutool-setting模块，使用watchmonitor监测配置文件变化，然后自动load到内存中。watchmonitor的使用可以避免轮询，以事件响应的方式应对文件变化。\n\n\n# 使用\n\nwatchmonitor提供的事件有：\n\n * entry_modify 文件或目录的修改事件\n * entry_create 文件或目录的创建事件\n * entry_delete 文件或目录的删除事件\n * overflow 丢失的事件\n\n这些事件对应standardwatcheventkinds中的事件。\n\n下面我们介绍watchmonitor的使用：\n\n\n# 监听指定事件\n\nfile file = fileutil.file("example.properties");\n//这里只监听文件或目录的修改事件\nwatchmonitor watchmonitor = watchmonitor.create(file, watchmonitor.entry_modify);\nwatchmonitor.setwatcher(new watcher(){\n\t@override\n\tpublic void oncreate(watchevent<?> event, path currentpath) {\n\t\tobject obj = event.context();\n\t\tconsole.log("创建：{}-> {}", currentpath, obj);\n\t}\n\n\t@override\n\tpublic void onmodify(watchevent<?> event, path currentpath) {\n\t\tobject obj = event.context();\n\t\tconsole.log("修改：{}-> {}", currentpath, obj);\n\t}\n\n\t@override\n\tpublic void ondelete(watchevent<?> event, path currentpath) {\n\t\tobject obj = event.context();\n\t\tconsole.log("删除：{}-> {}", currentpath, obj);\n\t}\n\n\t@override\n\tpublic void onoverflow(watchevent<?> event, path currentpath) {\n\t\tobject obj = event.context();\n\t\tconsole.log("overflow：{}-> {}", currentpath, obj);\n\t}\n});\n\n//设置监听目录的最大深入，目录层级大于制定层级的变更将不被监听，默认只监听当前层级目录\nwatchmonitor.setmaxdepth(3);\n//启动监听\nwatchmonitor.start();\n\n\n\n# 监听全部事件\n\n其实我们不必实现watcher的所有接口方法，hutool同时提供了simplewatcher类，只需重写对应方法即可。\n\n同样，如果我们想监听所有事件，可以：\n\nwatchmonitor.createall(file, new simplewatcher(){\n\t@override\n\tpublic void onmodify(watchevent<?> event, path currentpath) {\n\t\tconsole.log("event modify");\n\t}\n}).start();\n\n\ncreateall方法会创建一个监听所有事件的watchmonitor，同时在第二个参数中定义watcher来负责处理这些变动。\n\n\n# 延迟处理监听事件\n\n在监听目录或文件时，如果这个文件有修改操作，jdk会多次触发modify方法，为了解决这个问题，我们定义了delaywatcher，此类通过维护一个set将短时间内相同文件多次modify的事件合并处理触发，从而避免以上问题。\n\nwatchmonitor monitor = watchmonitor.createall("d:/", new delaywatcher(watcher, 500));\nmonitor.start();\n',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"文件写入-FileWriter",frontmatter:{title:"文件写入-FileWriter",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/FileWriter/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/05.%E6%96%87%E4%BB%B6/02.%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5-FileWriter.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/05.文件/02.文件写入-FileWriter.md",key:"v-3b9986b4",path:"/pages/FileWriter/",headersStr:null,content:'相应的，文件读取有了，自然有文件写入类，使用方式与FileReader也类似：\n\nFileWriter writer = new FileWriter("test.properties");\nwriter.write("test");\n\n\n写入文件分为追加模式和覆盖模式两类，追加模式可以用append方法，覆盖模式可以用write方法，同时也提供了一个write方法，第二个参数是可选覆盖模式。\n\n同样，此类提供了：\n\n * getOutputStream\n * getWriter\n * getPrintWriter\n\n这些方法用于转换为相应的类，提供更加灵活的写入操作。',normalizedContent:'相应的，文件读取有了，自然有文件写入类，使用方式与filereader也类似：\n\nfilewriter writer = new filewriter("test.properties");\nwriter.write("test");\n\n\n写入文件分为追加模式和覆盖模式两类，追加模式可以用append方法，覆盖模式可以用write方法，同时也提供了一个write方法，第二个参数是可选覆盖模式。\n\n同样，此类提供了：\n\n * getoutputstream\n * getwriter\n * getprintwriter\n\n这些方法用于转换为相应的类，提供更加灵活的写入操作。',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"文件跟随-Tailer",frontmatter:{title:"文件跟随-Tailer",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Tailer/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/05.%E6%96%87%E4%BB%B6/04.%E6%96%87%E4%BB%B6%E8%B7%9F%E9%9A%8F-Tailer.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/05.文件/04.文件跟随-Tailer.md",key:"v-e6999578",path:"/pages/Tailer/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:85}],headersStr:"由来 使用",content:'# 由来\n\n有时候我们要启动一个线程实时“监控”文件的变化，比如有新内容写出到文件时，我们可以及时打印出来，这个功能非常类似于Linux下的tail -f命令。\n\n\n# 使用\n\nTailer tailer = new Tailer(FileUtil.file("f:/test/test.log"), Tailer.CONSOLE_HANDLER, 2);\ntailer.start();\n\n\n其中Tailer.CONSOLE_HANDLER表示文件新增内容默认输出到控制台。\n\n/**\n * 命令行打印的行处理器\n * \n * @author looly\n * @since 4.5.2\n */\npublic static class ConsoleLineHandler implements LineHandler {\n\t@Override\n\tpublic void handle(String line) {\n\t\tConsole.log(line);\n\t}\n}\n\n\n我们也可以实现自己的LineHandler来处理每一行数据。\n\n> 注意 此方法会阻塞当前线程',normalizedContent:'# 由来\n\n有时候我们要启动一个线程实时“监控”文件的变化，比如有新内容写出到文件时，我们可以及时打印出来，这个功能非常类似于linux下的tail -f命令。\n\n\n# 使用\n\ntailer tailer = new tailer(fileutil.file("f:/test/test.log"), tailer.console_handler, 2);\ntailer.start();\n\n\n其中tailer.console_handler表示文件新增内容默认输出到控制台。\n\n/**\n * 命令行打印的行处理器\n * \n * @author looly\n * @since 4.5.2\n */\npublic static class consolelinehandler implements linehandler {\n\t@override\n\tpublic void handle(string line) {\n\t\tconsole.log(line);\n\t}\n}\n\n\n我们也可以实现自己的linehandler来处理每一行数据。\n\n> 注意 此方法会阻塞当前线程',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"文件名工具-FileNameUtil",frontmatter:{title:"文件名工具-FileNameUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/FileNameUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/05.%E6%96%87%E4%BB%B6/05.%E6%96%87%E4%BB%B6%E5%90%8D%E5%B7%A5%E5%85%B7-FileNameUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/05.文件/05.文件名工具-FileNameUtil.md",key:"v-a50927ba",path:"/pages/FileNameUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:111}],headersStr:"由来 使用",content:'# 由来\n\n文件名操作工具类，主要针对文件名获取主文件名、扩展名等操作，同时针对Windows平台，清理无效字符。\n\n此工具类在5.4.1之前是FileUtil的一部分，后单独剥离为FileNameUtil工具。\n\n\n# 使用\n\n 1. 获取文件名\n\nFile file = FileUtil.file("https://doc.hutool.cn/opt/test.txt");\n\n// test.txt\nString name = FileNameUtil.getName(file);\n\n\n 2. 获取主文件名和扩展名\n\nFile file = FileUtil.file("https://doc.hutool.cn/opt/test.txt");\n\n// "test"\nString name = FileNameUtil.mainName(file);\n\n// "txt"\nString name = FileNameUtil.extName(file);\n\n\n> 注意，此处获取的扩展名不带.。 FileNameUtil.mainName和FileNameUtil.getPrefix等价，同理FileNameUtil.extName和FileNameUtil.getSuffix等价，保留两个方法用于适应不同用户的习惯。',normalizedContent:'# 由来\n\n文件名操作工具类，主要针对文件名获取主文件名、扩展名等操作，同时针对windows平台，清理无效字符。\n\n此工具类在5.4.1之前是fileutil的一部分，后单独剥离为filenameutil工具。\n\n\n# 使用\n\n 1. 获取文件名\n\nfile file = fileutil.file("https://doc.hutool.cn/opt/test.txt");\n\n// test.txt\nstring name = filenameutil.getname(file);\n\n\n 2. 获取主文件名和扩展名\n\nfile file = fileutil.file("https://doc.hutool.cn/opt/test.txt");\n\n// "test"\nstring name = filenameutil.mainname(file);\n\n// "txt"\nstring name = filenameutil.extname(file);\n\n\n> 注意，此处获取的扩展名不带.。 filenameutil.mainname和filenameutil.getprefix等价，同理filenameutil.extname和filenameutil.getsuffix等价，保留两个方法用于适应不同用户的习惯。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/resource"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/06.%E8%B5%84%E6%BA%90/00.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/06.资源/00.概述.md",key:"v-4080eff2",path:"/pages/resource/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:392}],headersStr:"由来 定义",content:"# 由来\n\n资源（Resource）在Hutool中是一个广泛的概念，凡是存储数据的地方都可以归类到资源，那为何要提供一个如此抽象的接口呢？\n\n在实际编码当中，我们需要读取一些数据，比如配置文件、文本内容、图片甚至是任何二进制流，为此我们要加入很多的重载方法，比如：\n\nread(File file){...}\n\nread(InputStream in){...}\n\nread(byte[] bytes){...}\n\nread(URL url){...}\n\n\n等等如此，这样会造成整个代码变得非常冗余，查找API也很费劲。其实无论数据来自哪里，最终目的是，我们想从这些地方读到byte[]或者String。那么，我们就可以抽象一个Resource接口，让代码变得简单：\n\nread(Resource resource){...}\n\n\n用户只需传入Resource的实现即可。\n\n\n# 定义\n\n常见的，我们需要从资源中获取流（getStream），获取Reader来读取文本（getReader），直接读取文本（readStr），于是定义如下：\n\npublic interface Resource {\n    String getName();\n    URL getUrl();\n    InputStream getStream();\n    BufferedReader getReader(Charset charset);\n    String readStr(Charset charset);\n}\n\n\n> 关于Resource的详细定义见：Resource.java\n\n定义了Resource，我们就可以预定义一些特别的资源：\n\n * BytesResource 从byte[]中读取资源\n * InputStreamResource 从流中读取资源\n * StringResource 从String中读取资源\n * UrlResource 从URL中读取资源\n * FileResource 从文件中读取资源\n * ClassPathResource 从classpath（src/resources下）中读取资源\n * WebAppResource 从web root中读取资源\n * MultiResource 从多种资源中混合读取资源\n * MultiFileResource 从多个文件中混合读取资源\n\n当然，我们还可以根据业务需要自己实现Resource接口，完成自定义的资源读取。\n\n> 为了便于资源的查找，可以使用ResourceUtil快捷工具来获得我们需要的资源。",normalizedContent:"# 由来\n\n资源（resource）在hutool中是一个广泛的概念，凡是存储数据的地方都可以归类到资源，那为何要提供一个如此抽象的接口呢？\n\n在实际编码当中，我们需要读取一些数据，比如配置文件、文本内容、图片甚至是任何二进制流，为此我们要加入很多的重载方法，比如：\n\nread(file file){...}\n\nread(inputstream in){...}\n\nread(byte[] bytes){...}\n\nread(url url){...}\n\n\n等等如此，这样会造成整个代码变得非常冗余，查找api也很费劲。其实无论数据来自哪里，最终目的是，我们想从这些地方读到byte[]或者string。那么，我们就可以抽象一个resource接口，让代码变得简单：\n\nread(resource resource){...}\n\n\n用户只需传入resource的实现即可。\n\n\n# 定义\n\n常见的，我们需要从资源中获取流（getstream），获取reader来读取文本（getreader），直接读取文本（readstr），于是定义如下：\n\npublic interface resource {\n    string getname();\n    url geturl();\n    inputstream getstream();\n    bufferedreader getreader(charset charset);\n    string readstr(charset charset);\n}\n\n\n> 关于resource的详细定义见：resource.java\n\n定义了resource，我们就可以预定义一些特别的资源：\n\n * bytesresource 从byte[]中读取资源\n * inputstreamresource 从流中读取资源\n * stringresource 从string中读取资源\n * urlresource 从url中读取资源\n * fileresource 从文件中读取资源\n * classpathresource 从classpath（src/resources下）中读取资源\n * webappresource 从web root中读取资源\n * multiresource 从多种资源中混合读取资源\n * multifileresource 从多个文件中混合读取资源\n\n当然，我们还可以根据业务需要自己实现resource接口，完成自定义的资源读取。\n\n> 为了便于资源的查找，可以使用resourceutil快捷工具来获得我们需要的资源。",charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"文件追加-FileAppender",frontmatter:{title:"文件追加-FileAppender",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/FileAppender/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/05.%E6%96%87%E4%BB%B6/03.%E6%96%87%E4%BB%B6%E8%BF%BD%E5%8A%A0-FileAppender.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/05.文件/03.文件追加-FileAppender.md",key:"v-0759a67a",path:"/pages/FileAppender/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:227}],headersStr:"由来 使用",content:'# 由来\n\n顾名思义，FileAppender类表示文件追加器。此对象持有一个文件，在内存中积累一定量的数据后统一追加到文件，此类只有在写入文件时打开文件，并在写入结束后关闭之。因此此类不需要关闭。\n\n在调用append方法后会缓存于内存，只有超过容量后才会一次性写入文件，因此内存中随时有剩余未写入文件的内容，在最后必须调用flush方法将剩余内容刷入文件。\n\n也就是说，这是一个支持缓存的文件内容追加器。此类主要用于类似于日志写出这类需求。\n\n\n# 使用\n\nFileAppender appender = new FileAppender(file, 16, true);\nappender.append("123");\nappender.append("abc");\nappender.append("xyz");\n\nappender.flush();\nappender.toString();\n',normalizedContent:'# 由来\n\n顾名思义，fileappender类表示文件追加器。此对象持有一个文件，在内存中积累一定量的数据后统一追加到文件，此类只有在写入文件时打开文件，并在写入结束后关闭之。因此此类不需要关闭。\n\n在调用append方法后会缓存于内存，只有超过容量后才会一次性写入文件，因此内存中随时有剩余未写入文件的内容，在最后必须调用flush方法将剩余内容刷入文件。\n\n也就是说，这是一个支持缓存的文件内容追加器。此类主要用于类似于日志写出这类需求。\n\n\n# 使用\n\nfileappender appender = new fileappender(file, 16, true);\nappender.append("123");\nappender.append("abc");\nappender.append("xyz");\n\nappender.flush();\nappender.tostring();\n',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"16进制工具-HexUtil",frontmatter:{title:"16进制工具-HexUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/HexUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/02.16%E8%BF%9B%E5%88%B6%E5%B7%A5%E5%85%B7-HexUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/02.16进制工具-HexUtil.md",key:"v-521a5756",path:"/pages/HexUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"用于",slug:"用于",normalizedTitle:"用于",charIndex:211},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:274}],headersStr:"介绍 用于 使用",content:'# 介绍\n\n十六进制（简写为hex或下标16）在数学中是一种逢16进1的进位制，一般用数字0到9和字母A到F表示（其中:A~F即10~15）。例如十进制数57，在二进制写作111001，在16进制写作39。\n\n像java,c这样的语言为了区分十六进制和十进制数值,会在十六进制数的前面加上 0x,比如0x20是十进制的32,而不是十进制的20。HexUtil就是将字符串或byte数组与16进制表示转换的工具类。\n\n\n# 用于\n\n16进制一般针对无法显示的一些二进制进行显示，常用于： 1、图片的字符串表现形式 2、加密解密 3、编码转换\n\n\n# 使用\n\nHexUtil主要以encodeHex和decodeHex两个方法为核心，提供一些针对字符串的重载方法。\n\nString str = "我是一个字符串";\n\nString hex = HexUtil.encodeHexStr(str, CharsetUtil.CHARSET_UTF_8);\n\n//hex是：\n//e68891e698afe4b880e4b8aae5ad97e7aca6e4b8b2\n\nString decodedStr = HexUtil.decodeHexStr(hex);\n\n//解码后与str相同\n',normalizedContent:'# 介绍\n\n十六进制（简写为hex或下标16）在数学中是一种逢16进1的进位制，一般用数字0到9和字母a到f表示（其中:a~f即10~15）。例如十进制数57，在二进制写作111001，在16进制写作39。\n\n像java,c这样的语言为了区分十六进制和十进制数值,会在十六进制数的前面加上 0x,比如0x20是十进制的32,而不是十进制的20。hexutil就是将字符串或byte数组与16进制表示转换的工具类。\n\n\n# 用于\n\n16进制一般针对无法显示的一些二进制进行显示，常用于： 1、图片的字符串表现形式 2、加密解密 3、编码转换\n\n\n# 使用\n\nhexutil主要以encodehex和decodehex两个方法为核心，提供一些针对字符串的重载方法。\n\nstring str = "我是一个字符串";\n\nstring hex = hexutil.encodehexstr(str, charsetutil.charset_utf_8);\n\n//hex是：\n//e68891e698afe4b880e4b8aae5ad97e7aca6e4b8b2\n\nstring decodedstr = hexutil.decodehexstr(hex);\n\n//解码后与str相同\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/util/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/00.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/00.概述.md",key:"v-eee13e98",path:"/pages/util/",headers:[{level:2,title:"包含内容",slug:"包含内容",normalizedTitle:"包含内容",charIndex:2}],headersStr:"包含内容",content:"# 包含内容\n\n此包中的工具类为未经过分类的一些工具类，提供一些常用的工具方法。\n\n此包中根据用途归类为XXXUtil，提供大量的工具方法。在工具类中，主要以类方法（static方法）为主，且各个类无法实例化为对象，一个方法是一个独立功能，无相互影响。\n\n关于工具类的说明和使用，请参阅下面的章节。",normalizedContent:"# 包含内容\n\n此包中的工具类为未经过分类的一些工具类，提供一些常用的工具方法。\n\n此包中根据用途归类为xxxutil，提供大量的工具方法。在工具类中，主要以类方法（static方法）为主，且各个类无法实例化为对象，一个方法是一个独立功能，无相互影响。\n\n关于工具类的说明和使用，请参阅下面的章节。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"资源工具-ResourceUtil",frontmatter:{title:"资源工具-ResourceUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ResourceUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/06.%E8%B5%84%E6%BA%90/01.%E8%B5%84%E6%BA%90%E5%B7%A5%E5%85%B7-ResourceUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/06.资源/01.资源工具-ResourceUtil.md",key:"v-570c35c2",path:"/pages/ResourceUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:35}],headersStr:"介绍 使用",content:'# 介绍\n\nResourceUtil提供了资源快捷读取封装。\n\n\n# 使用\n\nResourceUtil中最核心的方法是getResourceObj，此方法可以根据传入路径是否为绝对路径而返回不同的实现。比如路径是：file:/opt/test，或者/opt/test都会被当作绝对路径，此时调用FileResource来读取数据。如果不满足以上条件，默认调用ClassPathResource读取classpath中的资源或者文件。\n\n同样，此工具类还封装了readBytes和readStr用于快捷读取bytes和字符串。\n\n举个例子，假设我们在classpath下放了一个test.xml，读取就变得非常简单：\n\nString str = ResourceUtil.readUtf8Str("https://doc.hutool.cn/assets/js/test.xml");\n\n\n假设我们的文件存放在src/resources/config目录下，则读取改为：\n\nString str = ResourceUtil.readUtf8Str("https://doc.hutool.cn/assets/js/config/test.xml");\n\n\n> 注意 在IDEA中，新加入文件到src/resources目录下，需要重新import项目，以便在编译时顺利把资源文件拷贝到target目录下。如果提示找不到文件，请去target目录下确认文件是否存在。',normalizedContent:'# 介绍\n\nresourceutil提供了资源快捷读取封装。\n\n\n# 使用\n\nresourceutil中最核心的方法是getresourceobj，此方法可以根据传入路径是否为绝对路径而返回不同的实现。比如路径是：file:/opt/test，或者/opt/test都会被当作绝对路径，此时调用fileresource来读取数据。如果不满足以上条件，默认调用classpathresource读取classpath中的资源或者文件。\n\n同样，此工具类还封装了readbytes和readstr用于快捷读取bytes和字符串。\n\n举个例子，假设我们在classpath下放了一个test.xml，读取就变得非常简单：\n\nstring str = resourceutil.readutf8str("https://doc.hutool.cn/assets/js/test.xml");\n\n\n假设我们的文件存放在src/resources/config目录下，则读取改为：\n\nstring str = resourceutil.readutf8str("https://doc.hutool.cn/assets/js/config/test.xml");\n\n\n> 注意 在idea中，新加入文件到src/resources目录下，需要重新import项目，以便在编译时顺利把资源文件拷贝到target目录下。如果提示找不到文件，请去target目录下确认文件是否存在。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Escape工具-EscapeUtil",frontmatter:{title:"Escape工具-EscapeUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/EscapeUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/03.Escape%E5%B7%A5%E5%85%B7-EscapeUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/03.Escape工具-EscapeUtil.md",key:"v-76c51a8c",path:"/pages/EscapeUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:142}],headersStr:"介绍 方法",content:"# 介绍\n\n转义和反转义工具类Escape / Unescape。escape采用ISO Latin字符集对指定的字符串进行编码。所有的空格符、标点符号、特殊字符以及其他非ASCII字符都将被转化成%xx格式的字符编码(xx等于该字符在字符集表里面的编码的16进制数字)。\n\n此类中的方法对应Javascript中的escape()函数和unescape()函数。\n\n\n# 方法\n\n 1. EscapeUtil.escape Escape编码（Unicode），该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . / 。其他所有的字符都会被转义序列替换。\n\n 2. EscapeUtil.unescape Escape解码。\n\n 3. EscapeUtil.safeUnescape 安全的unescape文本，当文本不是被escape的时候，返回原文。",normalizedContent:"# 介绍\n\n转义和反转义工具类escape / unescape。escape采用iso latin字符集对指定的字符串进行编码。所有的空格符、标点符号、特殊字符以及其他非ascii字符都将被转化成%xx格式的字符编码(xx等于该字符在字符集表里面的编码的16进制数字)。\n\n此类中的方法对应javascript中的escape()函数和unescape()函数。\n\n\n# 方法\n\n 1. escapeutil.escape escape编码（unicode），该方法不会对 ascii 字母和数字进行编码，也不会对下面这些 ascii 标点符号进行编码： * @ - _ + . / 。其他所有的字符都会被转义序列替换。\n\n 2. escapeutil.unescape escape解码。\n\n 3. escapeutil.safeunescape 安全的unescape文本，当文本不是被escape的时候，返回原文。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"字符串工具-StrUtil",frontmatter:{title:"字符串工具-StrUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/StrUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/01.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A5%E5%85%B7-StrUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/01.字符串工具-StrUtil.md",key:"v-7566f2b5",path:"/pages/StrUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:118},{level:3,title:"1. hasBlank、hasEmpty方法",slug:"_1-hasblank、hasempty方法",normalizedTitle:"1. hasblank、hasempty方法",charIndex:205},{level:3,title:"2. removePrefix、removeSuffix方法",slug:"_2-removeprefix、removesuffix方法",normalizedTitle:"2. removeprefix、removesuffix方法",charIndex:364},{level:3,title:"3. sub方法",slug:"_3-sub方法",normalizedTitle:"3. sub方法",charIndex:586},{level:3,title:"4. str、bytes方法",slug:"_4-str、bytes方法",normalizedTitle:"4. str、bytes方法",charIndex:1185},{level:3,title:"5. format方法",slug:"_5-format方法",normalizedTitle:"5. format方法",charIndex:1388},{level:3,title:"6. 定义的一些常量",slug:"_6-定义的一些常量",normalizedTitle:"6. 定义的一些常量",charIndex:1653}],headersStr:"由来 方法 1. hasBlank、hasEmpty方法 2. removePrefix、removeSuffix方法 3. sub方法 4. str、bytes方法 5. format方法 6. 定义的一些常量",content:'# 由来\n\n这个工具的用处类似于Apache Commons Lang中的StringUtil，之所以使用StrUtil而不是使用StringUtil是因为前者更短，而且Str这个简写我想已经深入人心了，大家都知道是字符串的意思。常用的方法例如isBlank、isNotBlank、isEmpty、isNotEmpty这些我就不做介绍了，判断字符串是否为空，下面我说几个比较好用的功能。\n\n\n# 方法\n\n\n# 1. hasBlank、hasEmpty方法\n\n就是给定一些字符串，如果一旦有空的就返回true，常用于判断好多字段是否有空的（例如web表单数据）。\n\n这两个方法的区别是hasEmpty只判断是否为null或者空字符串（""），hasBlank则会把不可见字符也算做空，isEmpty和isBlank同理。\n\n\n# 2. removePrefix、removeSuffix方法\n\n这两个是去掉字符串的前缀后缀的，例如去个文件名的扩展名啥。\n\nString fileName = StrUtil.removeSuffix("pretty_girl.jpg"/*tpa=https://doc.hutool.cn/assets/js/pretty_girl.jpg*/, ".jpg")  //fileName -> pretty_girl\n\n\n还有忽略大小写的removePrefixIgnoreCase和removeSuffixIgnoreCase都比较实用。\n\n\n# 3. sub方法\n\n不得不提一下这个方法，有人说String有了subString你还写它干啥，我想说subString方法越界啥的都会报异常，你还得自己判断，难受死了，我把各种情况判断都加进来了，而且index的位置还支持负数哦，-1表示最后一个字符前（这个思想来自于Python，如果学过Python的应该会很喜欢的），还有就是如果不小心把第一个位置和第二个位置搞反了，也会自动修正（例如想截取第4个和第2个字符之间的部分也是可以的哦~） 举个栗子\n\nString str = "abcdefgh";\nString strSub1 = StrUtil.sub(str, 2, 3); //strSub1 -> c\nString strSub2 = StrUtil.sub(str, 2, -3); //strSub2 -> cde\nString strSub3 = StrUtil.sub(str, 3, 2); //strSub2 -> c\n\n\n需要注意的是，-1表示最后一个字符，但是因为sub方法的结束index是不包含的，因此传-1最后一个字符是取不到的：\n\nString str = "abcdefgh";\nString strSub1 = StrUtil.sub(str, 2, -1); // cdefg\n\n\n如果想截取后半段，可以使用StrUtil.subSuf方法。\n\n\n# 4. str、bytes方法\n\n好吧，我承认把String.getByte(String charsetName)方法封装在这里了，原生的String.getByte()这个方法太坑了，使用系统编码，经常会有人跳进来导致乱码问题，所以我就加了这两个方法强制指定字符集了，包了个try抛出一个运行时异常，省的我得在我业务代码里处理那个恶心的UnsupportedEncodingException。\n\n\n# 5. format方法\n\n我会告诉你这是我最引以为豪的方法吗？灵感来自slf4j，可以使用字符串模板代替字符串拼接，我也自己实现了一个，而且变量的标识符都一样，神马叫无缝兼容~~来，上栗子（吃多了上火吧……）\n\nString template = "{}爱{}，就像老鼠爱大米";\nString str = StrUtil.format(template, "我", "你"); //str -> 我爱你，就像老鼠爱大米\n\n\n参数我定义成了Object类型，如果传别的类型的也可以，会自动调用toString()方法的。\n\n\n# 6. 定义的一些常量\n\n为了方便，我定义了一些比较常见的字符串常量在里面，像点、空串、换行符等等，还有HTML中的一些转义字符。\n\n更多方法请参阅API文档。',normalizedContent:'# 由来\n\n这个工具的用处类似于apache commons lang中的stringutil，之所以使用strutil而不是使用stringutil是因为前者更短，而且str这个简写我想已经深入人心了，大家都知道是字符串的意思。常用的方法例如isblank、isnotblank、isempty、isnotempty这些我就不做介绍了，判断字符串是否为空，下面我说几个比较好用的功能。\n\n\n# 方法\n\n\n# 1. hasblank、hasempty方法\n\n就是给定一些字符串，如果一旦有空的就返回true，常用于判断好多字段是否有空的（例如web表单数据）。\n\n这两个方法的区别是hasempty只判断是否为null或者空字符串（""），hasblank则会把不可见字符也算做空，isempty和isblank同理。\n\n\n# 2. removeprefix、removesuffix方法\n\n这两个是去掉字符串的前缀后缀的，例如去个文件名的扩展名啥。\n\nstring filename = strutil.removesuffix("pretty_girl.jpg"/*tpa=https://doc.hutool.cn/assets/js/pretty_girl.jpg*/, ".jpg")  //filename -> pretty_girl\n\n\n还有忽略大小写的removeprefixignorecase和removesuffixignorecase都比较实用。\n\n\n# 3. sub方法\n\n不得不提一下这个方法，有人说string有了substring你还写它干啥，我想说substring方法越界啥的都会报异常，你还得自己判断，难受死了，我把各种情况判断都加进来了，而且index的位置还支持负数哦，-1表示最后一个字符前（这个思想来自于python，如果学过python的应该会很喜欢的），还有就是如果不小心把第一个位置和第二个位置搞反了，也会自动修正（例如想截取第4个和第2个字符之间的部分也是可以的哦~） 举个栗子\n\nstring str = "abcdefgh";\nstring strsub1 = strutil.sub(str, 2, 3); //strsub1 -> c\nstring strsub2 = strutil.sub(str, 2, -3); //strsub2 -> cde\nstring strsub3 = strutil.sub(str, 3, 2); //strsub2 -> c\n\n\n需要注意的是，-1表示最后一个字符，但是因为sub方法的结束index是不包含的，因此传-1最后一个字符是取不到的：\n\nstring str = "abcdefgh";\nstring strsub1 = strutil.sub(str, 2, -1); // cdefg\n\n\n如果想截取后半段，可以使用strutil.subsuf方法。\n\n\n# 4. str、bytes方法\n\n好吧，我承认把string.getbyte(string charsetname)方法封装在这里了，原生的string.getbyte()这个方法太坑了，使用系统编码，经常会有人跳进来导致乱码问题，所以我就加了这两个方法强制指定字符集了，包了个try抛出一个运行时异常，省的我得在我业务代码里处理那个恶心的unsupportedencodingexception。\n\n\n# 5. format方法\n\n我会告诉你这是我最引以为豪的方法吗？灵感来自slf4j，可以使用字符串模板代替字符串拼接，我也自己实现了一个，而且变量的标识符都一样，神马叫无缝兼容~~来，上栗子（吃多了上火吧……）\n\nstring template = "{}爱{}，就像老鼠爱大米";\nstring str = strutil.format(template, "我", "你"); //str -> 我爱你，就像老鼠爱大米\n\n\n参数我定义成了object类型，如果传别的类型的也可以，会自动调用tostring()方法的。\n\n\n# 6. 定义的一些常量\n\n为了方便，我定义了一些比较常见的字符串常量在里面，像点、空串、换行符等等，还有html中的一些转义字符。\n\n更多方法请参阅api文档。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Hash算法-HashUtil",frontmatter:{title:"Hash算法-HashUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/HashUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/04.Hash%E7%AE%97%E6%B3%95-HashUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/04.Hash算法-HashUtil.md",key:"v-5899c3e6",path:"/pages/HashUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:51}],headersStr:"介绍 方法",content:"# 介绍\n\nHashUtil其实是一个hash算法的集合，此工具类中融合了各种hash算法。\n\n\n# 方法\n\n这些算法包括：\n\n 1.  additiveHash 加法hash\n 2.  rotatingHash 旋转hash\n 3.  oneByOneHash 一次一个hash\n 4.  bernstein Bernstein's hash\n 5.  universal Universal Hashing\n 6.  zobrist Zobrist Hashing\n 7.  fnvHash 改进的32位FNV算法\n 8.  intHash Thomas Wang的算法，整数hash\n 9.  rsHash RS算法hash\n 10. jsHash JS算法\n 11. pjwHash PJW算法\n 12. elfHash ELF算法\n 13. bkdrHash BKDR算法\n 14. sdbmHash SDBM算法\n 15. djbHash DJB算法\n 16. dekHash DEK算法\n 17. apHash AP算法\n 18. tianlHash TianL Hash算法\n 19. javaDefaultHash JAVA自己带的算法\n 20. mixHash 混合hash算法，输出64位的值",normalizedContent:"# 介绍\n\nhashutil其实是一个hash算法的集合，此工具类中融合了各种hash算法。\n\n\n# 方法\n\n这些算法包括：\n\n 1.  additivehash 加法hash\n 2.  rotatinghash 旋转hash\n 3.  onebyonehash 一次一个hash\n 4.  bernstein bernstein's hash\n 5.  universal universal hashing\n 6.  zobrist zobrist hashing\n 7.  fnvhash 改进的32位fnv算法\n 8.  inthash thomas wang的算法，整数hash\n 9.  rshash rs算法hash\n 10. jshash js算法\n 11. pjwhash pjw算法\n 12. elfhash elf算法\n 13. bkdrhash bkdr算法\n 14. sdbmhash sdbm算法\n 15. djbhash djb算法\n 16. dekhash dek算法\n 17. aphash ap算法\n 18. tianlhash tianl hash算法\n 19. javadefaulthash java自己带的算法\n 20. mixhash 混合hash算法，输出64位的值",charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"XML工具-XmlUtil",frontmatter:{title:"XML工具-XmlUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/XmlUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/06.XML%E5%B7%A5%E5%85%B7-XmlUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/06.XML工具-XmlUtil.md",key:"v-3c5c96e8",path:"/pages/XmlUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:145},{level:3,title:"读取XML",slug:"读取xml",normalizedTitle:"读取xml",charIndex:152},{level:3,title:"写XML",slug:"写xml",normalizedTitle:"写xml",charIndex:244},{level:3,title:"创建XML",slug:"创建xml",normalizedTitle:"创建xml",charIndex:317},{level:3,title:"XML操作",slug:"xml操作",normalizedTitle:"xml操作",charIndex:418},{level:3,title:"XML与对象转换",slug:"xml与对象转换",normalizedTitle:"xml与对象转换",charIndex:652},{level:3,title:"Xpath操作",slug:"xpath操作",normalizedTitle:"xpath操作",charIndex:827},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1365}],headersStr:"由来 使用 读取XML 写XML 创建XML XML操作 XML与对象转换 Xpath操作 总结",content:'# 由来\n\n在日常编码中，我们接触最多的除了JSON外，就是XML格式了，一般而言，我们首先想到的是引入Dom4j包，却不知JDK已经封装有XML解析和构建工具：w3c dom。但是由于这个API操作比较繁琐，因此Hutool中提供了XmlUtil简化XML的创建、读和写的过程。\n\n\n# 使用\n\n\n# 读取XML\n\n读取XML分为两个方法：\n\n * XmlUtil.readXML 读取XML文件\n * XmlUtil.parseXml 解析XML字符串为Document对象\n\n\n# 写XML\n\n * XmlUtil.toStr 将XML文档转换为String\n * XmlUtil.toFile 将XML文档写入到文件\n\n\n# 创建XML\n\n * XmlUtil.createXml 创建XML文档, 创建的XML默认是utf8编码，修改编码的过程是在toStr和toFile方法里，即XML在转为文本的时候才定义编码。\n\n\n# XML操作\n\n通过以下工具方法，可以完成基本的节点读取操作。\n\n * XmlUtil.cleanInvalid 去除XML文本中的无效字符\n * XmlUtil.getElements 根据节点名获得子节点列表\n * XmlUtil.getElement 根据节点名获得第一个子节点\n * XmlUtil.elementText 根据节点名获得第一个子节点的文本值\n * XmlUtil.transElements 将NodeList转换为Element列表\n\n\n# XML与对象转换\n\n * writeObjectAsXml 将可序列化的对象转换为XML写入文件，已经存在的文件将被覆盖。\n * readObjectFromXml 从XML中读取对象。\n\n> 注意 这两个方法严重依赖JDK的XMLEncoder和XMLDecoder，生成和解析必须成对存在（遵循固定格式），普通的XML转Bean会报错。\n\n\n# Xpath操作\n\nXpath的更多介绍请看文章：https://www.ibm.com/developerworks/cn/xml/x-javaxpathapi.html\n\n * createXPath 创建XPath\n * getByXPath 通过XPath方式读取XML节点等信息\n\n栗子：\n\n<?xml version="1.0" encoding="utf-8"?>\n\n<returnsms> \n  <returnstatus>Success（成功）</returnstatus>  \n  <message>ok</message>  \n  <remainpoint>1490</remainpoint>  \n  <taskID>885</taskID>  \n  <successCounts>1</successCounts> \n</returnsms>\n\n\nDocument docResult=XmlUtil.readXML(xmlFile);\n//结果为“ok”\nObject value = XmlUtil.getByXPath("//returnsms/message", docResult, XPathConstants.STRING);\n\n\n\n# 总结\n\nXmlUtil只是w3c dom的简单工具化封装，减少操作dom的难度，如果项目对XML依赖较大，依旧推荐Dom4j框架。',normalizedContent:'# 由来\n\n在日常编码中，我们接触最多的除了json外，就是xml格式了，一般而言，我们首先想到的是引入dom4j包，却不知jdk已经封装有xml解析和构建工具：w3c dom。但是由于这个api操作比较繁琐，因此hutool中提供了xmlutil简化xml的创建、读和写的过程。\n\n\n# 使用\n\n\n# 读取xml\n\n读取xml分为两个方法：\n\n * xmlutil.readxml 读取xml文件\n * xmlutil.parsexml 解析xml字符串为document对象\n\n\n# 写xml\n\n * xmlutil.tostr 将xml文档转换为string\n * xmlutil.tofile 将xml文档写入到文件\n\n\n# 创建xml\n\n * xmlutil.createxml 创建xml文档, 创建的xml默认是utf8编码，修改编码的过程是在tostr和tofile方法里，即xml在转为文本的时候才定义编码。\n\n\n# xml操作\n\n通过以下工具方法，可以完成基本的节点读取操作。\n\n * xmlutil.cleaninvalid 去除xml文本中的无效字符\n * xmlutil.getelements 根据节点名获得子节点列表\n * xmlutil.getelement 根据节点名获得第一个子节点\n * xmlutil.elementtext 根据节点名获得第一个子节点的文本值\n * xmlutil.transelements 将nodelist转换为element列表\n\n\n# xml与对象转换\n\n * writeobjectasxml 将可序列化的对象转换为xml写入文件，已经存在的文件将被覆盖。\n * readobjectfromxml 从xml中读取对象。\n\n> 注意 这两个方法严重依赖jdk的xmlencoder和xmldecoder，生成和解析必须成对存在（遵循固定格式），普通的xml转bean会报错。\n\n\n# xpath操作\n\nxpath的更多介绍请看文章：https://www.ibm.com/developerworks/cn/xml/x-javaxpathapi.html\n\n * createxpath 创建xpath\n * getbyxpath 通过xpath方式读取xml节点等信息\n\n栗子：\n\n<?xml version="1.0" encoding="utf-8"?>\n\n<returnsms> \n  <returnstatus>success（成功）</returnstatus>  \n  <message>ok</message>  \n  <remainpoint>1490</remainpoint>  \n  <taskid>885</taskid>  \n  <successcounts>1</successcounts> \n</returnsms>\n\n\ndocument docresult=xmlutil.readxml(xmlfile);\n//结果为“ok”\nobject value = xmlutil.getbyxpath("//returnsms/message", docresult, xpathconstants.string);\n\n\n\n# 总结\n\nxmlutil只是w3c dom的简单工具化封装，减少操作dom的难度，如果项目对xml依赖较大，依旧推荐dom4j框架。',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"支持泛型的克隆接口和克隆类",frontmatter:{title:"支持泛型的克隆接口和克隆类",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Cloneable/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/01.%E5%85%8B%E9%9A%86/01.%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%85%8B%E9%9A%86%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%8B%E9%9A%86%E7%B1%BB.html",relativePath:"01.指南/02.核心（Hutool-core）/01.克隆/01.支持泛型的克隆接口和克隆类.md",key:"v-4e0379ef",path:"/pages/Cloneable/",headers:[{level:2,title:"我们解决什么问题",slug:"我们解决什么问题",normalizedTitle:"我们解决什么问题",charIndex:2},{level:2,title:"泛型克隆接口",slug:"泛型克隆接口",normalizedTitle:"泛型克隆接口",charIndex:200},{level:2,title:"泛型克隆类",slug:"泛型克隆类",normalizedTitle:"泛型克隆类",charIndex:645},{level:2,title:"深克隆",slug:"深克隆",normalizedTitle:"深克隆",charIndex:1131}],headersStr:"我们解决什么问题 泛型克隆接口 泛型克隆类 深克隆",content:'# 我们解决什么问题\n\n我们知道，JDK中的Cloneable接口只是一个空接口，并没有定义成员，它存在的意义仅仅是指明一个类的实例化对象支持位复制（就是对象克隆），如果不实现这个类，调用对象的clone()方法就会抛出CloneNotSupportedException异常。而且，因为clone()方法在Object对象中，返回值也是Object对象，因此克隆后我们需要自己强转下类型。\n\n\n# 泛型克隆接口\n\n因此，cn.hutool.core.clone.Cloneable接口应运而生。此接口定义了一个返回泛型的成员方法，这样，实现此接口后会提示必须实现一个public的clone方法，调用父类clone方法即可：\n\n/**\n * 猫猫类，使用实现Cloneable方式\n * @author Looly\n *\n */\nprivate static class Cat implements Cloneable<Cat>{\n\tprivate String name = "miaomiao";\n\tprivate int age = 2;\n\t\n\t@Override\n\tpublic Cat clone() {\n\t\ttry {\n\t\t\treturn (Cat) super.clone();\n\t\t} catch (CloneNotSupportedException e) {\n\t\t\tthrow new CloneRuntimeException(e);\n\t\t}\n\t}\n}\n\n\n\n# 泛型克隆类\n\n但是实现此接口依旧有不方便之处，就是必须自己实现一个public类型的clone()方法，还要调用父类（Object）的clone方法并处理异常。于是cn.hutool.clone.CloneSupport类产生，这个类帮我们实现了上面的clone方法，因此只要继承此类，不用写任何代码即可使用clone()方法：\n\n/**\n * 狗狗类，用于继承CloneSupport类\n * @author Looly\n *\n */\nprivate static class Dog extends CloneSupport<Dog>{\n\tprivate String name = "wangwang";\n\tprivate int age = 3;\n}\n\n\n当然，使用CloneSupport的前提是你没有继承任何的类，谁让Java不支持多重继承呢（你依旧可以让父类继承这个类，如果可以的话）。如果没办法继承类，那实现cn.hutool.clone.Cloneable也是不错的主意，因此hutool提供了这两种方式，任选其一，在便捷和灵活上都提供了支持。\n\n\n# 深克隆\n\n我们知道实现Cloneable接口后克隆的对象是浅克隆，要想实现深克隆，请使用：\n\nObjectUtil.cloneByStream(obj)\n\n\n前提是对象必须实现Serializable接口。\n\nObjectUtil同样提供一些静态方法：clone(obj)、cloneIfPossible(obj) 用于简化克隆调用，详细的说明请查看核心类的相关文档。',normalizedContent:'# 我们解决什么问题\n\n我们知道，jdk中的cloneable接口只是一个空接口，并没有定义成员，它存在的意义仅仅是指明一个类的实例化对象支持位复制（就是对象克隆），如果不实现这个类，调用对象的clone()方法就会抛出clonenotsupportedexception异常。而且，因为clone()方法在object对象中，返回值也是object对象，因此克隆后我们需要自己强转下类型。\n\n\n# 泛型克隆接口\n\n因此，cn.hutool.core.clone.cloneable接口应运而生。此接口定义了一个返回泛型的成员方法，这样，实现此接口后会提示必须实现一个public的clone方法，调用父类clone方法即可：\n\n/**\n * 猫猫类，使用实现cloneable方式\n * @author looly\n *\n */\nprivate static class cat implements cloneable<cat>{\n\tprivate string name = "miaomiao";\n\tprivate int age = 2;\n\t\n\t@override\n\tpublic cat clone() {\n\t\ttry {\n\t\t\treturn (cat) super.clone();\n\t\t} catch (clonenotsupportedexception e) {\n\t\t\tthrow new cloneruntimeexception(e);\n\t\t}\n\t}\n}\n\n\n\n# 泛型克隆类\n\n但是实现此接口依旧有不方便之处，就是必须自己实现一个public类型的clone()方法，还要调用父类（object）的clone方法并处理异常。于是cn.hutool.clone.clonesupport类产生，这个类帮我们实现了上面的clone方法，因此只要继承此类，不用写任何代码即可使用clone()方法：\n\n/**\n * 狗狗类，用于继承clonesupport类\n * @author looly\n *\n */\nprivate static class dog extends clonesupport<dog>{\n\tprivate string name = "wangwang";\n\tprivate int age = 3;\n}\n\n\n当然，使用clonesupport的前提是你没有继承任何的类，谁让java不支持多重继承呢（你依旧可以让父类继承这个类，如果可以的话）。如果没办法继承类，那实现cn.hutool.clone.cloneable也是不错的主意，因此hutool提供了这两种方式，任选其一，在便捷和灵活上都提供了支持。\n\n\n# 深克隆\n\n我们知道实现cloneable接口后克隆的对象是浅克隆，要想实现深克隆，请使用：\n\nobjectutil.clonebystream(obj)\n\n\n前提是对象必须实现serializable接口。\n\nobjectutil同样提供一些静态方法：clone(obj)、cloneifpossible(obj) 用于简化克隆调用，详细的说明请查看核心类的相关文档。',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"对象工具-ObjectUtil",frontmatter:{title:"对象工具-ObjectUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ObjectUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/07.%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%85%B7-ObjectUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/07.对象工具-ObjectUtil.md",key:"v-6ecbeb40",path:"/pages/ObjectUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:18},{level:3,title:"默认值",slug:"默认值",normalizedTitle:"默认值",charIndex:84},{level:3,title:"ObjectUtil.equal",slug:"objectutil-equal",normalizedTitle:"objectutil.equal",charIndex:398},{level:3,title:"ObjectUtil.length",slug:"objectutil-length",normalizedTitle:"objectutil.length",charIndex:570},{level:3,title:"ObjectUtil.contains",slug:"objectutil-contains",normalizedTitle:"objectutil.contains",charIndex:970},{level:3,title:"判断是否为null",slug:"判断是否为null",normalizedTitle:"判断是否为null",charIndex:1189},{level:3,title:"克隆",slug:"克隆",normalizedTitle:"克隆",charIndex:1314},{level:3,title:"序列化和反序列化",slug:"序列化和反序列化",normalizedTitle:"序列化和反序列化",charIndex:1703},{level:3,title:"判断基本类型",slug:"判断基本类型",normalizedTitle:"判断基本类型",charIndex:1769}],headersStr:"由来 方法 默认值 ObjectUtil.equal ObjectUtil.length ObjectUtil.contains 判断是否为null 克隆 序列化和反序列化 判断基本类型",content:'# 由来\n\n在我们的日常使用中，有些方法是针对Object通用的，这些方法不区分何种对象，针对这些方法，Hutool封装为ObjectUtil。\n\n\n# 方法\n\n\n# 默认值\n\n借助于lambda表达式，ObjectUtil可以完成判断给定的值是否为null，不为null执行特定逻辑的功能。\n\nfinal String dateStr = null;\n\n// 此处判断如果dateStr为null，则调用`Instant.now()`，不为null则执行`DateUtil.parse`\nInstant result1 = ObjectUtil.defaultIfNull(dateStr,\n\t\t() -> DateUtil.parse(dateStr, DatePattern.NORM_DATETIME_PATTERN).toInstant(), Instant.now());\n\n\n\n# ObjectUtil.equal\n\n比较两个对象是否相等，相等需满足以下条件之一：\n\n 1. obj1 == null && obj2 == null\n 2. obj1.equals(obj2)\n\nObject a = null;\nObject b = null;\n\n// true\nObjectUtil.equals(a, b);\n\n\n\n# ObjectUtil.length\n\n计算对象长度，如果是字符串调用其length方法，集合类调用其size方法，数组调用其length属性，其他可遍历对象遍历计算长度。\n\n支持的类型包括：\n\n * CharSequence\n * Collection\n * Map\n * Iterator\n * Enumeration\n * Array\n\nint[] array = new int[]{1,2,3,4,5};\n\n// 5\nint length = ObjectUtil.length(array);\n\nMap<String, String> map = new HashMap<>();\nmap.put("a", "a1");\nmap.put("b", "b1");\nmap.put("c", "c1");\n\n// 3\nlength = ObjectUtil.length(map);\n\n\n\n# ObjectUtil.contains\n\n对象中是否包含元素。\n\n支持的对象类型包括：\n\n * String\n * Collection\n * Map\n * Iterator\n * Enumeration\n * Array\n\nint[] array = new int[]{1,2,3,4,5};\n\n// true\nfinal boolean contains = ObjectUtil.contains(array, 1);\n\n\n\n# 判断是否为null\n\n * ObjectUtil.isNull\n * ObjectUtil.isNotNull\n\n> 注意：此方法不能判断对象中字段为空的情况，如果需要检查Bean对象中字段是否全空，请使用BeanUtil.isEmpty。\n\n\n# 克隆\n\n * ObjectUtil.clone 克隆对象，如果对象实现Cloneable接口，调用其clone方法，如果实现Serializable接口，执行深度克隆，否则返回null。\n\nclass Obj extends CloneSupport<Obj> {\n\tpublic String doSomeThing() {\n\t\treturn "OK";\n\t}\n}\n\n\nObj obj = new Obj();\nObj obj2 = ObjectUtil.clone(obj);\n\n// OK\nobj2.doSomeThing();\n\n\n * ObjectUtil.cloneIfPossible 返回克隆后的对象，如果克隆失败，返回原对象\n\n * ObjectUtil.cloneByStream 序列化后拷贝流的方式克隆，对象必须实现Serializable接口\n\n\n# 序列化和反序列化\n\n * serialize 序列化，调用JDK序列化\n * deserialize 反序列化，调用JDK\n\n\n# 判断基本类型\n\nObjectUtil.isBasicType 判断是否为基本类型，包括包装类型和原始类型。\n\n包装类型：\n\n * Boolean\n * Byte\n * Character\n * Double\n * Float\n * Integer\n * Long\n * Short\n\n原始类型：\n\n * boolean\n * byte\n * char\n * double\n * float\n * int\n * long\n * short\n\nint a = 1;\n\n// true\nfinal boolean basicType = ObjectUtil.isBasicType(a);\n',normalizedContent:'# 由来\n\n在我们的日常使用中，有些方法是针对object通用的，这些方法不区分何种对象，针对这些方法，hutool封装为objectutil。\n\n\n# 方法\n\n\n# 默认值\n\n借助于lambda表达式，objectutil可以完成判断给定的值是否为null，不为null执行特定逻辑的功能。\n\nfinal string datestr = null;\n\n// 此处判断如果datestr为null，则调用`instant.now()`，不为null则执行`dateutil.parse`\ninstant result1 = objectutil.defaultifnull(datestr,\n\t\t() -> dateutil.parse(datestr, datepattern.norm_datetime_pattern).toinstant(), instant.now());\n\n\n\n# objectutil.equal\n\n比较两个对象是否相等，相等需满足以下条件之一：\n\n 1. obj1 == null && obj2 == null\n 2. obj1.equals(obj2)\n\nobject a = null;\nobject b = null;\n\n// true\nobjectutil.equals(a, b);\n\n\n\n# objectutil.length\n\n计算对象长度，如果是字符串调用其length方法，集合类调用其size方法，数组调用其length属性，其他可遍历对象遍历计算长度。\n\n支持的类型包括：\n\n * charsequence\n * collection\n * map\n * iterator\n * enumeration\n * array\n\nint[] array = new int[]{1,2,3,4,5};\n\n// 5\nint length = objectutil.length(array);\n\nmap<string, string> map = new hashmap<>();\nmap.put("a", "a1");\nmap.put("b", "b1");\nmap.put("c", "c1");\n\n// 3\nlength = objectutil.length(map);\n\n\n\n# objectutil.contains\n\n对象中是否包含元素。\n\n支持的对象类型包括：\n\n * string\n * collection\n * map\n * iterator\n * enumeration\n * array\n\nint[] array = new int[]{1,2,3,4,5};\n\n// true\nfinal boolean contains = objectutil.contains(array, 1);\n\n\n\n# 判断是否为null\n\n * objectutil.isnull\n * objectutil.isnotnull\n\n> 注意：此方法不能判断对象中字段为空的情况，如果需要检查bean对象中字段是否全空，请使用beanutil.isempty。\n\n\n# 克隆\n\n * objectutil.clone 克隆对象，如果对象实现cloneable接口，调用其clone方法，如果实现serializable接口，执行深度克隆，否则返回null。\n\nclass obj extends clonesupport<obj> {\n\tpublic string dosomething() {\n\t\treturn "ok";\n\t}\n}\n\n\nobj obj = new obj();\nobj obj2 = objectutil.clone(obj);\n\n// ok\nobj2.dosomething();\n\n\n * objectutil.cloneifpossible 返回克隆后的对象，如果克隆失败，返回原对象\n\n * objectutil.clonebystream 序列化后拷贝流的方式克隆，对象必须实现serializable接口\n\n\n# 序列化和反序列化\n\n * serialize 序列化，调用jdk序列化\n * deserialize 反序列化，调用jdk\n\n\n# 判断基本类型\n\nobjectutil.isbasictype 判断是否为基本类型，包括包装类型和原始类型。\n\n包装类型：\n\n * boolean\n * byte\n * character\n * double\n * float\n * integer\n * long\n * short\n\n原始类型：\n\n * boolean\n * byte\n * char\n * double\n * float\n * int\n * long\n * short\n\nint a = 1;\n\n// true\nfinal boolean basictype = objectutil.isbasictype(a);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"URL工具-URLUtil",frontmatter:{title:"URL工具-URLUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/URLUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/05.URL%E5%B7%A5%E5%85%B7-URLUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/05.URL工具-URLUtil.md",key:"v-08a66d6c",path:"/pages/URLUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:128},{level:3,title:"获取URL对象",slug:"获取url对象",normalizedTitle:"获取url对象",charIndex:135},{level:3,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:246}],headersStr:"介绍 方法 获取URL对象 其它",content:'# 介绍\n\nURL（Uniform Resource Locator）中文名为统一资源定位符，有时也被俗称为网页地址。表示互联网上的资源，如网页或者FTP地址。在Java中，也可以使用URL表示Classpath中的资源（Resource）地址。\n\n\n# 方法\n\n\n# 获取URL对象\n\n * URLUtil.url 通过一个字符串形式的URL地址创建对象\n * URLUtil.getURL 主要获得ClassPath下资源的URL，方便读取Classpath下的配置文件等信息。\n\n\n# 其它\n\n * URLUtil.normalize 标准化URL链接。对于不带http://头的地址做简单补全。\n\nString url = "http://www.hutool.cn//aaa/bbb";\n// 结果为：http://www.hutool.cn/aaa/bbb\nString normalize = URLUtil.normalize(url);\n\nurl = "http://www.hutool.cn//aaa/////bbb?a=1&b=2";\n// 结果为：http://www.hutool.cn/aaa/bbb?a=1&b=2\nnormalize = URLUtil.normalize(url);\n\n\n * URLUtil.encode 封装URLEncoder.encode，将需要转换的内容（ASCII码形式之外的内容），用十六进制表示法转换出来，并在之前加上%开头。\n\nString body = "366466 - 副本.jpg";\n// 结果为：366466%20-%20%E5%89%AF%E6%9C%AC.jpg\nString encode = URLUtil.encode(body);\n\n\n * URLUtil.decode 封装URLDecoder.decode，将%开头的16进制表示的内容解码。\n * URLUtil.getPath 获得path部分 URI -> http://www.aaa.bbb/search?scope=ccc&q=ddd PATH -> /search\n * URLUtil.toURI 转URL或URL字符串为URI。',normalizedContent:'# 介绍\n\nurl（uniform resource locator）中文名为统一资源定位符，有时也被俗称为网页地址。表示互联网上的资源，如网页或者ftp地址。在java中，也可以使用url表示classpath中的资源（resource）地址。\n\n\n# 方法\n\n\n# 获取url对象\n\n * urlutil.url 通过一个字符串形式的url地址创建对象\n * urlutil.geturl 主要获得classpath下资源的url，方便读取classpath下的配置文件等信息。\n\n\n# 其它\n\n * urlutil.normalize 标准化url链接。对于不带http://头的地址做简单补全。\n\nstring url = "http://www.hutool.cn//aaa/bbb";\n// 结果为：http://www.hutool.cn/aaa/bbb\nstring normalize = urlutil.normalize(url);\n\nurl = "http://www.hutool.cn//aaa/////bbb?a=1&b=2";\n// 结果为：http://www.hutool.cn/aaa/bbb?a=1&b=2\nnormalize = urlutil.normalize(url);\n\n\n * urlutil.encode 封装urlencoder.encode，将需要转换的内容（ascii码形式之外的内容），用十六进制表示法转换出来，并在之前加上%开头。\n\nstring body = "366466 - 副本.jpg";\n// 结果为：366466%20-%20%e5%89%af%e6%9c%ac.jpg\nstring encode = urlutil.encode(body);\n\n\n * urlutil.decode 封装urldecoder.decode，将%开头的16进制表示的内容解码。\n * urlutil.getpath 获得path部分 uri -> http://www.aaa.bbb/search?scope=ccc&q=ddd path -> /search\n * urlutil.touri 转url或url字符串为uri。',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"ClassPath资源访问-ClassPathResource",frontmatter:{title:"ClassPath资源访问-ClassPathResource",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ClassPathResource/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/04.IO%E6%B5%81%E7%9B%B8%E5%85%B3/06.%E8%B5%84%E6%BA%90/02.ClassPath%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE-ClassPathResource.html",relativePath:"01.指南/02.核心（Hutool-core）/04.IO流相关/06.资源/02.ClassPath资源访问-ClassPathResource.md",key:"v-4ec1d49e",path:"/pages/ClassPathResource/",headers:[{level:2,title:"什么是ClassPath",slug:"什么是classpath",normalizedTitle:"什么是classpath",charIndex:2},{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:230},{level:2,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:473}],headersStr:"什么是ClassPath 由来 封装",content:'# 什么是ClassPath\n\n简单说来ClassPath就是查找class文件的路径，在Tomcat等容器下，ClassPath一般是WEB-INF/classes，在普通java程序中，我们可以通过定义-cp或者-classpath参数来定义查找class文件的路径，这些路径就是ClassPath。\n\n为了项目方便，我们定义的配置文件肯定不能使用绝对路径，所以需要使用相对路径，这时候最好的办法就是把配置文件和class文件放在一起，便于查找。\n\n\n# 由来\n\n在Java编码过程中，我们常常希望读取项目内的配置文件，按照Maven的习惯，这些文件一般放在项目的src/main/resources下，读取的时候使用：\n\nString path = "config.properties";\nInputStream in = this.class.getResource(path).openStream();\n\n\n使用当前类来获得资源其实就是使用当前类的类加载器获取资源，最后openStream()方法获取输入流来读取文件流。\n\n\n# 封装\n\n面对这种复杂的读取操作，我们封装了ClassPathResource类来简化这种资源的读取：\n\nClassPathResource resource = new ClassPathResource("test.properties");\nProperties properties = new Properties();\nproperties.load(resource.getStream());\n\nConsole.log("Properties: {}", properties);\n\n\n这样就大大简化了ClassPath中资源的读取。\n\n> Hutool提供针对properties的封装类Props，同时提供更加强大的配置文件Setting类，这两个类已经针对ClassPath做过相应封装，可以以更加便捷的方式读取配置文件。相关文档请参阅Hutool-setting章节',normalizedContent:'# 什么是classpath\n\n简单说来classpath就是查找class文件的路径，在tomcat等容器下，classpath一般是web-inf/classes，在普通java程序中，我们可以通过定义-cp或者-classpath参数来定义查找class文件的路径，这些路径就是classpath。\n\n为了项目方便，我们定义的配置文件肯定不能使用绝对路径，所以需要使用相对路径，这时候最好的办法就是把配置文件和class文件放在一起，便于查找。\n\n\n# 由来\n\n在java编码过程中，我们常常希望读取项目内的配置文件，按照maven的习惯，这些文件一般放在项目的src/main/resources下，读取的时候使用：\n\nstring path = "config.properties";\ninputstream in = this.class.getresource(path).openstream();\n\n\n使用当前类来获得资源其实就是使用当前类的类加载器获取资源，最后openstream()方法获取输入流来读取文件流。\n\n\n# 封装\n\n面对这种复杂的读取操作，我们封装了classpathresource类来简化这种资源的读取：\n\nclasspathresource resource = new classpathresource("test.properties");\nproperties properties = new properties();\nproperties.load(resource.getstream());\n\nconsole.log("properties: {}", properties);\n\n\n这样就大大简化了classpath中资源的读取。\n\n> hutool提供针对properties的封装类props，同时提供更加强大的配置文件setting类，这两个类已经针对classpath做过相应封装，可以以更加便捷的方式读取配置文件。相关文档请参阅hutool-setting章节',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"反射工具-ReflectUtil",frontmatter:{title:"反射工具-ReflectUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ReflectUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/08.%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7-ReflectUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/08.反射工具-ReflectUtil.md",key:"v-f6f63f66",path:"/pages/ReflectUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:160},{level:3,title:"获取某个类的所有方法",slug:"获取某个类的所有方法",normalizedTitle:"获取某个类的所有方法",charIndex:167},{level:3,title:"获取某个类的指定方法",slug:"获取某个类的指定方法",normalizedTitle:"获取某个类的指定方法",charIndex:247},{level:3,title:"构造对象",slug:"构造对象",normalizedTitle:"构造对象",charIndex:332},{level:3,title:"执行方法",slug:"执行方法",normalizedTitle:"执行方法",charIndex:140}],headersStr:"介绍 使用 获取某个类的所有方法 获取某个类的指定方法 构造对象 执行方法",content:'# 介绍\n\nJava的反射机制，可以让语言变得更加灵活，对对象的操作也更加“动态”，因此在某些情况下，反射可以做到事半功倍的效果。Hutool针对Java的反射机制做了工具化封装，封装包括：\n\n 1. 获取构造方法\n 2. 获取字段\n 3. 获取字段值\n 4. 获取方法\n 5. 执行方法（对象方法和静态方法）\n\n\n# 使用\n\n\n# 获取某个类的所有方法\n\nMethod[] methods = ReflectUtil.getMethods(ExamInfoDict.class);\n\n\n\n# 获取某个类的指定方法\n\nMethod method = ReflectUtil.getMethod(ExamInfoDict.class, "getId");\n\n\n\n# 构造对象\n\nReflectUtil.newInstance(ExamInfoDict.class);\n\n\n\n# 执行方法\n\nclass TestClass {\n\tprivate int a;\n\n\tpublic int getA() {\n\t\treturn a;\n\t}\n\n\tpublic void setA(int a) {\n\t\tthis.a = a;\n\t}\n}\n\n\nTestClass testClass = new TestClass();\nReflectUtil.invoke(testClass, "setA", 10);\n',normalizedContent:'# 介绍\n\njava的反射机制，可以让语言变得更加灵活，对对象的操作也更加“动态”，因此在某些情况下，反射可以做到事半功倍的效果。hutool针对java的反射机制做了工具化封装，封装包括：\n\n 1. 获取构造方法\n 2. 获取字段\n 3. 获取字段值\n 4. 获取方法\n 5. 执行方法（对象方法和静态方法）\n\n\n# 使用\n\n\n# 获取某个类的所有方法\n\nmethod[] methods = reflectutil.getmethods(examinfodict.class);\n\n\n\n# 获取某个类的指定方法\n\nmethod method = reflectutil.getmethod(examinfodict.class, "getid");\n\n\n\n# 构造对象\n\nreflectutil.newinstance(examinfodict.class);\n\n\n\n# 执行方法\n\nclass testclass {\n\tprivate int a;\n\n\tpublic int geta() {\n\t\treturn a;\n\t}\n\n\tpublic void seta(int a) {\n\t\tthis.a = a;\n\t}\n}\n\n\ntestclass testclass = new testclass();\nreflectutil.invoke(testclass, "seta", 10);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"泛型类型工具-TypeUtil",frontmatter:{title:"泛型类型工具-TypeUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/TypeUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/09.%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7-TypeUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/09.泛型类型工具-TypeUtil.md",key:"v-c95fe988",path:"/pages/TypeUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:55},{level:3,title:"getClass",slug:"getclass",normalizedTitle:"getclass",charIndex:290},{level:3,title:"getParamType",slug:"getparamtype",normalizedTitle:"getparamtype",charIndex:317},{level:3,title:"getReturnType",slug:"getreturntype",normalizedTitle:"getreturntype",charIndex:497},{level:3,title:"getTypeArgument",slug:"gettypeargument",normalizedTitle:"gettypeargument",charIndex:679}],headersStr:"介绍 方法 getClass getParamType getReturnType getTypeArgument",content:'# 介绍\n\n针对 java.lang.reflect.Type 的工具类封装，最主要功能包括：\n\n 1. 获取方法的参数和返回值类型（包括Type和Class）\n 2. 获取泛型参数类型（包括对象的泛型参数或集合元素的泛型类型）\n\n\n# 方法\n\n首先我们定义一个类：\n\npublic class TestClass {\n\tpublic List<String> getList(){\n\t\treturn new ArrayList<>();\n\t}\n\t\n\tpublic Integer intTest(Integer integer) {\n\t\treturn 1;\n\t}\n}\n\n\n\n# getClass\n\n获得Type对应的原始类\n\n\n# getParamType\n\nMethod method = ReflectUtil.getMethod(TestClass.class, "intTest", Integer.class);\nType type = TypeUtil.getParamType(method, 0);\n// 结果：Integer.class\n\n\n获取方法参数的泛型类型\n\n\n# getReturnType\n\n获取方法的返回值类型\n\nMethod method = ReflectUtil.getMethod(TestClass.class, "getList");\nType type = TypeUtil.getReturnType(method);\n// 结果：java.util.List<java.lang.String>\n\n\n\n# getTypeArgument\n\n获取泛型类子类中泛型的填充类型。\n\nMethod method = ReflectUtil.getMethod(TestClass.class, "getList");\nType type = TypeUtil.getReturnType(method);\n\nType type2 = TypeUtil.getTypeArgument(type);\n// 结果：String.class\n',normalizedContent:'# 介绍\n\n针对 java.lang.reflect.type 的工具类封装，最主要功能包括：\n\n 1. 获取方法的参数和返回值类型（包括type和class）\n 2. 获取泛型参数类型（包括对象的泛型参数或集合元素的泛型类型）\n\n\n# 方法\n\n首先我们定义一个类：\n\npublic class testclass {\n\tpublic list<string> getlist(){\n\t\treturn new arraylist<>();\n\t}\n\t\n\tpublic integer inttest(integer integer) {\n\t\treturn 1;\n\t}\n}\n\n\n\n# getclass\n\n获得type对应的原始类\n\n\n# getparamtype\n\nmethod method = reflectutil.getmethod(testclass.class, "inttest", integer.class);\ntype type = typeutil.getparamtype(method, 0);\n// 结果：integer.class\n\n\n获取方法参数的泛型类型\n\n\n# getreturntype\n\n获取方法的返回值类型\n\nmethod method = reflectutil.getmethod(testclass.class, "getlist");\ntype type = typeutil.getreturntype(method);\n// 结果：java.util.list<java.lang.string>\n\n\n\n# gettypeargument\n\n获取泛型类子类中泛型的填充类型。\n\nmethod method = reflectutil.getmethod(testclass.class, "getlist");\ntype type = typeutil.getreturntype(method);\n\ntype type2 = typeutil.gettypeargument(type);\n// 结果：string.class\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"分页工具-PageUtil",frontmatter:{title:"分页工具-PageUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/PageUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/10.%E5%88%86%E9%A1%B5%E5%B7%A5%E5%85%B7-PageUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/10.分页工具-PageUtil.md",key:"v-72bf7324",path:"/pages/PageUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"兼容性",slug:"兼容性",normalizedTitle:"兼容性",charIndex:124},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:46},{level:3,title:"transToStartEnd",slug:"transtostartend",normalizedTitle:"transtostartend",charIndex:181},{level:3,title:"totalPage",slug:"totalpage",normalizedTitle:"totalpage",charIndex:442},{level:3,title:"分页彩虹算法",slug:"分页彩虹算法",normalizedTitle:"分页彩虹算法",charIndex:520}],headersStr:"由来 兼容性 使用 transToStartEnd totalPage 分页彩虹算法",content:"# 由来\n\n分页工具类并不是数据库分页的封装，而是分页方式的转换。在我们手动分页的时候，常常使用页码+每页个数的方式，但是有些数据库需要使用开始位置和结束位置来表示。很多时候这种转换容易出错（边界问题），于是封装了PageUtil工具类。\n\n\n# 兼容性\n\n 1. 版本<5.2.5 初始页码为1\n 2. 版本>=5.2.5 初始页码为0\n\n\n# 使用\n\n\n# transToStartEnd\n\n将页数和每页条目数转换为开始位置和结束位置。 此方法用于包括结束位置的分页方法。\n\n例如：\n\n * 页码：0，每页10 -> [0, 10]\n * 页码：1，每页10 -> [10, 20]\n\nint[] startEnd1 = PageUtil.transToStartEnd(0, 10);//[0, 10]\nint[] startEnd2 = PageUtil.transToStartEnd(1, 10);//[10, 20]\n\n\n> 方法中，页码从0开始，位置从0开始\n\n\n# totalPage\n\n根据总数和每页个数计算总页数\n\nint totalPage = PageUtil.totalPage(20, 3);//7\n\n\n\n# 分页彩虹算法\n\n此方法来自：https://github.com/iceroot/iceroot/blob/master/src/main/java/com/icexxx/util/IceUtil.java\n\n在页面上显示下一页时，常常需要显示前N页和后N页，PageUtil.rainbow作用于此。\n\n例如我们当前页为第5页，共有20页，只显示6个页码，显示的分页列表应为：\n\n上一页 3 4 [5] 6 7 8 下一页\n\n\n//参数意义分别为：当前页、总页数、每屏展示的页数\nint[] rainbow = PageUtil.rainbow(5, 20, 6);\n//结果：[3, 4, 5, 6, 7, 8]\n",normalizedContent:"# 由来\n\n分页工具类并不是数据库分页的封装，而是分页方式的转换。在我们手动分页的时候，常常使用页码+每页个数的方式，但是有些数据库需要使用开始位置和结束位置来表示。很多时候这种转换容易出错（边界问题），于是封装了pageutil工具类。\n\n\n# 兼容性\n\n 1. 版本<5.2.5 初始页码为1\n 2. 版本>=5.2.5 初始页码为0\n\n\n# 使用\n\n\n# transtostartend\n\n将页数和每页条目数转换为开始位置和结束位置。 此方法用于包括结束位置的分页方法。\n\n例如：\n\n * 页码：0，每页10 -> [0, 10]\n * 页码：1，每页10 -> [10, 20]\n\nint[] startend1 = pageutil.transtostartend(0, 10);//[0, 10]\nint[] startend2 = pageutil.transtostartend(1, 10);//[10, 20]\n\n\n> 方法中，页码从0开始，位置从0开始\n\n\n# totalpage\n\n根据总数和每页个数计算总页数\n\nint totalpage = pageutil.totalpage(20, 3);//7\n\n\n\n# 分页彩虹算法\n\n此方法来自：https://github.com/iceroot/iceroot/blob/master/src/main/java/com/icexxx/util/iceutil.java\n\n在页面上显示下一页时，常常需要显示前n页和后n页，pageutil.rainbow作用于此。\n\n例如我们当前页为第5页，共有20页，只显示6个页码，显示的分页列表应为：\n\n上一页 3 4 [5] 6 7 8 下一页\n\n\n//参数意义分别为：当前页、总页数、每屏展示的页数\nint[] rainbow = pageutil.rainbow(5, 20, 6);\n//结果：[3, 4, 5, 6, 7, 8]\n",charsets:{cjk:!0},lastUpdated:"2024/08/02, 15:43:34",lastUpdatedTimestamp:1722584614e3},{title:"类工具-ClassUtil",frontmatter:{title:"类工具-ClassUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ClassUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/12.%E7%B1%BB%E5%B7%A5%E5%85%B7-ClassUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/12.类工具-ClassUtil.md",key:"v-d496470a",path:"/pages/ClassUtil/",headers:[{level:2,title:"类处理工具 ClassUtil",slug:"类处理工具-classutil",normalizedTitle:"类处理工具 classutil",charIndex:2},{level:3,title:"getShortClassName",slug:"getshortclassname",normalizedTitle:"getshortclassname",charIndex:145},{level:3,title:"isAllAssignableFrom",slug:"isallassignablefrom",normalizedTitle:"isallassignablefrom",charIndex:227},{level:3,title:"isPrimitiveWrapper",slug:"isprimitivewrapper",normalizedTitle:"isprimitivewrapper",charIndex:321},{level:3,title:"isBasicType",slug:"isbasictype",normalizedTitle:"isbasictype",charIndex:353},{level:3,title:"getPackage",slug:"getpackage",normalizedTitle:"getpackage",charIndex:389},{level:3,title:"scanPackage方法",slug:"scanpackage方法",normalizedTitle:"scanpackage方法",charIndex:57},{level:3,title:"getClassPaths方法",slug:"getclasspaths方法",normalizedTitle:"getclasspaths方法",charIndex:536},{level:3,title:"getJavaClassPaths方法",slug:"getjavaclasspaths方法",normalizedTitle:"getjavaclasspaths方法",charIndex:828},{level:3,title:"getClassLoader和getContextClassLoader方法",slug:"getclassloader和getcontextclassloader方法",normalizedTitle:"getclassloader和getcontextclassloader方法",charIndex:883},{level:3,title:"getDefaultValue",slug:"getdefaultvalue",normalizedTitle:"getdefaultvalue",charIndex:988},{level:3,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:1079}],headersStr:"类处理工具 ClassUtil getShortClassName isAllAssignableFrom isPrimitiveWrapper isBasicType getPackage scanPackage方法 getClassPaths方法 getJavaClassPaths方法 getClassLoader和getContextClassLoader方法 getDefaultValue 其它",content:"# 类处理工具 ClassUtil\n\n这个工具主要是封装了一些反射的方法，使调用更加方便。而这个类中最有用的方法是scanPackage方法，这个方法会扫描classpath下所有类，这个在Spring中是特性之一，主要为Hulu框架中类扫描的一个基础。下面介绍下这个类中的方法。\n\n\n# getShortClassName\n\n获取完整类名的短格式如：cn.hutool.core.util.StrUtil -> c.h.c.u.StrUtil\n\n\n# isAllAssignableFrom\n\n比较判断types1和types2两组类，如果types1中所有的类都与types2对应位置的类相同，或者是其父类或接口，则返回true\n\n\n# isPrimitiveWrapper\n\n是否为包装类型\n\n\n# isBasicType\n\n是否为基本类型（包括包装类和原始类）\n\n\n# getPackage\n\n获得给定类所在包的名称，例如： cn.hutool.util.ClassUtil -> cn.hutool.util\n\n\n# scanPackage方法\n\n此方法唯一的参数是包的名称，返回结果为此包以及子包下所有的类。方法使用很简单，但是过程复杂一些，包扫描首先会调用 getClassPaths方法获得ClassPath，然后扫描ClassPath，如果是目录，扫描目录下的类文件，或者jar文件。如果是jar包，则直接从jar包中获取类名。这个方法的作用显而易见，就是要找出所有的类，在Spring中用于依赖注入，我在Hulu中则用于找到Action类。当然，你也可以传一个ClassFilter对象，用于过滤不需要的类。\n\n\n# getClassPaths方法\n\n此方法是获得当前线程的ClassPath，核心是Thread.currentThread().getContextClassLoader().getResources的调用。\n\n\n# getJavaClassPaths方法\n\n此方法用于获得java的系统变量定义的ClassPath。\n\n\n# getClassLoader和getContextClassLoader方法\n\n后者只是获得当前线程的ClassLoader，前者在获取失败的时候获取ClassUtil这个类的ClassLoader。\n\n\n# getDefaultValue\n\n获取指定类型的默认值，默认值规则为：\n\n 1. 如果为原始类型，返回0（boolean类型返回false）\n 2. 非原始类型返回null\n\n\n# 其它\n\n更多详细的方法描述见：\n\nhttps://apidoc.gitee.com/loolly/hutool/cn/hutool/core/util/ClassUtil.html",normalizedContent:"# 类处理工具 classutil\n\n这个工具主要是封装了一些反射的方法，使调用更加方便。而这个类中最有用的方法是scanpackage方法，这个方法会扫描classpath下所有类，这个在spring中是特性之一，主要为hulu框架中类扫描的一个基础。下面介绍下这个类中的方法。\n\n\n# getshortclassname\n\n获取完整类名的短格式如：cn.hutool.core.util.strutil -> c.h.c.u.strutil\n\n\n# isallassignablefrom\n\n比较判断types1和types2两组类，如果types1中所有的类都与types2对应位置的类相同，或者是其父类或接口，则返回true\n\n\n# isprimitivewrapper\n\n是否为包装类型\n\n\n# isbasictype\n\n是否为基本类型（包括包装类和原始类）\n\n\n# getpackage\n\n获得给定类所在包的名称，例如： cn.hutool.util.classutil -> cn.hutool.util\n\n\n# scanpackage方法\n\n此方法唯一的参数是包的名称，返回结果为此包以及子包下所有的类。方法使用很简单，但是过程复杂一些，包扫描首先会调用 getclasspaths方法获得classpath，然后扫描classpath，如果是目录，扫描目录下的类文件，或者jar文件。如果是jar包，则直接从jar包中获取类名。这个方法的作用显而易见，就是要找出所有的类，在spring中用于依赖注入，我在hulu中则用于找到action类。当然，你也可以传一个classfilter对象，用于过滤不需要的类。\n\n\n# getclasspaths方法\n\n此方法是获得当前线程的classpath，核心是thread.currentthread().getcontextclassloader().getresources的调用。\n\n\n# getjavaclasspaths方法\n\n此方法用于获得java的系统变量定义的classpath。\n\n\n# getclassloader和getcontextclassloader方法\n\n后者只是获得当前线程的classloader，前者在获取失败的时候获取classutil这个类的classloader。\n\n\n# getdefaultvalue\n\n获取指定类型的默认值，默认值规则为：\n\n 1. 如果为原始类型，返回0（boolean类型返回false）\n 2. 非原始类型返回null\n\n\n# 其它\n\n更多详细的方法描述见：\n\nhttps://apidoc.gitee.com/loolly/hutool/cn/hutool/core/util/classutil.html",charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"命令行工具-RuntimeUtil",frontmatter:{title:"命令行工具-RuntimeUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/RuntimeUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/14.%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-RuntimeUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/14.命令行工具-RuntimeUtil.md",key:"v-202202ac",path:"/pages/RuntimeUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:122},{level:3,title:"基础方法",slug:"基础方法",normalizedTitle:"基础方法",charIndex:129},{level:3,title:"快捷方法",slug:"快捷方法",normalizedTitle:"快捷方法",charIndex:192},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:260}],headersStr:"介绍 方法 基础方法 快捷方法 使用",content:'# 介绍\n\n在Java世界中，如果想与其它语言打交道，处理调用接口，或者JNI，就是通过本地命令方式调用了。Hutool封装了JDK的Process类，用于执行命令行命令（在Windows下是cmd，在Linux下是shell命令）。\n\n\n# 方法\n\n\n# 基础方法\n\n 1. exec 执行命令行命令，返回Process对象，Process可以读取执行命令后的返回内容的流\n\n\n# 快捷方法\n\n 1. execForStr 执行系统命令，返回字符串\n 2. execForLines 执行系统命令，返回行列表\n\n\n# 使用\n\nString str = RuntimeUtil.execForStr("ipconfig");\n\n\n执行这个命令后，在Windows下可以获取网卡信息。',normalizedContent:'# 介绍\n\n在java世界中，如果想与其它语言打交道，处理调用接口，或者jni，就是通过本地命令方式调用了。hutool封装了jdk的process类，用于执行命令行命令（在windows下是cmd，在linux下是shell命令）。\n\n\n# 方法\n\n\n# 基础方法\n\n 1. exec 执行命令行命令，返回process对象，process可以读取执行命令后的返回内容的流\n\n\n# 快捷方法\n\n 1. execforstr 执行系统命令，返回字符串\n 2. execforlines 执行系统命令，返回行列表\n\n\n# 使用\n\nstring str = runtimeutil.execforstr("ipconfig");\n\n\n执行这个命令后，在windows下可以获取网卡信息。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"剪贴板工具-ClipboardUtil",frontmatter:{title:"剪贴板工具-ClipboardUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ClipboardUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/11.%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%B7%A5%E5%85%B7-ClipboardUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/11.剪贴板工具-ClipboardUtil.md",key:"v-2daefea4",path:"/pages/ClipboardUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:62},{level:3,title:"通用方法",slug:"通用方法",normalizedTitle:"通用方法",charIndex:112},{level:3,title:"针对文本",slug:"针对文本",normalizedTitle:"针对文本",charIndex:180},{level:3,title:"针对Image对象（图片）",slug:"针对image对象-图片",normalizedTitle:"针对image对象（图片）",charIndex:230}],headersStr:"介绍 使用 通用方法 针对文本 针对Image对象（图片）",content:"# 介绍\n\n在Hutool群友的强烈要求下，在3.2.0+ 中新增了ClipboardUtil这个类用于简化操作剪贴板（当然使用场景被局限）。\n\n\n# 使用\n\nClipboardUtil 封装了几个常用的静态方法:\n\n\n# 通用方法\n\n 1. getClipboard 获取系统剪贴板\n 2. set 设置内容到剪贴板\n 3. get 获取剪贴板内容\n\n\n# 针对文本\n\n 1. setStr 设置文本到剪贴板\n 2. getStr 从剪贴板获取文本\n\n\n# 针对Image对象（图片）\n\n 1. setImage 设置图片到剪贴板\n 2. getImage 从剪贴板获取图片",normalizedContent:"# 介绍\n\n在hutool群友的强烈要求下，在3.2.0+ 中新增了clipboardutil这个类用于简化操作剪贴板（当然使用场景被局限）。\n\n\n# 使用\n\nclipboardutil 封装了几个常用的静态方法:\n\n\n# 通用方法\n\n 1. getclipboard 获取系统剪贴板\n 2. set 设置内容到剪贴板\n 3. get 获取剪贴板内容\n\n\n# 针对文本\n\n 1. setstr 设置文本到剪贴板\n 2. getstr 从剪贴板获取文本\n\n\n# 针对image对象（图片）\n\n 1. setimage 设置图片到剪贴板\n 2. getimage 从剪贴板获取图片",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"数字工具-NumberUtil",frontmatter:{title:"数字工具-NumberUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/NumberUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/15.%E6%95%B0%E5%AD%97%E5%B7%A5%E5%85%B7-NumberUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/15.数字工具-NumberUtil.md",key:"v-1402f9e7",path:"/pages/NumberUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:27},{level:3,title:"加减乘除",slug:"加减乘除",normalizedTitle:"加减乘除",charIndex:34},{level:3,title:"保留小数",slug:"保留小数",normalizedTitle:"保留小数",charIndex:170},{level:3,title:"decimalFormat",slug:"decimalformat",normalizedTitle:"decimalformat",charIndex:712},{level:3,title:"校验数字",slug:"校验数字",normalizedTitle:"校验数字",charIndex:1194},{level:3,title:"随机数",slug:"随机数",normalizedTitle:"随机数",charIndex:1322},{level:3,title:"整数列表",slug:"整数列表",normalizedTitle:"整数列表",charIndex:1486},{level:3,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:1576}],headersStr:"由来 使用 加减乘除 保留小数 decimalFormat 校验数字 随机数 整数列表 其它",content:'# 由来\n\n数字工具针对数学运算做工具性封装\n\n\n# 使用\n\n\n# 加减乘除\n\n * NumberUtil.add 针对数字类型做加法\n * NumberUtil.sub 针对数字类型做减法\n * NumberUtil.mul 针对数字类型做乘法\n * NumberUtil.div 针对数字类型做除法，并提供重载方法用于规定除不尽的情况下保留小数位数和舍弃方式。\n\n以上四种运算都会将double转为BigDecimal后计算，解决float和double类型无法进行精确计算的问题。这些方法常用于商业计算。\n\n\n# 保留小数\n\n保留小数的方法主要有两种：\n\n * NumberUtil.round 方法主要封装BigDecimal中的方法来保留小数，返回BigDecimal，这个方法更加灵活，可以选择四舍五入或者全部舍弃等模式。\n\ndouble te1=123456.123456;\ndouble te2=123456.128456;\nConsole.log(round(te1,4));//结果:123456.1235\nConsole.log(round(te2,4));//结果:123456.1285\n\n\n * NumberUtil.roundStr 方法主要封装String.format方法,舍弃方式采用四舍五入。\n\ndouble te1=123456.123456;\ndouble te2=123456.128456;\nConsole.log(roundStr(te1,2));//结果:123456.12\nConsole.log(roundStr(te2,2));//结果:123456.13\n\n\n\n# decimalFormat\n\n针对 DecimalFormat.format进行简单封装。按照固定格式对double或long类型的数字做格式化操作。\n\nlong c=299792458;//光速\nString format = NumberUtil.decimalFormat(",###", c);//299,792,458\n\n\n格式中主要以 # 和 0 两种占位符号来指定数字长度。0 表示如果位数不足则以 0 填充，# 表示只要有可能就把数字拉上这个位置。\n\n * 0 -> 取一位整数\n * 0.00 -> 取一位整数和两位小数\n * 00.000 -> 取两位整数和三位小数\n * # -> 取所有整数部分\n * #.##% -> 以百分比方式计数，并取两位小数\n * #.#####E0 -> 显示为科学计数法，并取五位小数\n * ,### -> 每三位以逗号进行分隔，例如：299,792,458\n * 光速大小为每秒,###米 -> 将格式嵌入文本\n\n关于格式的更多说明，请参阅：Java DecimalFormat的主要功能及使用方法\n\n\n# 校验数字\n\n * NumberUtil.isNumber 是否为数字\n * NumberUtil.isInteger 是否为整数\n * NumberUtil.isDouble 是否为浮点数\n * NumberUtil.isPrimes 是否为质数\n\n\n# 随机数\n\n * NumberUtil.generateRandomNumber 生成不重复随机数 根据给定的最小数字和最大数字，以及随机数的个数，产生指定的不重复的数组。\n * NumberUtil.generateBySet 生成不重复随机数 根据给定的最小数字和最大数字，以及随机数的个数，产生指定的不重复的数组。\n\n\n# 整数列表\n\nNumberUtil.range 方法根据范围和步进，生成一个有序整数列表。 NumberUtil.appendRange 将给定范围内的整数添加到已有集合中\n\n\n# 其它\n\n * NumberUtil.factorial 阶乘\n * NumberUtil.sqrt 平方根\n * NumberUtil.divisor 最大公约数\n * NumberUtil.multiple 最小公倍数\n * NumberUtil.getBinaryStr 获得数字对应的二进制字符串\n * NumberUtil.binaryToInt 二进制转int\n * NumberUtil.binaryToLong 二进制转long\n * NumberUtil.compare 比较两个值的大小\n * NumberUtil.toStr 数字转字符串，并自动去除尾小数点儿后多余的0',normalizedContent:'# 由来\n\n数字工具针对数学运算做工具性封装\n\n\n# 使用\n\n\n# 加减乘除\n\n * numberutil.add 针对数字类型做加法\n * numberutil.sub 针对数字类型做减法\n * numberutil.mul 针对数字类型做乘法\n * numberutil.div 针对数字类型做除法，并提供重载方法用于规定除不尽的情况下保留小数位数和舍弃方式。\n\n以上四种运算都会将double转为bigdecimal后计算，解决float和double类型无法进行精确计算的问题。这些方法常用于商业计算。\n\n\n# 保留小数\n\n保留小数的方法主要有两种：\n\n * numberutil.round 方法主要封装bigdecimal中的方法来保留小数，返回bigdecimal，这个方法更加灵活，可以选择四舍五入或者全部舍弃等模式。\n\ndouble te1=123456.123456;\ndouble te2=123456.128456;\nconsole.log(round(te1,4));//结果:123456.1235\nconsole.log(round(te2,4));//结果:123456.1285\n\n\n * numberutil.roundstr 方法主要封装string.format方法,舍弃方式采用四舍五入。\n\ndouble te1=123456.123456;\ndouble te2=123456.128456;\nconsole.log(roundstr(te1,2));//结果:123456.12\nconsole.log(roundstr(te2,2));//结果:123456.13\n\n\n\n# decimalformat\n\n针对 decimalformat.format进行简单封装。按照固定格式对double或long类型的数字做格式化操作。\n\nlong c=299792458;//光速\nstring format = numberutil.decimalformat(",###", c);//299,792,458\n\n\n格式中主要以 # 和 0 两种占位符号来指定数字长度。0 表示如果位数不足则以 0 填充，# 表示只要有可能就把数字拉上这个位置。\n\n * 0 -> 取一位整数\n * 0.00 -> 取一位整数和两位小数\n * 00.000 -> 取两位整数和三位小数\n * # -> 取所有整数部分\n * #.##% -> 以百分比方式计数，并取两位小数\n * #.#####e0 -> 显示为科学计数法，并取五位小数\n * ,### -> 每三位以逗号进行分隔，例如：299,792,458\n * 光速大小为每秒,###米 -> 将格式嵌入文本\n\n关于格式的更多说明，请参阅：java decimalformat的主要功能及使用方法\n\n\n# 校验数字\n\n * numberutil.isnumber 是否为数字\n * numberutil.isinteger 是否为整数\n * numberutil.isdouble 是否为浮点数\n * numberutil.isprimes 是否为质数\n\n\n# 随机数\n\n * numberutil.generaterandomnumber 生成不重复随机数 根据给定的最小数字和最大数字，以及随机数的个数，产生指定的不重复的数组。\n * numberutil.generatebyset 生成不重复随机数 根据给定的最小数字和最大数字，以及随机数的个数，产生指定的不重复的数组。\n\n\n# 整数列表\n\nnumberutil.range 方法根据范围和步进，生成一个有序整数列表。 numberutil.appendrange 将给定范围内的整数添加到已有集合中\n\n\n# 其它\n\n * numberutil.factorial 阶乘\n * numberutil.sqrt 平方根\n * numberutil.divisor 最大公约数\n * numberutil.multiple 最小公倍数\n * numberutil.getbinarystr 获得数字对应的二进制字符串\n * numberutil.binarytoint 二进制转int\n * numberutil.binarytolong 二进制转long\n * numberutil.compare 比较两个值的大小\n * numberutil.tostr 数字转字符串，并自动去除尾小数点儿后多余的0',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"数组工具-ArrayUtil",frontmatter:{title:"数组工具-ArrayUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ArrayUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/16.%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7-ArrayUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/16.数组工具-ArrayUtil.md",key:"v-3be64c8f",path:"/pages/ArrayUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:12},{level:3,title:"判空",slug:"判空",normalizedTitle:"判空",charIndex:159},{level:3,title:"新建泛型数组",slug:"新建泛型数组",normalizedTitle:"新建泛型数组",charIndex:370},{level:3,title:"调整大小",slug:"调整大小",normalizedTitle:"调整大小",charIndex:486},{level:3,title:"合并数组",slug:"合并数组",normalizedTitle:"合并数组",charIndex:534},{level:3,title:"克隆",slug:"克隆",normalizedTitle:"克隆",charIndex:587},{level:3,title:"有序列表生成",slug:"有序列表生成",normalizedTitle:"有序列表生成",charIndex:938},{level:3,title:"拆分数组",slug:"拆分数组",normalizedTitle:"拆分数组",charIndex:1029},{level:3,title:"过滤",slug:"过滤",normalizedTitle:"过滤",charIndex:1093},{level:3,title:"编辑",slug:"编辑",normalizedTitle:"编辑",charIndex:1327},{level:3,title:"zip",slug:"zip",normalizedTitle:"zip",charIndex:1632},{level:3,title:"是否包含元素",slug:"是否包含元素",normalizedTitle:"是否包含元素",charIndex:1854},{level:3,title:"包装和拆包",slug:"包装和拆包",normalizedTitle:"包装和拆包",charIndex:1908},{level:3,title:"判断对象是否为数组",slug:"判断对象是否为数组",normalizedTitle:"判断对象是否为数组",charIndex:2016},{level:3,title:"转为字符串",slug:"转为字符串",normalizedTitle:"转为字符串",charIndex:2079},{level:3,title:"toArray",slug:"toarray",normalizedTitle:"toarray",charIndex:2277}],headersStr:"介绍 方法 判空 新建泛型数组 调整大小 合并数组 克隆 有序列表生成 拆分数组 过滤 编辑 zip 是否包含元素 包装和拆包 判断对象是否为数组 转为字符串 toArray",content:'# 介绍\n\n数组工具中的方法在2.x版本中都在CollectionUtil中存在，3.x之后版本（包括4.x版本）中拆分出来作为ArrayUtil。数组工具类主要针对原始类型数组和泛型数组相关方法进行封装。\n\n数组工具类主要是解决对象数组（包括包装类型数组）和原始类型数组使用方法不统一的问题。\n\n\n# 方法\n\n\n# 判空\n\n数组的判空类似于字符串的判空，标准是null或者数组长度为0，ArrayUtil中封装了针对原始类型和泛型数组的判空和判非空：\n\n 1. 判断空\n\nint[] a = {};\nint[] b = null;\nArrayUtil.isEmpty(a);\nArrayUtil.isEmpty(b);\n\n\n 2. 判断非空\n\nint[] a = {1,2};\nArrayUtil.isNotEmpty(a);\n\n\n\n# 新建泛型数组\n\nArray.newInstance并不支持泛型返回值，在此封装此方法使之支持泛型返回值。\n\nString[] newArray = ArrayUtil.newArray(String.class, 3);\n\n\n\n# 调整大小\n\n使用 ArrayUtil.resize方法生成一个新的重新设置大小的数组。\n\n\n# 合并数组\n\nArrayUtil.addAll方法采用可变参数方式，将多个泛型数组合并为一个数组。\n\n\n# 克隆\n\n数组本身支持clone方法，因此确定为某种类型数组时调用ArrayUtil.clone(T[]),不确定类型的使用ArrayUtil.clone(T)，两种重载方法在实现上有所不同，但是在使用中并不能感知出差别。\n\n 1. 泛型数组调用原生克隆\n\nInteger[] b = {1,2,3};\nInteger[] cloneB = ArrayUtil.clone(b);\nAssert.assertArrayEquals(b, cloneB);\n\n\n 2. 非泛型数组（原始类型数组）调用第二种重载方法\n\nint[] a = {1,2,3};\nint[] clone = ArrayUtil.clone(a);\nAssert.assertArrayEquals(a, clone);\n\n\n\n# 有序列表生成\n\nArrayUtil.range方法有三个重载，这三个重载配合可以实现支持步进的有序数组或者步进为1的有序数组。这种列表生成器在Python中做为语法糖存在。\n\n\n# 拆分数组\n\nArrayUtil.split方法用于拆分一个byte数组，将byte数组平均分成几等份，常用于消息拆分。\n\n\n# 过滤\n\nArrayUtil.filter方法用于过滤已有数组元素，只针对泛型数组操作，原始类型数组并未提供。 方法中Filter接口用于返回boolean值决定是否保留。\n\n过滤数组，只保留偶数\n\nInteger[] a = {1,2,3,4,5,6};\n// [2,4,6]\nInteger[] filter = ArrayUtil.filter(a, (Editor<Integer>) t -> (t % 2 == 0) ? t : null);\n\n\n对已有数组编辑，获得编辑后的值。\n\nInteger[] a = {1, 2, 3, 4, 5, 6};\n// [1, 20, 3, 40, 5, 60]\nInteger[] filter = ArrayUtil.filter(a, (Editor<Integer>) t -> (t % 2 == 0) ? t * 10 : t);\n\n\n\n# 编辑\n\n修改元素对象,此方法会修改原数组。\n\nInteger[] a = {1, 2, 3, 4, 5, 6};\n// [1, 20, 3, 40, 5, 60]\nArrayUtil.edit(a, t -> (t % 2 == 0) ? t * 10 : t);\n\n\n\n# zip\n\nArrayUtil.zip方法传入两个数组，第一个数组为key，第二个数组对应位置为value，此方法在Python中为zip()函数。\n\nString[] keys = {"a", "b", "c"};\nInteger[] values = {1,2,3};\nMap<String, Integer> map = ArrayUtil.zip(keys, values, true);\n\n//{a=1, b=2, c=3}\n\n\n\n# 是否包含元素\n\nArrayUtil.contains方法只针对泛型数组，检测指定元素是否在数组中。\n\n\n# 包装和拆包\n\n在原始类型元素和包装类型中，Java实现了自动包装和拆包，但是相应的数组无法实现，于是便是用ArrayUtil.wrap和ArrayUtil.unwrap对原始类型数组和包装类型数组进行转换。\n\n\n# 判断对象是否为数组\n\nArrayUtil.isArray方法封装了obj.getClass().isArray()。\n\n\n# 转为字符串\n\n 1. ArrayUtil.toString 通常原始类型的数组输出为字符串时无法正常显示，于是封装此方法可以完美兼容原始类型数组和包装类型数组的转为字符串操作。\n\n 2. ArrayUtil.join 方法使用间隔符将一个数组转为字符串，比如[1,2,3,4]这个数组转为字符串，间隔符使用“-”的话，结果为 1-2-3-4，join方法同样支持泛型数组和原始类型数组。\n\n\n# toArray\n\nArrayUtil.toArray方法针对ByteBuffer转数组提供便利。',normalizedContent:'# 介绍\n\n数组工具中的方法在2.x版本中都在collectionutil中存在，3.x之后版本（包括4.x版本）中拆分出来作为arrayutil。数组工具类主要针对原始类型数组和泛型数组相关方法进行封装。\n\n数组工具类主要是解决对象数组（包括包装类型数组）和原始类型数组使用方法不统一的问题。\n\n\n# 方法\n\n\n# 判空\n\n数组的判空类似于字符串的判空，标准是null或者数组长度为0，arrayutil中封装了针对原始类型和泛型数组的判空和判非空：\n\n 1. 判断空\n\nint[] a = {};\nint[] b = null;\narrayutil.isempty(a);\narrayutil.isempty(b);\n\n\n 2. 判断非空\n\nint[] a = {1,2};\narrayutil.isnotempty(a);\n\n\n\n# 新建泛型数组\n\narray.newinstance并不支持泛型返回值，在此封装此方法使之支持泛型返回值。\n\nstring[] newarray = arrayutil.newarray(string.class, 3);\n\n\n\n# 调整大小\n\n使用 arrayutil.resize方法生成一个新的重新设置大小的数组。\n\n\n# 合并数组\n\narrayutil.addall方法采用可变参数方式，将多个泛型数组合并为一个数组。\n\n\n# 克隆\n\n数组本身支持clone方法，因此确定为某种类型数组时调用arrayutil.clone(t[]),不确定类型的使用arrayutil.clone(t)，两种重载方法在实现上有所不同，但是在使用中并不能感知出差别。\n\n 1. 泛型数组调用原生克隆\n\ninteger[] b = {1,2,3};\ninteger[] cloneb = arrayutil.clone(b);\nassert.assertarrayequals(b, cloneb);\n\n\n 2. 非泛型数组（原始类型数组）调用第二种重载方法\n\nint[] a = {1,2,3};\nint[] clone = arrayutil.clone(a);\nassert.assertarrayequals(a, clone);\n\n\n\n# 有序列表生成\n\narrayutil.range方法有三个重载，这三个重载配合可以实现支持步进的有序数组或者步进为1的有序数组。这种列表生成器在python中做为语法糖存在。\n\n\n# 拆分数组\n\narrayutil.split方法用于拆分一个byte数组，将byte数组平均分成几等份，常用于消息拆分。\n\n\n# 过滤\n\narrayutil.filter方法用于过滤已有数组元素，只针对泛型数组操作，原始类型数组并未提供。 方法中filter接口用于返回boolean值决定是否保留。\n\n过滤数组，只保留偶数\n\ninteger[] a = {1,2,3,4,5,6};\n// [2,4,6]\ninteger[] filter = arrayutil.filter(a, (editor<integer>) t -> (t % 2 == 0) ? t : null);\n\n\n对已有数组编辑，获得编辑后的值。\n\ninteger[] a = {1, 2, 3, 4, 5, 6};\n// [1, 20, 3, 40, 5, 60]\ninteger[] filter = arrayutil.filter(a, (editor<integer>) t -> (t % 2 == 0) ? t * 10 : t);\n\n\n\n# 编辑\n\n修改元素对象,此方法会修改原数组。\n\ninteger[] a = {1, 2, 3, 4, 5, 6};\n// [1, 20, 3, 40, 5, 60]\narrayutil.edit(a, t -> (t % 2 == 0) ? t * 10 : t);\n\n\n\n# zip\n\narrayutil.zip方法传入两个数组，第一个数组为key，第二个数组对应位置为value，此方法在python中为zip()函数。\n\nstring[] keys = {"a", "b", "c"};\ninteger[] values = {1,2,3};\nmap<string, integer> map = arrayutil.zip(keys, values, true);\n\n//{a=1, b=2, c=3}\n\n\n\n# 是否包含元素\n\narrayutil.contains方法只针对泛型数组，检测指定元素是否在数组中。\n\n\n# 包装和拆包\n\n在原始类型元素和包装类型中，java实现了自动包装和拆包，但是相应的数组无法实现，于是便是用arrayutil.wrap和arrayutil.unwrap对原始类型数组和包装类型数组进行转换。\n\n\n# 判断对象是否为数组\n\narrayutil.isarray方法封装了obj.getclass().isarray()。\n\n\n# 转为字符串\n\n 1. arrayutil.tostring 通常原始类型的数组输出为字符串时无法正常显示，于是封装此方法可以完美兼容原始类型数组和包装类型数组的转为字符串操作。\n\n 2. arrayutil.join 方法使用间隔符将一个数组转为字符串，比如[1,2,3,4]这个数组转为字符串，间隔符使用“-”的话，结果为 1-2-3-4，join方法同样支持泛型数组和原始类型数组。\n\n\n# toarray\n\narrayutil.toarray方法针对bytebuffer转数组提供便利。',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"随机工具-RandomUtil",frontmatter:{title:"随机工具-RandomUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/RandomUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/17.%E9%9A%8F%E6%9C%BA%E5%B7%A5%E5%85%B7-RandomUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/17.随机工具-RandomUtil.md",key:"v-512b1952",path:"/pages/RandomUtil/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:109}],headersStr:"说明 使用",content:"# 说明\n\nRandomUtil主要针对JDK中Random对象做封装，严格来说，Java产生的随机数都是伪随机数，因此Hutool封装后产生的随机结果也是伪随机结果。不过这种随机结果对于大多数情况已经够用。\n\n\n# 使用\n\n * RandomUtil.randomInt 获得指定范围内的随机数\n\n例如我们想产生一个[10, 100)的随机数，则：\n\nint c = RandomUtil.randomInt(10, 100);\n\n\n * RandomUtil.randomBytes 随机bytes，一般用于密码或者salt生成\n\nbyte[] c = RandomUtil.randomBytes(10);\n\n\n * RandomUtil.randomEle 随机获得列表中的元素\n * RandomUtil.randomEleSet 随机获得列表中的一定量的不重复元素，返回LinkedHashSet\n\nSet<Integer> set = RandomUtil.randomEleSet(CollUtil.newArrayList(1, 2, 3, 4, 5, 6), 2);\n\n\n * RandomUtil.randomString 获得一个随机的字符串（只包含数字和字符）\n * RandomUtil.randomNumbers 获得一个只包含数字的字符串\n * RandomUtil.weightRandom 权重随机生成器，传入带权重的对象，然后根据权重随机获取对象",normalizedContent:"# 说明\n\nrandomutil主要针对jdk中random对象做封装，严格来说，java产生的随机数都是伪随机数，因此hutool封装后产生的随机结果也是伪随机结果。不过这种随机结果对于大多数情况已经够用。\n\n\n# 使用\n\n * randomutil.randomint 获得指定范围内的随机数\n\n例如我们想产生一个[10, 100)的随机数，则：\n\nint c = randomutil.randomint(10, 100);\n\n\n * randomutil.randombytes 随机bytes，一般用于密码或者salt生成\n\nbyte[] c = randomutil.randombytes(10);\n\n\n * randomutil.randomele 随机获得列表中的元素\n * randomutil.randomeleset 随机获得列表中的一定量的不重复元素，返回linkedhashset\n\nset<integer> set = randomutil.randomeleset(collutil.newarraylist(1, 2, 3, 4, 5, 6), 2);\n\n\n * randomutil.randomstring 获得一个随机的字符串（只包含数字和字符）\n * randomutil.randomnumbers 获得一个只包含数字的字符串\n * randomutil.weightrandom 权重随机生成器，传入带权重的对象，然后根据权重随机获取对象",charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"唯一ID工具-IdUtil",frontmatter:{title:"唯一ID工具-IdUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/IdUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/18.%E5%94%AF%E4%B8%80ID%E5%B7%A5%E5%85%B7-IdUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/18.唯一ID工具-IdUtil.md",key:"v-4159bb2c",path:"/pages/IdUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:135},{level:3,title:"UUID",slug:"uuid",normalizedTitle:"uuid",charIndex:83},{level:3,title:"ObjectId",slug:"objectid",normalizedTitle:"objectid",charIndex:91},{level:3,title:"Snowflake",slug:"snowflake",normalizedTitle:"snowflake",charIndex:112}],headersStr:"介绍 使用 UUID ObjectId Snowflake",content:"# 介绍\n\n在分布式环境中，唯一ID生成应用十分广泛，生成方法也多种多样，Hutool针对一些常用生成策略做了简单封装。\n\n唯一ID生成器的工具类，涵盖了：\n\n * UUID\n * ObjectId（MongoDB）\n * Snowflake（Twitter）\n\n\n# 使用\n\n\n# UUID\n\nUUID全称通用唯一识别码（universally unique identifier），JDK通过java.util.UUID提供了 Leach-Salz 变体的封装。在Hutool中，生成一个UUID字符串方法如下：\n\n//生成的UUID是带-的字符串，类似于：a5c8a5e8-df2b-4706-bea4-08d0939410e3\nString uuid = IdUtil.randomUUID();\n\n//生成的是不带-的字符串，类似于：b17f24ff026d40949c85a24f4f375d42\nString simpleUUID = IdUtil.simpleUUID();\n\n\n> 说明 Hutool重写java.util.UUID的逻辑，对应类为cn.hutool.core.lang.UUID，使生成不带-的UUID字符串不再需要做字符替换，性能提升一倍左右。\n\n\n# ObjectId\n\nObjectId是MongoDB数据库的一种唯一ID生成策略，是UUID version1的变种，详细介绍可见：服务化框架－分布式Unique ID的生成方法一览。\n\nHutool针对此封装了cn.hutool.core.lang.ObjectId，快捷创建方法为：\n\n//生成类似：5b9e306a4df4f8c54a39fb0c\nString id = ObjectId.next();\n\n//方法2：从Hutool-4.1.14开始提供\nString id2 = IdUtil.objectId();\n\n\n\n# Snowflake\n\n分布式系统中，有一些需要使用全局唯一ID的场景，有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。Twitter的Snowflake 算法就是这种生成器。\n\n使用方法如下：\n\n//参数1为终端ID\n//参数2为数据中心ID\nSnowflake snowflake = IdUtil.getSnowflake(1, 1);\nlong id = snowflake.nextId();\n\n//简单使用\nlong id = IdUtil.getSnowflakeNextId();\nString id = IdUtil.getSnowflakeNextIdStr();\n\n\n> 注意 IdUtil.createSnowflake每次调用会创建一个新的Snowflake对象，不同的Snowflake对象创建的ID可能会有重复，因此请自行维护此对象为单例，或者使用IdUtil.getSnowflake使用全局单例对象。",normalizedContent:"# 介绍\n\n在分布式环境中，唯一id生成应用十分广泛，生成方法也多种多样，hutool针对一些常用生成策略做了简单封装。\n\n唯一id生成器的工具类，涵盖了：\n\n * uuid\n * objectid（mongodb）\n * snowflake（twitter）\n\n\n# 使用\n\n\n# uuid\n\nuuid全称通用唯一识别码（universally unique identifier），jdk通过java.util.uuid提供了 leach-salz 变体的封装。在hutool中，生成一个uuid字符串方法如下：\n\n//生成的uuid是带-的字符串，类似于：a5c8a5e8-df2b-4706-bea4-08d0939410e3\nstring uuid = idutil.randomuuid();\n\n//生成的是不带-的字符串，类似于：b17f24ff026d40949c85a24f4f375d42\nstring simpleuuid = idutil.simpleuuid();\n\n\n> 说明 hutool重写java.util.uuid的逻辑，对应类为cn.hutool.core.lang.uuid，使生成不带-的uuid字符串不再需要做字符替换，性能提升一倍左右。\n\n\n# objectid\n\nobjectid是mongodb数据库的一种唯一id生成策略，是uuid version1的变种，详细介绍可见：服务化框架－分布式unique id的生成方法一览。\n\nhutool针对此封装了cn.hutool.core.lang.objectid，快捷创建方法为：\n\n//生成类似：5b9e306a4df4f8c54a39fb0c\nstring id = objectid.next();\n\n//方法2：从hutool-4.1.14开始提供\nstring id2 = idutil.objectid();\n\n\n\n# snowflake\n\n分布式系统中，有一些需要使用全局唯一id的场景，有些时候我们希望能使用一种简单一些的id，并且希望id能够按照时间有序生成。twitter的snowflake 算法就是这种生成器。\n\n使用方法如下：\n\n//参数1为终端id\n//参数2为数据中心id\nsnowflake snowflake = idutil.getsnowflake(1, 1);\nlong id = snowflake.nextid();\n\n//简单使用\nlong id = idutil.getsnowflakenextid();\nstring id = idutil.getsnowflakenextidstr();\n\n\n> 注意 idutil.createsnowflake每次调用会创建一个新的snowflake对象，不同的snowflake对象创建的id可能会有重复，因此请自行维护此对象为单例，或者使用idutil.getsnowflake使用全局单例对象。",charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"枚举工具-EnumUtil",frontmatter:{title:"枚举工具-EnumUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/EnumUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/13.%E6%9E%9A%E4%B8%BE%E5%B7%A5%E5%85%B7-EnumUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/13.枚举工具-EnumUtil.md",key:"v-f4bfc402",path:"/pages/EnumUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:184},{level:3,title:"getNames",slug:"getnames",normalizedTitle:"getnames",charIndex:422},{level:3,title:"getFieldValues",slug:"getfieldvalues",normalizedTitle:"getfieldvalues",charIndex:545},{level:3,title:"getBy",slug:"getby",normalizedTitle:"getby",charIndex:687},{level:3,title:"getFieldBy",slug:"getfieldby",normalizedTitle:"getfieldby",charIndex:794},{level:3,title:"getEnumMap",slug:"getenummap",normalizedTitle:"getenummap",charIndex:925},{level:3,title:"getNameFieldMap",slug:"getnamefieldmap",normalizedTitle:"getnamefieldmap",charIndex:1114}],headersStr:"介绍 方法 getNames getFieldValues getBy getFieldBy getEnumMap getNameFieldMap",content:'# 介绍\n\n枚举（enum）算一种“语法糖”，是指一个经过排序的、被打包成一个单一实体的项列表。一个枚举的实例可以使用枚举项列表中任意单一项的值。枚举在各个语言当中都有着广泛的应用，通常用来表示诸如颜色、方式、类别、状态等等数目有限、形式离散、表达又极为明确的量。Java从JDK5开始，引入了对枚举的支持。\n\nEnumUtil 用于对未知枚举类型进行操作。\n\n\n# 方法\n\n首先我们定义一个枚举对象：\n\n//定义枚举\npublic enum TestEnum{\n\tTEST1("type1"), TEST2("type2"), TEST3("type3");\n\t\n\tprivate TestEnum(String type) {\n\t\tthis.type = type;\n\t}\n\t\n\tprivate String type;\n\t\n\tpublic String getType() {\n\t\treturn this.type;\n\t}\n}\n\n\n\n# getNames\n\n获取枚举类中所有枚举对象的name列表。栗子：\n\nList<String> names = EnumUtil.getNames(TestEnum.class);\n//结果：[TEST1, TEST2, TEST3]\n\n\n\n# getFieldValues\n\n获得枚举类中各枚举对象下指定字段的值。栗子：\n\nList<Object> types = EnumUtil.getFieldValues(TestEnum.class, "type");\n//结果：[type1, type2, type3]\n\n\n\n# getBy\n\n根据传入lambda和值获得对应枚举。栗子🌰：\n\nTestEnum testEnum = EnumUtil.getBy(TestEnum::ordinal, 1);\n//结果：TEST2\n\n\n\n# getFieldBy\n\n根据传入lambda和值获得对应枚举的值。栗子🌰：\n\nString type = EnumUtil.getFieldBy(TestEnum::getType, Enum::ordinal, 1);\n// 结果：“type2”\n\n\n\n# getEnumMap\n\n获取枚举字符串值和枚举对象的Map对应，使用LinkedHashMap保证有序，结果中键为枚举名，值为枚举对象。栗子：\n\nMap<String,TestEnum> enumMap = EnumUtil.getEnumMap(TestEnum.class);\nenumMap.get("TEST1") // 结果为：TestEnum.TEST1\n\n\n\n# getNameFieldMap\n\n获得枚举名对应指定字段值的Map，键为枚举名，值为字段值。栗子：\n\nMap<String, Object> enumMap = EnumUtil.getNameFieldMap(TestEnum.class, "type");\nenumMap.get("TEST1") // 结果为：type1\n',normalizedContent:'# 介绍\n\n枚举（enum）算一种“语法糖”，是指一个经过排序的、被打包成一个单一实体的项列表。一个枚举的实例可以使用枚举项列表中任意单一项的值。枚举在各个语言当中都有着广泛的应用，通常用来表示诸如颜色、方式、类别、状态等等数目有限、形式离散、表达又极为明确的量。java从jdk5开始，引入了对枚举的支持。\n\nenumutil 用于对未知枚举类型进行操作。\n\n\n# 方法\n\n首先我们定义一个枚举对象：\n\n//定义枚举\npublic enum testenum{\n\ttest1("type1"), test2("type2"), test3("type3");\n\t\n\tprivate testenum(string type) {\n\t\tthis.type = type;\n\t}\n\t\n\tprivate string type;\n\t\n\tpublic string gettype() {\n\t\treturn this.type;\n\t}\n}\n\n\n\n# getnames\n\n获取枚举类中所有枚举对象的name列表。栗子：\n\nlist<string> names = enumutil.getnames(testenum.class);\n//结果：[test1, test2, test3]\n\n\n\n# getfieldvalues\n\n获得枚举类中各枚举对象下指定字段的值。栗子：\n\nlist<object> types = enumutil.getfieldvalues(testenum.class, "type");\n//结果：[type1, type2, type3]\n\n\n\n# getby\n\n根据传入lambda和值获得对应枚举。栗子🌰：\n\ntestenum testenum = enumutil.getby(testenum::ordinal, 1);\n//结果：test2\n\n\n\n# getfieldby\n\n根据传入lambda和值获得对应枚举的值。栗子🌰：\n\nstring type = enumutil.getfieldby(testenum::gettype, enum::ordinal, 1);\n// 结果：“type2”\n\n\n\n# getenummap\n\n获取枚举字符串值和枚举对象的map对应，使用linkedhashmap保证有序，结果中键为枚举名，值为枚举对象。栗子：\n\nmap<string,testenum> enummap = enumutil.getenummap(testenum.class);\nenummap.get("test1") // 结果为：testenum.test1\n\n\n\n# getnamefieldmap\n\n获得枚举名对应指定字段值的map，键为枚举名，值为字段值。栗子：\n\nmap<string, object> enummap = enumutil.getnamefieldmap(testenum.class, "type");\nenummap.get("test1") // 结果为：type1\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"压缩工具-ZipUtil",frontmatter:{title:"压缩工具-ZipUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ZipUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/19.%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7-ZipUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/19.压缩工具-ZipUtil.md",key:"v-1cd0a948",path:"/pages/ZipUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:124},{level:3,title:"Zip",slug:"zip",normalizedTitle:"zip",charIndex:42},{level:3,title:"Gzip",slug:"gzip",normalizedTitle:"gzip",charIndex:1164},{level:3,title:"Zlib",slug:"zlib",normalizedTitle:"zlib",charIndex:1271},{level:3,title:"常见问题",slug:"常见问题",normalizedTitle:"常见问题",charIndex:1508}],headersStr:"由来 方法 Zip Gzip Zlib 常见问题",content:'# 由来\n\n在Java中，对文件、文件夹打包，压缩是一件比较繁琐的事情，我们常常引入Zip4j进行此类操作。但是很多时候，JDK中的zip包就可满足我们大部分需求。ZipUtil就是针对java.util.zip做工具化封装，使压缩解压操作可以一个方法搞定，并且自动处理文件和目录的问题，不再需要用户判断，压缩后的文件也会自动创建文件，自动创建父目录，大大简化的压缩解压的复杂度。\n\n\n# 方法\n\n\n# Zip\n\n 1. 压缩\n\nZipUtil.zip 方法提供一系列的重载方法，满足不同需求的压缩需求，这包括：\n\n * 打包到当前目录（可以打包文件，也可以打包文件夹，根据路径自动判断）\n\n//将aaa目录下的所有文件目录打包到d:/aaa.zip\nZipUtil.zip("d:/aaa");\n\n\n * 指定打包后保存的目的地，自动判断目标是文件还是文件夹\n\n//将aaa目录下的所有文件目录打包到d:/bbb/目录下的aaa.zip文件中\n// 此处第二个参数必须为文件，不能为目录\nZipUtil.zip("d:/aaa", "d:/bbb/aaa.zip");\n\n//将aaa目录下的所有文件目录打包到d:/bbb/目录下的ccc.zip文件中\nZipUtil.zip("d:/aaa", "d:/bbb/ccc.zip");\n\n\n * 可选是否包含被打包的目录。比如我们打包一个照片的目录，打开这个压缩包有可能是带目录的，也有可能是打开压缩包直接看到的是文件。zip方法增加一个boolean参数可选这两种模式，以应对众多需求。\n\n//将aaa目录以及其目录下的所有文件目录打包到d:/bbb/目录下的ccc.zip文件中\nZipUtil.zip("d:/aaa", "d:/bbb/ccc.zip", true);\n\n\n * 多文件或目录压缩。可以选择多个文件或目录一起打成zip包。\n\nZipUtil.zip(FileUtil.file("d:/bbb/ccc.zip"), false, \n    FileUtil.file("d:/test1/file1.txt"),\n    FileUtil.file("d:/test1/file2.txt"),\n    FileUtil.file("d:/test2/file1.txt"),\n    FileUtil.file("d:/test2/file2.txt")\n);\n\n\n 2. 解压\n\nZipUtil.unzip 解压。同样提供几个重载，满足不同需求。\n\n//将test.zip解压到e:\\\\aaa目录下，返回解压到的目录\nFile unzip = ZipUtil.unzip("E:\\\\aaa\\\\test.zip", "e:\\\\aaa");\n\n\n\n# Gzip\n\nGzip是网页传输中广泛使用的压缩方式，Hutool同样提供其工具方法简化其过程。\n\nZipUtil.gzip 压缩，可压缩字符串，也可压缩文件 ZipUtil.unGzip 解压Gzip文件\n\n\n# Zlib\n\nZipUtil.zlib 压缩，可压缩字符串，也可压缩文件 ZipUtil.unZlib 解压zlib文件\n\n> 注意 ZipUtil默认情况下使用系统编码，也就是说：\n> \n>  1. 如果你在命令行下运行，则调用系统编码（一般Windows下为GBK、Linux下为UTF-8）\n>  2. 如果你在IDE（如Eclipse）下运行代码，则读取的是当前项目的编码（详细请查阅IDE设置，我的项目默认都是UTF-8编码，因此解压和压缩都是用这个编码）\n\n\n# 常见问题\n\n 1. 解压时报java.lang.IllegalArgumentException:MALFORMED错误\n\n基本是因为编码问题，Hutool默认使用UTF-8编码，自定义为其他编码即可（一般为GBK）。\n\n//将test.zip解压到e:\\\\aaa目录下，返回解压到的目录\nFile unzip = ZipUtil.unzip("E:\\\\aaa\\\\test.zip", "e:\\\\aaa", CharsetUtil.CHARSET_GBK);\n\n\n 2. 压缩并添加密码\n\nHutool或JDK的Zip工具并不支持添加密码，可以考虑使用Zip4j完成，以下代码来自Zip4j官网。\n\nZipParameters zipParameters = new ZipParameters();\nzipParameters.setEncryptFiles(true);\nzipParameters.setEncryptionMethod(EncryptionMethod.AES);\n// Below line is optional. AES 256 is used by default. You can override it to use AES 128. AES 192 is supported only for extracting.\nzipParameters.setAesKeyStrength(AesKeyStrength.KEY_STRENGTH_256); \n\nList<File> filesToAdd = Arrays.asList(\n    new File("somefile"), \n    new File("someotherfile")\n);\n\nZipFile zipFile = new ZipFile("https://doc.hutool.cn/assets/js/filename.zip", "password".toCharArray());\nzipFile.addFiles(filesToAdd, zipParameters);\n',normalizedContent:'# 由来\n\n在java中，对文件、文件夹打包，压缩是一件比较繁琐的事情，我们常常引入zip4j进行此类操作。但是很多时候，jdk中的zip包就可满足我们大部分需求。ziputil就是针对java.util.zip做工具化封装，使压缩解压操作可以一个方法搞定，并且自动处理文件和目录的问题，不再需要用户判断，压缩后的文件也会自动创建文件，自动创建父目录，大大简化的压缩解压的复杂度。\n\n\n# 方法\n\n\n# zip\n\n 1. 压缩\n\nziputil.zip 方法提供一系列的重载方法，满足不同需求的压缩需求，这包括：\n\n * 打包到当前目录（可以打包文件，也可以打包文件夹，根据路径自动判断）\n\n//将aaa目录下的所有文件目录打包到d:/aaa.zip\nziputil.zip("d:/aaa");\n\n\n * 指定打包后保存的目的地，自动判断目标是文件还是文件夹\n\n//将aaa目录下的所有文件目录打包到d:/bbb/目录下的aaa.zip文件中\n// 此处第二个参数必须为文件，不能为目录\nziputil.zip("d:/aaa", "d:/bbb/aaa.zip");\n\n//将aaa目录下的所有文件目录打包到d:/bbb/目录下的ccc.zip文件中\nziputil.zip("d:/aaa", "d:/bbb/ccc.zip");\n\n\n * 可选是否包含被打包的目录。比如我们打包一个照片的目录，打开这个压缩包有可能是带目录的，也有可能是打开压缩包直接看到的是文件。zip方法增加一个boolean参数可选这两种模式，以应对众多需求。\n\n//将aaa目录以及其目录下的所有文件目录打包到d:/bbb/目录下的ccc.zip文件中\nziputil.zip("d:/aaa", "d:/bbb/ccc.zip", true);\n\n\n * 多文件或目录压缩。可以选择多个文件或目录一起打成zip包。\n\nziputil.zip(fileutil.file("d:/bbb/ccc.zip"), false, \n    fileutil.file("d:/test1/file1.txt"),\n    fileutil.file("d:/test1/file2.txt"),\n    fileutil.file("d:/test2/file1.txt"),\n    fileutil.file("d:/test2/file2.txt")\n);\n\n\n 2. 解压\n\nziputil.unzip 解压。同样提供几个重载，满足不同需求。\n\n//将test.zip解压到e:\\\\aaa目录下，返回解压到的目录\nfile unzip = ziputil.unzip("e:\\\\aaa\\\\test.zip", "e:\\\\aaa");\n\n\n\n# gzip\n\ngzip是网页传输中广泛使用的压缩方式，hutool同样提供其工具方法简化其过程。\n\nziputil.gzip 压缩，可压缩字符串，也可压缩文件 ziputil.ungzip 解压gzip文件\n\n\n# zlib\n\nziputil.zlib 压缩，可压缩字符串，也可压缩文件 ziputil.unzlib 解压zlib文件\n\n> 注意 ziputil默认情况下使用系统编码，也就是说：\n> \n>  1. 如果你在命令行下运行，则调用系统编码（一般windows下为gbk、linux下为utf-8）\n>  2. 如果你在ide（如eclipse）下运行代码，则读取的是当前项目的编码（详细请查阅ide设置，我的项目默认都是utf-8编码，因此解压和压缩都是用这个编码）\n\n\n# 常见问题\n\n 1. 解压时报java.lang.illegalargumentexception:malformed错误\n\n基本是因为编码问题，hutool默认使用utf-8编码，自定义为其他编码即可（一般为gbk）。\n\n//将test.zip解压到e:\\\\aaa目录下，返回解压到的目录\nfile unzip = ziputil.unzip("e:\\\\aaa\\\\test.zip", "e:\\\\aaa", charsetutil.charset_gbk);\n\n\n 2. 压缩并添加密码\n\nhutool或jdk的zip工具并不支持添加密码，可以考虑使用zip4j完成，以下代码来自zip4j官网。\n\nzipparameters zipparameters = new zipparameters();\nzipparameters.setencryptfiles(true);\nzipparameters.setencryptionmethod(encryptionmethod.aes);\n// below line is optional. aes 256 is used by default. you can override it to use aes 128. aes 192 is supported only for extracting.\nzipparameters.setaeskeystrength(aeskeystrength.key_strength_256); \n\nlist<file> filestoadd = arrays.aslist(\n    new file("somefile"), \n    new file("someotherfile")\n);\n\nzipfile zipfile = new zipfile("https://doc.hutool.cn/assets/js/filename.zip", "password".tochararray());\nzipfile.addfiles(filestoadd, zipparameters);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"正则工具-ReUtil",frontmatter:{title:"正则工具-ReUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ReUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/21.%E6%AD%A3%E5%88%99%E5%B7%A5%E5%85%B7-ReUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/21.正则工具-ReUtil.md",key:"v-1ff2bb34",path:"/pages/ReUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:1003},{level:3,title:"ReUtil.extractMulti",slug:"reutil-extractmulti",normalizedTitle:"reutil.extractmulti",charIndex:1010},{level:3,title:"ReUtil.delFirst",slug:"reutil-delfirst",normalizedTitle:"reutil.delfirst",charIndex:1223},{level:3,title:"ReUtil.findAll",slug:"reutil-findall",normalizedTitle:"reutil.findall",charIndex:1418},{level:3,title:"ReUtil.getFirstNumber",slug:"reutil-getfirstnumber",normalizedTitle:"reutil.getfirstnumber",charIndex:1635},{level:3,title:"ReUtil.isMatch",slug:"reutil-ismatch",normalizedTitle:"reutil.ismatch",charIndex:1749},{level:3,title:"ReUtil.replaceAll",slug:"reutil-replaceall",normalizedTitle:"reutil.replaceall",charIndex:1923},{level:3,title:"ReUtil.escape",slug:"reutil-escape",normalizedTitle:"reutil.escape",charIndex:2193}],headersStr:"由来 使用 ReUtil.extractMulti ReUtil.delFirst ReUtil.findAll ReUtil.getFirstNumber ReUtil.isMatch ReUtil.replaceAll ReUtil.escape",content:'# 由来\n\n在文本处理中，正则表达式几乎是全能的，但是Java的正则表达式有时候处理一些事情还是有些繁琐，所以我封装了部分常用功能。就比如说我要匹配一段文本中的某些部分，我们需要这样做：\n\nString content = "ZZZaaabbbccc中文1234";\nPattern pattern = Pattern.compile(regex, Pattern.DOTALL);\nMatcher matcher = pattern.matcher(content);\nif (matcher.find()) {\n    String result= matcher.group();\n}\n\n\n其中牵涉到多个对象，想用的时候真心记不住。好吧，既然功能如此常用，我就封装一下：\n\n/**\n* 获得匹配的字符串\n* \n* @param pattern 编译后的正则模式\n* @param content 被匹配的内容\n* @param groupIndex 匹配正则的分组序号\n* @return 匹配后得到的字符串，未匹配返回null\n*/\npublic static String get(Pattern pattern, String content, int groupIndex) {\n    Matcher matcher = pattern.matcher(content);\n    if (matcher.find()) {\n        return matcher.group(groupIndex);\n    }\n    return null;\n}\n\n/**\n* 获得匹配的字符串\n* \n* @param regex 匹配的正则\n* @param content 被匹配的内容\n* @param groupIndex 匹配正则的分组序号\n* @return 匹配后得到的字符串，未匹配返回null\n*/\npublic static String get(String regex, String content, int groupIndex) {\n    Pattern pattern = Pattern.compile(regex, Pattern.DOTALL);\n    return get(pattern, content, groupIndex);\n}\n\n\n\n# 使用\n\n\n# ReUtil.extractMulti\n\n抽取多个分组然后把它们拼接起来\n\nString content = "ZZZaaabbbccc中文1234";\nString resultExtractMulti = ReUtil.extractMulti("(\\\\w)aa(\\\\w)", content, "$1-$2");\nAssert.assertEquals("Z-a", resultExtractMulti);\n\n\n\n# ReUtil.delFirst\n\n删除第一个匹配到的内容\n\nString content = "ZZZaaabbbccc中文1234";\nString resultDelFirst = ReUtil.delFirst("(\\\\w)aa(\\\\w)", content);\nAssert.assertEquals("ZZbbbccc中文1234", resultDelFirst);\n\n\n\n# ReUtil.findAll\n\n查找所有匹配文本\n\nString content = "ZZZaaabbbccc中文1234";\nList<String> resultFindAll = ReUtil.findAll("\\\\w{2}", content, 0, new ArrayList<String>());\n// 结果：["ZZ", "Za", "aa", "bb", "bc", "cc", "12", "34"]\n\n\n\n# ReUtil.getFirstNumber\n\n找到匹配的第一个数字\n\nInteger resultGetFirstNumber = ReUtil.getFirstNumber(content);\n// 结果：1234\n\n\n\n# ReUtil.isMatch\n\n给定字符串是否匹配给定正则\n\nString content = "ZZZaaabbbccc中文1234";\nboolean isMatch = ReUtil.isMatch("\\\\w+[\\u4E00-\\u9FFF]+\\\\d+", content);\nAssert.assertTrue(isMatch);\n\n\n\n# ReUtil.replaceAll\n\n通过正则查找到字符串，然后把匹配到的字符串加入到replacementTemplate中，$1表示分组1的字符串\n\nString content = "ZZZaaabbbccc中文1234";\n//此处把1234替换为 ->1234<-\nString replaceAll = ReUtil.replaceAll(content, "(\\\\d+)", "->$1<-");\nAssert.assertEquals("ZZZaaabbbccc中文->1234<-", replaceAll);\n\n\n\n# ReUtil.escape\n\n转义给定字符串，为正则相关的特殊符号转义\n\nString escape = ReUtil.escape("我有个$符号{}");\n// 结果：我有个\\\\$符号\\\\{\\\\}\n',normalizedContent:'# 由来\n\n在文本处理中，正则表达式几乎是全能的，但是java的正则表达式有时候处理一些事情还是有些繁琐，所以我封装了部分常用功能。就比如说我要匹配一段文本中的某些部分，我们需要这样做：\n\nstring content = "zzzaaabbbccc中文1234";\npattern pattern = pattern.compile(regex, pattern.dotall);\nmatcher matcher = pattern.matcher(content);\nif (matcher.find()) {\n    string result= matcher.group();\n}\n\n\n其中牵涉到多个对象，想用的时候真心记不住。好吧，既然功能如此常用，我就封装一下：\n\n/**\n* 获得匹配的字符串\n* \n* @param pattern 编译后的正则模式\n* @param content 被匹配的内容\n* @param groupindex 匹配正则的分组序号\n* @return 匹配后得到的字符串，未匹配返回null\n*/\npublic static string get(pattern pattern, string content, int groupindex) {\n    matcher matcher = pattern.matcher(content);\n    if (matcher.find()) {\n        return matcher.group(groupindex);\n    }\n    return null;\n}\n\n/**\n* 获得匹配的字符串\n* \n* @param regex 匹配的正则\n* @param content 被匹配的内容\n* @param groupindex 匹配正则的分组序号\n* @return 匹配后得到的字符串，未匹配返回null\n*/\npublic static string get(string regex, string content, int groupindex) {\n    pattern pattern = pattern.compile(regex, pattern.dotall);\n    return get(pattern, content, groupindex);\n}\n\n\n\n# 使用\n\n\n# reutil.extractmulti\n\n抽取多个分组然后把它们拼接起来\n\nstring content = "zzzaaabbbccc中文1234";\nstring resultextractmulti = reutil.extractmulti("(\\\\w)aa(\\\\w)", content, "$1-$2");\nassert.assertequals("z-a", resultextractmulti);\n\n\n\n# reutil.delfirst\n\n删除第一个匹配到的内容\n\nstring content = "zzzaaabbbccc中文1234";\nstring resultdelfirst = reutil.delfirst("(\\\\w)aa(\\\\w)", content);\nassert.assertequals("zzbbbccc中文1234", resultdelfirst);\n\n\n\n# reutil.findall\n\n查找所有匹配文本\n\nstring content = "zzzaaabbbccc中文1234";\nlist<string> resultfindall = reutil.findall("\\\\w{2}", content, 0, new arraylist<string>());\n// 结果：["zz", "za", "aa", "bb", "bc", "cc", "12", "34"]\n\n\n\n# reutil.getfirstnumber\n\n找到匹配的第一个数字\n\ninteger resultgetfirstnumber = reutil.getfirstnumber(content);\n// 结果：1234\n\n\n\n# reutil.ismatch\n\n给定字符串是否匹配给定正则\n\nstring content = "zzzaaabbbccc中文1234";\nboolean ismatch = reutil.ismatch("\\\\w+[\\u4e00-\\u9fff]+\\\\d+", content);\nassert.asserttrue(ismatch);\n\n\n\n# reutil.replaceall\n\n通过正则查找到字符串，然后把匹配到的字符串加入到replacementtemplate中，$1表示分组1的字符串\n\nstring content = "zzzaaabbbccc中文1234";\n//此处把1234替换为 ->1234<-\nstring replaceall = reutil.replaceall(content, "(\\\\d+)", "->$1<-");\nassert.assertequals("zzzaaabbbccc中文->1234<-", replaceall);\n\n\n\n# reutil.escape\n\n转义给定字符串，为正则相关的特殊符号转义\n\nstring escape = reutil.escape("我有个$符号{}");\n// 结果：我有个\\\\$符号\\\\{\\\\}\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"引用工具-ReferenceUtil",frontmatter:{title:"引用工具-ReferenceUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ReferenceUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/20.%E5%BC%95%E7%94%A8%E5%B7%A5%E5%85%B7-ReferenceUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/20.引用工具-ReferenceUtil.md",key:"v-bdeb45d4",path:"/pages/ReferenceUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:236},{level:3,title:"create",slug:"create",normalizedTitle:"create",charIndex:243}],headersStr:"介绍 方法 create",content:"# 介绍\n\n引用工具类，主要针对Reference 工具化封装\n\n主要封装包括：\n\n 1. SoftReference 软引用，在GC报告内存不足时会被GC回收\n 2. WeakReference 弱引用，在GC时发现弱引用会回收其对象\n 3. PhantomReference 虚引用，在GC时发现虚引用对象，会将PhantomReference插入ReferenceQueue。此时对象未被真正回收，要等到ReferenceQueue被真正处理后才会被回收。\n\n\n# 方法\n\n\n# create\n\n根据类型枚举创建引用。",normalizedContent:"# 介绍\n\n引用工具类，主要针对reference 工具化封装\n\n主要封装包括：\n\n 1. softreference 软引用，在gc报告内存不足时会被gc回收\n 2. weakreference 弱引用，在gc时发现弱引用会回收其对象\n 3. phantomreference 虚引用，在gc时发现虚引用对象，会将phantomreference插入referencequeue。此时对象未被真正回收，要等到referencequeue被真正处理后才会被回收。\n\n\n# 方法\n\n\n# create\n\n根据类型枚举创建引用。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"身份证工具-IdcardUtil",frontmatter:{title:"身份证工具-IdcardUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/IdcardUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/23.%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%B7%A5%E5%85%B7-IdcardUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/23.身份证工具-IdcardUtil.md",key:"v-6e3d0395",path:"/pages/IdcardUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:172},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:164}],headersStr:"由来 介绍 使用",content:'# 由来\n\n在日常开发中，我们对身份证的验证主要是正则方式（位数，数字范围等），但是中国身份证，尤其18位身份证每一位都有严格规定，并且最后一位为校验位。而我们在实际应用中，针对身份证的验证理应严格至此。于是IdcardUtil应运而生。\n\n> IdcardUtil从3.0.4版本起加入Hutool工具家族，升级至此版本以上可使用。\n\n\n# 介绍\n\nIdcardUtil现在支持大陆15位、18位身份证，港澳台10位身份证。\n\n工具中主要的方法包括：\n\n 1. isValidCard 验证身份证是否合法\n 2. convert15To18 身份证15位转18位\n 3. getBirthByIdCard 获取生日\n 4. getAgeByIdCard 获取年龄\n 5. getYearByIdCard 获取生日年\n 6. getMonthByIdCard 获取生日月\n 7. getDayByIdCard 获取生日天\n 8. getGenderByIdCard 获取性别\n 9. getProvinceByIdCard 获取省份\n\n\n# 使用\n\nString ID_18 = "321083197812162119";\nString ID_15 = "150102880730303";\n\n//是否有效\nboolean valid = IdcardUtil.isValidCard(ID_18);\nboolean valid15 = IdcardUtil.isValidCard(ID_15);\n\n//转换\nString convert15To18 = IdcardUtil.convert15To18(ID_15);\nAssert.assertEquals(convert15To18, "150102198807303035");\n\n//年龄\nDateTime date = DateUtil.parse("2017-04-10");\n\t\t\nint age = IdcardUtil.getAgeByIdCard(ID_18, date);\nAssert.assertEquals(age, 38);\n\nint age2 = IdcardUtil.getAgeByIdCard(ID_15, date);\nAssert.assertEquals(age2, 28);\n\n//生日\nString birth = IdcardUtil.getBirthByIdCard(ID_18);\nAssert.assertEquals(birth, "19781216");\n\nString birth2 = IdcardUtil.getBirthByIdCard(ID_15);\nAssert.assertEquals(birth2, "19880730");\n\n//省份\nString province = IdcardUtil.getProvinceByIdCard(ID_18);\nAssert.assertEquals(province, "江苏");\n\nString province2 = IdcardUtil.getProvinceByIdCard(ID_15);\nAssert.assertEquals(province2, "内蒙古");\n\n\n> 声明 以上两个身份证号码为随机编造的，如有雷同，纯属巧合。',normalizedContent:'# 由来\n\n在日常开发中，我们对身份证的验证主要是正则方式（位数，数字范围等），但是中国身份证，尤其18位身份证每一位都有严格规定，并且最后一位为校验位。而我们在实际应用中，针对身份证的验证理应严格至此。于是idcardutil应运而生。\n\n> idcardutil从3.0.4版本起加入hutool工具家族，升级至此版本以上可使用。\n\n\n# 介绍\n\nidcardutil现在支持大陆15位、18位身份证，港澳台10位身份证。\n\n工具中主要的方法包括：\n\n 1. isvalidcard 验证身份证是否合法\n 2. convert15to18 身份证15位转18位\n 3. getbirthbyidcard 获取生日\n 4. getagebyidcard 获取年龄\n 5. getyearbyidcard 获取生日年\n 6. getmonthbyidcard 获取生日月\n 7. getdaybyidcard 获取生日天\n 8. getgenderbyidcard 获取性别\n 9. getprovincebyidcard 获取省份\n\n\n# 使用\n\nstring id_18 = "321083197812162119";\nstring id_15 = "150102880730303";\n\n//是否有效\nboolean valid = idcardutil.isvalidcard(id_18);\nboolean valid15 = idcardutil.isvalidcard(id_15);\n\n//转换\nstring convert15to18 = idcardutil.convert15to18(id_15);\nassert.assertequals(convert15to18, "150102198807303035");\n\n//年龄\ndatetime date = dateutil.parse("2017-04-10");\n\t\t\nint age = idcardutil.getagebyidcard(id_18, date);\nassert.assertequals(age, 38);\n\nint age2 = idcardutil.getagebyidcard(id_15, date);\nassert.assertequals(age2, 28);\n\n//生日\nstring birth = idcardutil.getbirthbyidcard(id_18);\nassert.assertequals(birth, "19781216");\n\nstring birth2 = idcardutil.getbirthbyidcard(id_15);\nassert.assertequals(birth2, "19880730");\n\n//省份\nstring province = idcardutil.getprovincebyidcard(id_18);\nassert.assertequals(province, "江苏");\n\nstring province2 = idcardutil.getprovincebyidcard(id_15);\nassert.assertequals(province2, "内蒙古");\n\n\n> 声明 以上两个身份证号码为随机编造的，如有雷同，纯属巧合。',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"信息脱敏工具-DesensitizedUtil",frontmatter:{title:"信息脱敏工具-DesensitizedUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/DesensitizedUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/24.%E4%BF%A1%E6%81%AF%E8%84%B1%E6%95%8F%E5%B7%A5%E5%85%B7-DesensitizedUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/24.信息脱敏工具-DesensitizedUtil.md",key:"v-4946ba1a",path:"/pages/DesensitizedUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:224}],headersStr:"介绍 使用",content:'# 介绍\n\n在数据处理或清洗中，可能涉及到很多隐私信息的脱敏工作，因此Hutool针对常用的信息封装了一些脱敏方法。\n\n现阶段支持的脱敏数据类型包括：\n\n 1.  用户id\n 2.  中文姓名\n 3.  身份证号\n 4.  座机号\n 5.  手机号\n 6.  地址\n 7.  电子邮件\n 8.  密码\n 9.  中国大陆车牌，包含普通车辆、新能源车辆\n 10. 银行卡\n\n整体来说，所谓脱敏就是隐藏掉信息中的一部分关键信息，用*代替，自定义隐藏可以使用StrUtil.hide方法完成。\n\n\n# 使用\n\n我们以身份证号码为例：\n\n// 5***************1X\nDesensitizedUtil.idCardNum("51343620000320711X", 1, 2);\n\n\n对于约定俗成的脱敏，我们可以不用指定隐藏位数，比如手机号：\n\n// 180****1999\nDesensitizedUtil.mobilePhone("18049531999");\n\n\n当然还有一些简单粗暴的脱敏，比如密码，只保留了位数信息：\n\n// **********\nDesensitizedUtil.password("1234567890");\n\n\n> 鸣谢 此工具类来自于dazer and neusoft and qiaomu贡献，看着像三个人……',normalizedContent:'# 介绍\n\n在数据处理或清洗中，可能涉及到很多隐私信息的脱敏工作，因此hutool针对常用的信息封装了一些脱敏方法。\n\n现阶段支持的脱敏数据类型包括：\n\n 1.  用户id\n 2.  中文姓名\n 3.  身份证号\n 4.  座机号\n 5.  手机号\n 6.  地址\n 7.  电子邮件\n 8.  密码\n 9.  中国大陆车牌，包含普通车辆、新能源车辆\n 10. 银行卡\n\n整体来说，所谓脱敏就是隐藏掉信息中的一部分关键信息，用*代替，自定义隐藏可以使用strutil.hide方法完成。\n\n\n# 使用\n\n我们以身份证号码为例：\n\n// 5***************1x\ndesensitizedutil.idcardnum("51343620000320711x", 1, 2);\n\n\n对于约定俗成的脱敏，我们可以不用指定隐藏位数，比如手机号：\n\n// 180****1999\ndesensitizedutil.mobilephone("18049531999");\n\n\n当然还有一些简单粗暴的脱敏，比如密码，只保留了位数信息：\n\n// **********\ndesensitizedutil.password("1234567890");\n\n\n> 鸣谢 此工具类来自于dazer and neusoft and qiaomu贡献，看着像三个人……',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"SPI加载工具-ServiceLoaderUtil",frontmatter:{title:"SPI加载工具-ServiceLoaderUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ServiceLoaderUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/26.SPI%E5%8A%A0%E8%BD%BD%E5%B7%A5%E5%85%B7-ServiceLoaderUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/26.SPI加载工具-ServiceLoaderUtil.md",key:"v-83448174",path:"/pages/ServiceLoaderUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:154}],headersStr:"介绍 使用",content:'# 介绍\n\nSPI（Service Provider Interface），是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。\n\n更多介绍见：https://www.jianshu.com/p/3a3edbcd8f24\n\n\n# 使用\n\n定义一个接口：\n\npackage cn.hutool.test.spi;\n\npublic interface SPIService {\n    void execute();\n}\n\n\n有两个实现:\n\npackage cn.hutool.test.spi;\n\npublic class SpiImpl1 implements SPIService{\n    public void execute() {\n        Console.log("SpiImpl1.execute()");\n    }\n}\n\n\npackage cn.hutool.test.spi;\n\npublic class SpiImpl2 implements SPIService{\n    public void execute() {\n        Console.log("SpiImpl2.execute()");\n    }\n}\n\n\n然后在classpath的META-INF/services下创建一个文件，叫cn.hutool.test.spi.SPIService，内容为：\n\ncn.hutool.test.spi.SpiImpl1\ncn.hutool.test.spi.SpiImpl2\n\n\n加载第一个可用服务，如果用户定义了多个接口实现类，只获取第一个不报错的服务。这个方法多用于同一接口多种实现的自动甄别加载， 通过判断jar是否引入，自动找到实现类。\n\nSPIService service = ServiceLoaderUtil.loadFirstAvailable(SPIService.class);\nservice.execute();\n',normalizedContent:'# 介绍\n\nspi（service provider interface），是一种服务发现机制。它通过在classpath路径下的meta-inf/services文件夹查找文件，自动加载文件里所定义的类。\n\n更多介绍见：https://www.jianshu.com/p/3a3edbcd8f24\n\n\n# 使用\n\n定义一个接口：\n\npackage cn.hutool.test.spi;\n\npublic interface spiservice {\n    void execute();\n}\n\n\n有两个实现:\n\npackage cn.hutool.test.spi;\n\npublic class spiimpl1 implements spiservice{\n    public void execute() {\n        console.log("spiimpl1.execute()");\n    }\n}\n\n\npackage cn.hutool.test.spi;\n\npublic class spiimpl2 implements spiservice{\n    public void execute() {\n        console.log("spiimpl2.execute()");\n    }\n}\n\n\n然后在classpath的meta-inf/services下创建一个文件，叫cn.hutool.test.spi.spiservice，内容为：\n\ncn.hutool.test.spi.spiimpl1\ncn.hutool.test.spi.spiimpl2\n\n\n加载第一个可用服务，如果用户定义了多个接口实现类，只获取第一个不报错的服务。这个方法多用于同一接口多种实现的自动甄别加载， 通过判断jar是否引入，自动找到实现类。\n\nspiservice service = serviceloaderutil.loadfirstavailable(spiservice.class);\nservice.execute();\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"字符编码工具-CharsetUtil",frontmatter:{title:"字符编码工具-CharsetUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CharsetUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/27.%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%B7%A5%E5%85%B7-CharsetUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/27.字符编码工具-CharsetUtil.md",key:"v-2ad05378",path:"/pages/CharsetUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"常量",slug:"常量",normalizedTitle:"常量",charIndex:44},{level:3,title:"字符串形式",slug:"字符串形式",normalizedTitle:"字符串形式",charIndex:87},{level:3,title:"Charset对象形式",slug:"charset对象形式",normalizedTitle:"charset对象形式",charIndex:131},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:205},{level:3,title:"编码字符串转为Charset对象",slug:"编码字符串转为charset对象",normalizedTitle:"编码字符串转为charset对象",charIndex:212},{level:3,title:"转换编码",slug:"转换编码",normalizedTitle:"转换编码",charIndex:278},{level:3,title:"系统默认编码",slug:"系统默认编码",normalizedTitle:"系统默认编码",charIndex:350}],headersStr:"介绍 常量 字符串形式 Charset对象形式 方法 编码字符串转为Charset对象 转换编码 系统默认编码",content:"# 介绍\n\nCharsetUtil主要针对编码操作做了工具化封装，同时提供了一些常用编码常量。\n\n\n# 常量\n\n常量在需要编码的地方直接引用，可以很好的提高便利性。\n\n\n# 字符串形式\n\n 1. ISO_8859_1\n 2. UTF_8\n 3. GBK\n\n\n# Charset对象形式\n\n 1. CHARSET_ISO_8859_1\n 2. CHARSET_UTF_8\n 3. CHARSET_GBK\n\n\n# 方法\n\n\n# 编码字符串转为Charset对象\n\nCharsetUtil.charset方法用于将编码形式字符串转为Charset对象。\n\n\n# 转换编码\n\nCharsetUtil.convert方法主要是在两种编码中转换。主要针对因为编码识别错误而导致的乱码问题的一种解决方法。\n\n\n# 系统默认编码\n\nCharsetUtil.defaultCharset方法是Charset.defaultCharset()的封装方法。返回系统编码。 CharsetUtil.defaultCharsetName方法返回字符串形式的编码类型。",normalizedContent:"# 介绍\n\ncharsetutil主要针对编码操作做了工具化封装，同时提供了一些常用编码常量。\n\n\n# 常量\n\n常量在需要编码的地方直接引用，可以很好的提高便利性。\n\n\n# 字符串形式\n\n 1. iso_8859_1\n 2. utf_8\n 3. gbk\n\n\n# charset对象形式\n\n 1. charset_iso_8859_1\n 2. charset_utf_8\n 3. charset_gbk\n\n\n# 方法\n\n\n# 编码字符串转为charset对象\n\ncharsetutil.charset方法用于将编码形式字符串转为charset对象。\n\n\n# 转换编码\n\ncharsetutil.convert方法主要是在两种编码中转换。主要针对因为编码识别错误而导致的乱码问题的一种解决方法。\n\n\n# 系统默认编码\n\ncharsetutil.defaultcharset方法是charset.defaultcharset()的封装方法。返回系统编码。 charsetutil.defaultcharsetname方法返回字符串形式的编码类型。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"HashMap扩展-Dict",frontmatter:{title:"HashMap扩展-Dict",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Dict/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/06.%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/02.HashMap%E6%89%A9%E5%B1%95-Dict.html",relativePath:"01.指南/02.核心（Hutool-core）/06.语言特性/02.HashMap扩展-Dict.md",key:"v-2a3afbbd",path:"/pages/Dict/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:169},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:91},{level:3,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:328},{level:3,title:"获取指定类型的值",slug:"获取指定类型的值",normalizedTitle:"获取指定类型的值",charIndex:482}],headersStr:"由来 介绍 使用 创建 获取指定类型的值",content:'# 由来\n\n如果你了解Python，你一定知道Python有dict这一数据结构，也是一种KV（Key-Value）结构的数据结构，类似于Java中的Map，但是提供了更加灵活多样的使用。Hutool中的Dict对象旨在实现更加灵活的KV结构，针对强类型，提供丰富的getXXX操作，将HashMap扩展为无类型区别的数据结构。\n\n\n# 介绍\n\nDict继承HashMap，其key为String类型，value为Object类型，通过实现BasicTypeGetter接口提供针对不同类型的get方法，同时提供针对Bean的转换方法，大大提高Map的灵活性。\n\n> Hutool-db中Entity是Dict子类，做为数据的媒介。\n\n\n# 使用\n\n\n# 创建\n\nDict dict = Dict.create()\n\t.set("key1", 1)//int\n\t.set("key2", 1000L)//long\n\t.set("key3", DateTime.now());//Date\n\n\n通过链式构造，创建Dict对象，同时可以按照Map的方式使用。\n\n\n# 获取指定类型的值\n\nLong v2 = dict.getLong("key2");//1000\n',normalizedContent:'# 由来\n\n如果你了解python，你一定知道python有dict这一数据结构，也是一种kv（key-value）结构的数据结构，类似于java中的map，但是提供了更加灵活多样的使用。hutool中的dict对象旨在实现更加灵活的kv结构，针对强类型，提供丰富的getxxx操作，将hashmap扩展为无类型区别的数据结构。\n\n\n# 介绍\n\ndict继承hashmap，其key为string类型，value为object类型，通过实现basictypegetter接口提供针对不同类型的get方法，同时提供针对bean的转换方法，大大提高map的灵活性。\n\n> hutool-db中entity是dict子类，做为数据的媒介。\n\n\n# 使用\n\n\n# 创建\n\ndict dict = dict.create()\n\t.set("key1", 1)//int\n\t.set("key2", 1000l)//long\n\t.set("key3", datetime.now());//date\n\n\n通过链式构造，创建dict对象，同时可以按照map的方式使用。\n\n\n# 获取指定类型的值\n\nlong v2 = dict.getlong("key2");//1000\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/language/characteristics/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/06.%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/02.核心（Hutool-core）/06.语言特性/01.概述.md",key:"v-6b25220f",path:"/pages/language/characteristics/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2}],headersStr:"介绍",content:"# 介绍\n\n语言特性，即lang包，主要针对JDK中的一些数据结构和接口的完善，包括：\n\n * caller 获取方法调用者\n * copier 复制器抽象接口\n * func 函数接口\n * hash 哈希算法\n * loader 加载器抽象接口\n * mutable 提供可变对象\n * tree 提供树状结构\n * 其它\n\n总之，lang包下提供了一个大杂烩，汇集了各种数据结构。",normalizedContent:"# 介绍\n\n语言特性，即lang包，主要针对jdk中的一些数据结构和接口的完善，包括：\n\n * caller 获取方法调用者\n * copier 复制器抽象接口\n * func 函数接口\n * hash 哈希算法\n * loader 加载器抽象接口\n * mutable 提供可变对象\n * tree 提供树状结构\n * 其它\n\n总之，lang包下提供了一个大杂烩，汇集了各种数据结构。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"单例工具-Singleton",frontmatter:{title:"单例工具-Singleton",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Singleton/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/06.%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/03.%E5%8D%95%E4%BE%8B%E5%B7%A5%E5%85%B7-Singleton.html",relativePath:"01.指南/02.核心（Hutool-core）/06.语言特性/03.单例工具-Singleton.md",key:"v-ed8b3516",path:"/pages/Singleton/",headers:[{level:2,title:"为什么会有这个类",slug:"为什么会有这个类",normalizedTitle:"为什么会有这个类",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:16},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1347}],headersStr:"为什么会有这个类 使用 总结",content:'# 为什么会有这个类\n\n平常我们使用单例不外乎两种方式：\n\n 1. 在对象里加个静态方法getInstance()来获取。此方式可以参考 【转】线程安全的单例模式 这篇博客，可分为饿汉和饱汉模式。\n 2. 通过Spring这类容器统一管理对象，用的时候去对象池中拿。Spring也可以通过配置决定懒汉或者饿汉模式\n\n说实话我更倾向于第二种，但是Spring更注重的是注入，而不是拿，于是我想做Singleton这个类，维护一个单例的池，用这个单例对象的时候直接来拿就可以，这里我用的懒汉模式。我只是想把单例的管理方式换一种思路，我希望管理单例的是一个容器工具，而不是一个大大的框架，这样能大大减少单例使用的复杂性。\n\n\n# 使用\n\n/**\n * 单例样例\n * @author loolly\n *\n */\npublic class SingletonDemo {\n\n    /**\n     * 动物接口\n     * @author loolly\n     *\n     */\n    public static interface Animal{\n        public void say();\n    }\n\n    /**\n     * 狗实现\n     * @author loolly\n     *\n     */\n    public static class Dog implements Animal{\n        @Override\n        public void say() {\n            System.out.println("汪汪");\n        }\n    }\n\n    /**\n     * 猫实现\n     * @author loolly\n     *\n     */\n    public static class Cat implements Animal{\n        @Override\n        public void say() {\n            System.out.println("喵喵");\n        }\n    }\n\n    public static void main(String[] args) {\n        Animal dog = Singleton.get(Dog.class);\n        Animal cat = Singleton.get(Cat.class);\n\n        //单例对象每次取出为同一个对象，除非调用Singleton.destroy()或者remove方法\n        System.out.println(dog == Singleton.get(Dog.class));        //True\n        System.out.println(cat == Singleton.get(Cat.class));            //True\n\n        dog.say();        //汪汪\n        cat.say();        //喵喵\n    }\n}\n\n\n\n# 总结\n\n大家如果有兴趣可以看下这个类，实现非常简单，用一个安全的ConcurrentHashMap作为单例对象池，通过newInstance()实例化对象（支持带参数的构造方法），无论取还是创建对象都是线程安全的。',normalizedContent:'# 为什么会有这个类\n\n平常我们使用单例不外乎两种方式：\n\n 1. 在对象里加个静态方法getinstance()来获取。此方式可以参考 【转】线程安全的单例模式 这篇博客，可分为饿汉和饱汉模式。\n 2. 通过spring这类容器统一管理对象，用的时候去对象池中拿。spring也可以通过配置决定懒汉或者饿汉模式\n\n说实话我更倾向于第二种，但是spring更注重的是注入，而不是拿，于是我想做singleton这个类，维护一个单例的池，用这个单例对象的时候直接来拿就可以，这里我用的懒汉模式。我只是想把单例的管理方式换一种思路，我希望管理单例的是一个容器工具，而不是一个大大的框架，这样能大大减少单例使用的复杂性。\n\n\n# 使用\n\n/**\n * 单例样例\n * @author loolly\n *\n */\npublic class singletondemo {\n\n    /**\n     * 动物接口\n     * @author loolly\n     *\n     */\n    public static interface animal{\n        public void say();\n    }\n\n    /**\n     * 狗实现\n     * @author loolly\n     *\n     */\n    public static class dog implements animal{\n        @override\n        public void say() {\n            system.out.println("汪汪");\n        }\n    }\n\n    /**\n     * 猫实现\n     * @author loolly\n     *\n     */\n    public static class cat implements animal{\n        @override\n        public void say() {\n            system.out.println("喵喵");\n        }\n    }\n\n    public static void main(string[] args) {\n        animal dog = singleton.get(dog.class);\n        animal cat = singleton.get(cat.class);\n\n        //单例对象每次取出为同一个对象，除非调用singleton.destroy()或者remove方法\n        system.out.println(dog == singleton.get(dog.class));        //true\n        system.out.println(cat == singleton.get(cat.class));            //true\n\n        dog.say();        //汪汪\n        cat.say();        //喵喵\n    }\n}\n\n\n\n# 总结\n\n大家如果有兴趣可以看下这个类，实现非常简单，用一个安全的concurrenthashmap作为单例对象池，通过newinstance()实例化对象（支持带参数的构造方法），无论取还是创建对象都是线程安全的。',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"断言-Assert",frontmatter:{title:"断言-Assert",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Assert/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/06.%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/04.%E6%96%AD%E8%A8%80-Assert.html",relativePath:"01.指南/02.核心（Hutool-core）/06.语言特性/04.断言-Assert.md",key:"v-026aa2c0",path:"/pages/Assert/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:295},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:150},{level:2,title:"更多方法",slug:"更多方法",normalizedTitle:"更多方法",charIndex:499}],headersStr:"由来 介绍 使用 更多方法",content:"# 由来\n\nJava中有assert关键字，但是存在许多问题：\n\n 1. assert关键字需要在运行时显式开启才能生效，否则你的断言就没有任何意义。\n 2. 用assert代替if是陷阱之二。assert的判断和if语句差不多，但两者的作用有着本质的区别：assert关键字本意上是为测试调试程序时使用的，但如果不小心用assert来控制了程序的业务流程，那在测试调试结束后去掉assert关键字就意味着修改了程序的正常的逻辑。\n 3. assert断言失败将面临程序的退出。\n\n因此，并不建议使用此关键字。相应的，在Hutool中封装了更加友好的Assert类，用于断言判定。\n\n\n# 介绍\n\nAssert类更像是Junit中的Assert类，也很像Guava中的Preconditions，主要作用是在方法或者任何地方对参数的有效性做校验。当不满足断言条件时，会抛出IllegalArgumentException或IllegalStateException异常。\n\n\n# 使用\n\nString a = null;\ncn.hutool.lang.Assert.isNull(a);\n\n\n\n# 更多方法\n\n * isTrue 必须为true，否则抛出IllegalArgumentException异常\n * isNull 必须是null值\n * notNull 不能是null值\n * notEmpty 不能为空，支持字符串，数组，集合等\n * notBlank 不能是空白字符串\n * notContain 不能包含指定的子串\n * noNullElements 数组中不能包含null元素\n * isInstanceOf 必须是指定类的实例\n * isAssignable 必须是子类和父类关系\n * state 会抛出IllegalStateException异常",normalizedContent:"# 由来\n\njava中有assert关键字，但是存在许多问题：\n\n 1. assert关键字需要在运行时显式开启才能生效，否则你的断言就没有任何意义。\n 2. 用assert代替if是陷阱之二。assert的判断和if语句差不多，但两者的作用有着本质的区别：assert关键字本意上是为测试调试程序时使用的，但如果不小心用assert来控制了程序的业务流程，那在测试调试结束后去掉assert关键字就意味着修改了程序的正常的逻辑。\n 3. assert断言失败将面临程序的退出。\n\n因此，并不建议使用此关键字。相应的，在hutool中封装了更加友好的assert类，用于断言判定。\n\n\n# 介绍\n\nassert类更像是junit中的assert类，也很像guava中的preconditions，主要作用是在方法或者任何地方对参数的有效性做校验。当不满足断言条件时，会抛出illegalargumentexception或illegalstateexception异常。\n\n\n# 使用\n\nstring a = null;\ncn.hutool.lang.assert.isnull(a);\n\n\n\n# 更多方法\n\n * istrue 必须为true，否则抛出illegalargumentexception异常\n * isnull 必须是null值\n * notnull 不能是null值\n * notempty 不能为空，支持字符串，数组，集合等\n * notblank 不能是空白字符串\n * notcontain 不能包含指定的子串\n * nonullelements 数组中不能包含null元素\n * isinstanceof 必须是指定类的实例\n * isassignable 必须是子类和父类关系\n * state 会抛出illegalstateexception异常",charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"二进码十进数-BCD",frontmatter:{title:"二进码十进数-BCD",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/BCD/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/06.%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/05.%E4%BA%8C%E8%BF%9B%E7%A0%81%E5%8D%81%E8%BF%9B%E6%95%B0-BCD.html",relativePath:"01.指南/02.核心（Hutool-core）/06.语言特性/05.二进码十进数-BCD.md",key:"v-8a9fe21a",path:"/pages/BCD/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:429},{level:2,title:"注意",slug:"注意",normalizedTitle:"注意",charIndex:601}],headersStr:"介绍 方法 注意",content:'# 介绍\n\nBCD码（Binary-Coded Decimal）亦称二进码十进数或二-十进制代码，BCD码这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。\n\n这种编码技巧最常用于会计系统的设计里，因为会计制度经常需要对很长的数字串作准确的计算。相对于一般的浮点式记数法，采用BCD码，既可保存数值的精确度，又可免却电脑作浮点运算时所耗费的时间。此外，对于其他需要高精确度的计算，BCD编码亦很常用。\n\nBCD码是四位二进制码, 也就是将十进制的数字转化为二进制, 但是和普通的转化有一点不同, 每一个十进制的数字0-9都对应着一个四位的二进制码,对应关系如下: 十进制0 对应 二进制0000;十进制1 对应二进制0001.......9=>1001 接下来的10就由两个上述的码来表示，表示为0001 0000。也就是BCD码是遇见1001就产生进位,不象普通的二进制码,到1111才产生进位10000\n\n\n# 方法\n\nString strForTest = "123456ABCDEF";\n\t\t\n//转BCD\nbyte[] bcd = BCD.strToBcd(strForTest);\n//解码BCD\nString str = BCD.bcdToStr(bcd);\nAssert.assertEquals(strForTest, str);\n\n\n\n# 注意\n\n由于对ASCII的编码解码有缺陷，且这种BCD实现并不规范，因此会在6.0.0中移除',normalizedContent:'# 介绍\n\nbcd码（binary-coded decimal）亦称二进码十进数或二-十进制代码，bcd码这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。\n\n这种编码技巧最常用于会计系统的设计里，因为会计制度经常需要对很长的数字串作准确的计算。相对于一般的浮点式记数法，采用bcd码，既可保存数值的精确度，又可免却电脑作浮点运算时所耗费的时间。此外，对于其他需要高精确度的计算，bcd编码亦很常用。\n\nbcd码是四位二进制码, 也就是将十进制的数字转化为二进制, 但是和普通的转化有一点不同, 每一个十进制的数字0-9都对应着一个四位的二进制码,对应关系如下: 十进制0 对应 二进制0000;十进制1 对应二进制0001.......9=>1001 接下来的10就由两个上述的码来表示，表示为0001 0000。也就是bcd码是遇见1001就产生进位,不象普通的二进制码,到1111才产生进位10000\n\n\n# 方法\n\nstring strfortest = "123456abcdef";\n\t\t\n//转bcd\nbyte[] bcd = bcd.strtobcd(strfortest);\n//解码bcd\nstring str = bcd.bcdtostr(bcd);\nassert.assertequals(strfortest, str);\n\n\n\n# 注意\n\n由于对ascii的编码解码有缺陷，且这种bcd实现并不规范，因此会在6.0.0中移除',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"类加载工具-ClassLoaderUtil",frontmatter:{title:"类加载工具-ClassLoaderUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ClassLoaderUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/28.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%B7%A5%E5%85%B7-ClassLoaderUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/28.类加载工具-ClassLoaderUtil.md",key:"v-370b04f1",path:"/pages/ClassLoaderUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:54},{level:3,title:"获取ClassLoader",slug:"获取classloader",normalizedTitle:"获取classloader",charIndex:61},{level:4,title:"getContextClassLoader",slug:"getcontextclassloader",normalizedTitle:"getcontextclassloader",charIndex:78},{level:4,title:"getClassLoader",slug:"getclassloader",normalizedTitle:"getclassloader",charIndex:175},{level:3,title:"加载Class",slug:"加载class",normalizedTitle:"加载class",charIndex:344},{level:4,title:"loadClass",slug:"loadclass",normalizedTitle:"loadclass",charIndex:355},{level:4,title:"isPresent",slug:"ispresent",normalizedTitle:"ispresent",charIndex:644}],headersStr:"介绍 方法 获取ClassLoader getContextClassLoader getClassLoader 加载Class loadClass isPresent",content:"# 介绍\n\n提供ClassLoader相关的工具类，例如类加载（Class.forName包装）等\n\n\n# 方法\n\n\n# 获取ClassLoader\n\n# getContextClassLoader\n\n获取当前线程的ClassLoader，本质上调用Thread.currentThread().getContextClassLoader()\n\n# getClassLoader\n\n按照以下顺序规则查找获取ClassLoader：\n\n 1. 获取当前线程的ContextClassLoader\n 2. 获取ClassLoaderUtil类对应的ClassLoader\n 3. 获取系统ClassLoader（ClassLoader.getSystemClassLoader()）\n\n\n# 加载Class\n\n# loadClass\n\n加载类，通过传入类的字符串，返回其对应的类名，使用默认ClassLoader并初始化类（调用static模块内容和可选的初始化static属性）\n\n扩展Class.forName方法，支持以下几类类名的加载：\n\n 1. 原始类型，例如：int\n 2. 数组类型，例如：int[]、Long[]、String[]\n 3. 内部类，例如：java.lang.Thread.State会被转为java.lang.Thread$State加载\n\n同时提供loadPrimitiveClass方法用于快速加载原始类型的类。包括原始类型、原始类型数组和void\n\n# isPresent\n\n指定类是否被提供，通过调用loadClass方法尝试加载指定类名的类，如果加载失败返回false。\n\n加载失败的原因可能是此类不存在或其关联引用类不存在。",normalizedContent:"# 介绍\n\n提供classloader相关的工具类，例如类加载（class.forname包装）等\n\n\n# 方法\n\n\n# 获取classloader\n\n# getcontextclassloader\n\n获取当前线程的classloader，本质上调用thread.currentthread().getcontextclassloader()\n\n# getclassloader\n\n按照以下顺序规则查找获取classloader：\n\n 1. 获取当前线程的contextclassloader\n 2. 获取classloaderutil类对应的classloader\n 3. 获取系统classloader（classloader.getsystemclassloader()）\n\n\n# 加载class\n\n# loadclass\n\n加载类，通过传入类的字符串，返回其对应的类名，使用默认classloader并初始化类（调用static模块内容和可选的初始化static属性）\n\n扩展class.forname方法，支持以下几类类名的加载：\n\n 1. 原始类型，例如：int\n 2. 数组类型，例如：int[]、long[]、string[]\n 3. 内部类，例如：java.lang.thread.state会被转为java.lang.thread$state加载\n\n同时提供loadprimitiveclass方法用于快速加载原始类型的类。包括原始类型、原始类型数组和void\n\n# ispresent\n\n指定类是否被提供，通过调用loadclass方法尝试加载指定类名的类，如果加载失败返回false。\n\n加载失败的原因可能是此类不存在或其关联引用类不存在。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"控制台打印封装-Console",frontmatter:{title:"控制台打印封装-Console",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Console/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/06.%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/06.%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%B0%81%E8%A3%85-Console.html",relativePath:"01.指南/02.核心（Hutool-core）/06.语言特性/06.控制台打印封装-Console.md",key:"v-4341ea62",path:"/pages/Console/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:259}],headersStr:"由来 使用",content:'# 由来\n\n编码中我们常常需要调试输出一些信息，除了打印日志，最长用的要数System.out和System.err\n\n比如我们打印一个Hello World，可以这样写：\n\nSystem.out.println("Hello World");\n\n\n但是面对纷杂的打印需求，System.out.println无法满足，比如：\n\n 1. 不支持参数，对象打印需要拼接字符串\n 2. 不能直接打印数组，需要手动调用Arrays.toString\n\n考虑到以上问题，我封装了Console对象。\n\n> Console对象的使用更加类似于Javascript的console.log()方法，这也是借鉴了JS的一个语法糖。\n\n\n# 使用\n\n 1. Console.log 这个方法基本等同于System.out.println,但是支持类似于Slf4j的字符串模板语法，同时也会自动将对象（包括数组）转为字符串形式。\n\nString[] a = {"abc", "bcd", "def"};\nConsole.log(a);//控制台输出：[abc, bcd, def]\n\n\nConsole.log("This is Console log for {}.", "test");\n//控制台输出：This is Console log for test.\n\n\n 2. Console.error 这个方法基本等同于System.err.println，但是支持类似于Slf4j的字符串模板语法，同时也会自动将对象（包括数组）转为字符串形式。',normalizedContent:'# 由来\n\n编码中我们常常需要调试输出一些信息，除了打印日志，最长用的要数system.out和system.err\n\n比如我们打印一个hello world，可以这样写：\n\nsystem.out.println("hello world");\n\n\n但是面对纷杂的打印需求，system.out.println无法满足，比如：\n\n 1. 不支持参数，对象打印需要拼接字符串\n 2. 不能直接打印数组，需要手动调用arrays.tostring\n\n考虑到以上问题，我封装了console对象。\n\n> console对象的使用更加类似于javascript的console.log()方法，这也是借鉴了js的一个语法糖。\n\n\n# 使用\n\n 1. console.log 这个方法基本等同于system.out.println,但是支持类似于slf4j的字符串模板语法，同时也会自动将对象（包括数组）转为字符串形式。\n\nstring[] a = {"abc", "bcd", "def"};\nconsole.log(a);//控制台输出：[abc, bcd, def]\n\n\nconsole.log("this is console log for {}.", "test");\n//控制台输出：this is console log for test.\n\n\n 2. console.error 这个方法基本等同于system.err.println，但是支持类似于slf4j的字符串模板语法，同时也会自动将对象（包括数组）转为字符串形式。',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"字段验证器-Validator",frontmatter:{title:"字段验证器-Validator",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Validator/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/06.%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/07.%E5%AD%97%E6%AE%B5%E9%AA%8C%E8%AF%81%E5%99%A8-Validator.html",relativePath:"01.指南/02.核心（Hutool-core）/06.语言特性/07.字段验证器-Validator.md",key:"v-1d2ccb1c",path:"/pages/Validator/",headers:[{level:2,title:"作用",slug:"作用",normalizedTitle:"作用",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:52},{level:3,title:"判断验证",slug:"判断验证",normalizedTitle:"判断验证",charIndex:59},{level:3,title:"异常验证",slug:"异常验证",normalizedTitle:"异常验证",charIndex:326}],headersStr:"作用 使用 判断验证 异常验证",content:'# 作用\n\n验证给定字符串是否满足指定条件，一般用在表单字段验证里。\n\n此类中全部为静态方法。\n\n\n# 使用\n\n\n# 判断验证\n\n直接调用Validator.isXXX(String value)既可验证字段，返回是否通过验证。\n\n例如：\n\nboolean isEmail = Validator.isEmail("https://doc.hutool.cn/assets/js/loolly@gmail.com")\n\n\n表示验证给定字符串是否复合电子邮件格式。\n\n其他验证信息请参阅Validator类\n\n如果Validator里的方法无法满足自己的需求，那还可以调用\n\nValidator.isMatchRegex("需要验证字段的正则表达式", "被验证内容")\n\n\n通过正则表达式来灵活的验证内容。\n\n\n# 异常验证\n\n除了手动判断，我们有时需要在判断未满足条件时抛出一个异常，Validator同样提供异常验证机制：\n\nValidator.validateChinese("我是一段zhongwen", "内容中包含非中文");\n\n\n因为内容中包含非中文字符，因此会抛出ValidateException。',normalizedContent:'# 作用\n\n验证给定字符串是否满足指定条件，一般用在表单字段验证里。\n\n此类中全部为静态方法。\n\n\n# 使用\n\n\n# 判断验证\n\n直接调用validator.isxxx(string value)既可验证字段，返回是否通过验证。\n\n例如：\n\nboolean isemail = validator.isemail("https://doc.hutool.cn/assets/js/loolly@gmail.com")\n\n\n表示验证给定字符串是否复合电子邮件格式。\n\n其他验证信息请参阅validator类\n\n如果validator里的方法无法满足自己的需求，那还可以调用\n\nvalidator.ismatchregex("需要验证字段的正则表达式", "被验证内容")\n\n\n通过正则表达式来灵活的验证内容。\n\n\n# 异常验证\n\n除了手动判断，我们有时需要在判断未满足条件时抛出一个异常，validator同样提供异常验证机制：\n\nvalidator.validatechinese("我是一段zhongwen", "内容中包含非中文");\n\n\n因为内容中包含非中文字符，因此会抛出validateexception。',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"字符串格式化-StrFormatter",frontmatter:{title:"字符串格式化-StrFormatter",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/StrFormatter/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/06.%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/08.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96-StrFormatter.html",relativePath:"01.指南/02.核心（Hutool-core）/06.语言特性/08.字符串格式化-StrFormatter.md",key:"v-0bff2622",path:"/pages/StrFormatter/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:104}],headersStr:"由来 使用",content:'# 由来\n\n我一直对Slf4j的字符串格式化情有独钟，通过{}这种简单的占位符完成字符串的格式化。于是参考Slf4j的源码，便有了StrFormatter。\n\n> StrFormatter.format的快捷使用方式为StrUtil.format，推荐使用后者。\n\n\n# 使用\n\n//通常使用\nString result1 = StrFormatter.format("this is {} for {}", "a", "b");\nAssert.assertEquals("this is a for b", result1);\n\n//转义{}\nString result2 = StrFormatter.format("this is \\\\{} for {}", "a", "b");\nAssert.assertEquals("this is {} for a", result2);\n\n//转义\\\nString result3 = StrFormatter.format("this is \\\\\\\\{} for {}", "a", "b");\nAssert.assertEquals("this is \\\\a for b", result3);\n',normalizedContent:'# 由来\n\n我一直对slf4j的字符串格式化情有独钟，通过{}这种简单的占位符完成字符串的格式化。于是参考slf4j的源码，便有了strformatter。\n\n> strformatter.format的快捷使用方式为strutil.format，推荐使用后者。\n\n\n# 使用\n\n//通常使用\nstring result1 = strformatter.format("this is {} for {}", "a", "b");\nassert.assertequals("this is a for b", result1);\n\n//转义{}\nstring result2 = strformatter.format("this is \\\\{} for {}", "a", "b");\nassert.assertequals("this is {} for a", result2);\n\n//转义\\\nstring result3 = strformatter.format("this is \\\\\\\\{} for {}", "a", "b");\nassert.assertequals("this is \\\\a for b", result3);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"社会信用代码工具-CreditCodeUtil",frontmatter:{title:"社会信用代码工具-CreditCodeUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CreditCodeUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/05.%E5%B7%A5%E5%85%B7%E7%B1%BB/25.%E7%A4%BE%E4%BC%9A%E4%BF%A1%E7%94%A8%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7-CreditCodeUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/05.工具类/25.社会信用代码工具-CreditCodeUtil.md",key:"v-e85c093a",path:"/pages/CreditCodeUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:236},{level:3,title:"校验",slug:"校验",normalizedTitle:"校验",charIndex:197},{level:3,title:"随机社会信用代码",slug:"随机社会信用代码",normalizedTitle:"随机社会信用代码",charIndex:351}],headersStr:"介绍 使用 校验 随机社会信用代码",content:'# 介绍\n\n法人和其他组织统一社会信用代码制度，相当于让法人和其他组织拥有了一个全国统一的“身份证号”。\n\n规则如下：\n\n 1. 第一部分：登记管理部门代码1位 (数字或大写英文字母)\n 2. 第二部分：机构类别代码1位 (数字或大写英文字母)\n 3. 第三部分：登记管理机关行政区划码6位 (数字)\n 4. 第四部分：主体标识码（组织机构代码）9位 (数字或大写英文字母)\n 5. 第五部分：校验码1位 (数字或大写英文字母)\n\n此工具主要提供校验和随机生成。\n\n\n# 使用\n\n\n# 校验\n\nString testCreditCode = "91310110666007217T";\n// true\nCreditCodeUtil.isCreditCode(testCreditCode);\n\n\n\n# 随机社会信用代码\n\nfinal String s = CreditCodeUtil.randomCreditCode();\n',normalizedContent:'# 介绍\n\n法人和其他组织统一社会信用代码制度，相当于让法人和其他组织拥有了一个全国统一的“身份证号”。\n\n规则如下：\n\n 1. 第一部分：登记管理部门代码1位 (数字或大写英文字母)\n 2. 第二部分：机构类别代码1位 (数字或大写英文字母)\n 3. 第三部分：登记管理机关行政区划码6位 (数字)\n 4. 第四部分：主体标识码（组织机构代码）9位 (数字或大写英文字母)\n 5. 第五部分：校验码1位 (数字或大写英文字母)\n\n此工具主要提供校验和随机生成。\n\n\n# 使用\n\n\n# 校验\n\nstring testcreditcode = "91310110666007217t";\n// true\ncreditcodeutil.iscreditcode(testcreditcode);\n\n\n\n# 随机社会信用代码\n\nfinal string s = creditcodeutil.randomcreditcode();\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"树结构工具-TreeUtil",frontmatter:{title:"树结构工具-TreeUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/TreeUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/06.%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/09.%E6%A0%91%E7%BB%93%E6%9E%84/10.%E6%A0%91%E7%BB%93%E6%9E%84%E5%B7%A5%E5%85%B7-TreeUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/06.语言特性/09.树结构/10.树结构工具-TreeUtil.md",key:"v-6d760620",path:"/pages/TreeUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:249},{level:3,title:"定义结构",slug:"定义结构",normalizedTitle:"定义结构",charIndex:256},{level:3,title:"构建Tree",slug:"构建tree",normalizedTitle:"构建tree",charIndex:628},{level:3,title:"自定义字段名",slug:"自定义字段名",normalizedTitle:"自定义字段名",charIndex:206}],headersStr:"介绍 使用 定义结构 构建Tree 自定义字段名",content:'# 介绍\n\n考虑到菜单等需求的普遍性，有用户提交了一个扩展性极好的树状结构实现。这种树状结构可以根据配置文件灵活的定义节点之间的关系，也能很好的兼容关系数据库中数据。实现\n\n关系型数据库数据  <->  Tree  <->  JSON\n\n\n树状结构中最大的问题就是关系问题，在数据库中，每条数据通过某个字段关联自己的父节点，每个业务中这个字段的名字都不同，如何解决这个问题呢？\n\nPR的提供者提供了一种解决思路：自定义字段名，节点不再是一个bean，而是一个map，实现灵活的字段名定义。\n\n\n# 使用\n\n\n# 定义结构\n\n我们假设要构建一个菜单，可以实现系统管理和店铺管理，菜单的样子如下：\n\n系统管理\n    |- 用户管理\n    |- 添加用户\n\n店铺管理\n    |- 商品管理\n    |- 添加商品\n\n\n那这种结构如何保存在数据库中呢？一般是这样的：\n\nID    PARENTID   NAME   WEIGHT\n1     0          系统管理   5\n11    1          用户管理   10\n111   1          用户添加   11\n2     0          店铺管理   5\n21    2          商品管理   10\n221   2          添加添加   11\n\n我们看到，每条数据根据parentId相互关联并表示层级关系，parentId在这里也叫外键。\n\n\n# 构建Tree\n\n// 构建node列表\nList<TreeNode<String>> nodeList = CollUtil.newArrayList();\n\nnodeList.add(new TreeNode<>("1", "0", "系统管理", 5));\nnodeList.add(new TreeNode<>("11", "1", "用户管理", 222222));\nnodeList.add(new TreeNode<>("111", "11", "用户添加", 0));\nnodeList.add(new TreeNode<>("2", "0", "店铺管理", 1));\nnodeList.add(new TreeNode<>("21", "2", "商品管理", 44));\nnodeList.add(new TreeNode<>("221", "2", "商品管理2", 2));\n\n\n> TreeNode表示一个抽象的节点，也表示数据库中一行数据。 如果有其它数据，可以调用setExtra添加扩展字段。\n\n// 0表示最顶层的id是0\nList<Tree<String>> treeList = TreeUtil.build(nodeList, "0");\n\n\n因为两个Tree是平级的，再没有上层节点，因此为List。\n\n\n# 自定义字段名\n\n//配置\nTreeNodeConfig treeNodeConfig = new TreeNodeConfig();\n// 自定义属性名 都有默认值的\ntreeNodeConfig.setWeightKey("order");\ntreeNodeConfig.setIdKey("rid");\n// 最大递归深度\ntreeNodeConfig.setDeep(3);\n\n//转换器 (含义:找出父节点为字符串零的所有子节点, 并递归查找对应的子节点, 深度最多为 3)\nList<Tree<String>> treeNodes = TreeUtil.<TreeNode, String>build(nodeList, "0", treeNodeConfig,\n\t\t(treeNode, tree) -> {\n\t\t\ttree.setId(treeNode.getId());\n\t\t\ttree.setParentId(treeNode.getParentId());\n\t\t\ttree.setWeight(treeNode.getWeight());\n\t\t\ttree.setName(treeNode.getName());\n\t\t\t// 扩展属性 ...\n\t\t\ttree.putExtra("extraField", 666);\n\t\t\ttree.putExtra("other", new Object());\n\t\t});\n\n\n通过TreeNodeConfig我们可以自定义节点的名称、关系节点id名称，这样就可以和不同的数据库做对应。',normalizedContent:'# 介绍\n\n考虑到菜单等需求的普遍性，有用户提交了一个扩展性极好的树状结构实现。这种树状结构可以根据配置文件灵活的定义节点之间的关系，也能很好的兼容关系数据库中数据。实现\n\n关系型数据库数据  <->  tree  <->  json\n\n\n树状结构中最大的问题就是关系问题，在数据库中，每条数据通过某个字段关联自己的父节点，每个业务中这个字段的名字都不同，如何解决这个问题呢？\n\npr的提供者提供了一种解决思路：自定义字段名，节点不再是一个bean，而是一个map，实现灵活的字段名定义。\n\n\n# 使用\n\n\n# 定义结构\n\n我们假设要构建一个菜单，可以实现系统管理和店铺管理，菜单的样子如下：\n\n系统管理\n    |- 用户管理\n    |- 添加用户\n\n店铺管理\n    |- 商品管理\n    |- 添加商品\n\n\n那这种结构如何保存在数据库中呢？一般是这样的：\n\nid    parentid   name   weight\n1     0          系统管理   5\n11    1          用户管理   10\n111   1          用户添加   11\n2     0          店铺管理   5\n21    2          商品管理   10\n221   2          添加添加   11\n\n我们看到，每条数据根据parentid相互关联并表示层级关系，parentid在这里也叫外键。\n\n\n# 构建tree\n\n// 构建node列表\nlist<treenode<string>> nodelist = collutil.newarraylist();\n\nnodelist.add(new treenode<>("1", "0", "系统管理", 5));\nnodelist.add(new treenode<>("11", "1", "用户管理", 222222));\nnodelist.add(new treenode<>("111", "11", "用户添加", 0));\nnodelist.add(new treenode<>("2", "0", "店铺管理", 1));\nnodelist.add(new treenode<>("21", "2", "商品管理", 44));\nnodelist.add(new treenode<>("221", "2", "商品管理2", 2));\n\n\n> treenode表示一个抽象的节点，也表示数据库中一行数据。 如果有其它数据，可以调用setextra添加扩展字段。\n\n// 0表示最顶层的id是0\nlist<tree<string>> treelist = treeutil.build(nodelist, "0");\n\n\n因为两个tree是平级的，再没有上层节点，因此为list。\n\n\n# 自定义字段名\n\n//配置\ntreenodeconfig treenodeconfig = new treenodeconfig();\n// 自定义属性名 都有默认值的\ntreenodeconfig.setweightkey("order");\ntreenodeconfig.setidkey("rid");\n// 最大递归深度\ntreenodeconfig.setdeep(3);\n\n//转换器 (含义:找出父节点为字符串零的所有子节点, 并递归查找对应的子节点, 深度最多为 3)\nlist<tree<string>> treenodes = treeutil.<treenode, string>build(nodelist, "0", treenodeconfig,\n\t\t(treenode, tree) -> {\n\t\t\ttree.setid(treenode.getid());\n\t\t\ttree.setparentid(treenode.getparentid());\n\t\t\ttree.setweight(treenode.getweight());\n\t\t\ttree.setname(treenode.getname());\n\t\t\t// 扩展属性 ...\n\t\t\ttree.putextra("extrafield", 666);\n\t\t\ttree.putextra("other", new object());\n\t\t});\n\n\n通过treenodeconfig我们可以自定义节点的名称、关系节点id名称，这样就可以和不同的数据库做对应。',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/javaBean/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/07.JavaBean/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/02.核心（Hutool-core）/07.JavaBean/01.概述.md",key:"v-21bff5d0",path:"/pages/javaBean/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2}],headersStr:"概述",content:"# 概述\n\n针对JavaBean已经有BeanUtil的工具封装，我认为这还不够。最近看了Apache Commons BeanUtils的DynaBean源码和Nuts中Mirror类的文档（请看这里 -> 增强反射），启发颇多，于是我决定在Hutool中加入DynaBean。\n\nDyna即Dynamic，顾名思义，通过Java反射机制操作JavaBean，以达到动态语言的某些特性。\n\nbean包的另一个改进是针对PropertyDescriptor提供缓存。BeanInfoCache类缓存了通过内省获取到的PropertyDescriptor，以提高反射性能。",normalizedContent:"# 概述\n\n针对javabean已经有beanutil的工具封装，我认为这还不够。最近看了apache commons beanutils的dynabean源码和nuts中mirror类的文档（请看这里 -> 增强反射），启发颇多，于是我决定在hutool中加入dynabean。\n\ndyna即dynamic，顾名思义，通过java反射机制操作javabean，以达到动态语言的某些特性。\n\nbean包的另一个改进是针对propertydescriptor提供缓存。beaninfocache类缓存了通过内省获取到的propertydescriptor，以提高反射性能。",charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"DynaBean",frontmatter:{title:"DynaBean",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/DynaBean/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/07.JavaBean/03.DynaBean.html",relativePath:"01.指南/02.核心（Hutool-core）/07.JavaBean/03.DynaBean.md",key:"v-e698f07e",path:"/pages/DynaBean/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:15},{level:3,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:78},{level:3,title:"操作",slug:"操作",normalizedTitle:"操作",charIndex:23},{level:3,title:"invoke",slug:"invoke",normalizedTitle:"invoke",charIndex:619}],headersStr:"介绍 使用 创建 操作 invoke",content:'# 介绍\n\nDynaBean是使用反射机制动态操作JavaBean的一个封装类，通过这个类，可以通过传入字段名称的方式动态调用get和set方法，也可以动态创建JavaBean对象，亦或者执行JavaBean中的方法。\n\n\n# 使用\n\n我们先定义一个JavaBean：\n\n// Lombok注解\n@Data\npublic static class User{\n\tprivate String name;\n\tprivate int age;\n\t\n\tpublic String testMethod(){\n\t\treturn "test for " + this.name;\n\t}\n\n}\n\n\n\n# 创建\n\nDynaBean bean = DynaBean.create(user);\n//我们也可以通过反射构造对象\nDynaBean bean2 = DynaBean.create(User.class);\n\n\n\n# 操作\n\n我们通过DynaBean来包装并操作这个Bean\n\nUser user = new User();\nDynaBean bean = DynaBean.create(user);\nbean.set("name", "李华");\nbean.set("age", 12);\n\nString name = bean.get("name");//输出“李华”\n\n\n这样我们就可以像操作Map一样动态操作JavaBean\n\n\n# invoke\n\n除了标准的get和set方法，也可以调用invoke方法执行对象中的任意方法：\n\n//执行指定方法\nObject invoke = bean2.invoke("testMethod");\nAssert.assertEquals("test for 李华", invoke);\n\n\n> 说明: DynaBean默认实现了hashCode、equals和toString三个方法，这三个方法也是默认调用原对象的相应方法。',normalizedContent:'# 介绍\n\ndynabean是使用反射机制动态操作javabean的一个封装类，通过这个类，可以通过传入字段名称的方式动态调用get和set方法，也可以动态创建javabean对象，亦或者执行javabean中的方法。\n\n\n# 使用\n\n我们先定义一个javabean：\n\n// lombok注解\n@data\npublic static class user{\n\tprivate string name;\n\tprivate int age;\n\t\n\tpublic string testmethod(){\n\t\treturn "test for " + this.name;\n\t}\n\n}\n\n\n\n# 创建\n\ndynabean bean = dynabean.create(user);\n//我们也可以通过反射构造对象\ndynabean bean2 = dynabean.create(user.class);\n\n\n\n# 操作\n\n我们通过dynabean来包装并操作这个bean\n\nuser user = new user();\ndynabean bean = dynabean.create(user);\nbean.set("name", "李华");\nbean.set("age", 12);\n\nstring name = bean.get("name");//输出“李华”\n\n\n这样我们就可以像操作map一样动态操作javabean\n\n\n# invoke\n\n除了标准的get和set方法，也可以调用invoke方法执行对象中的任意方法：\n\n//执行指定方法\nobject invoke = bean2.invoke("testmethod");\nassert.assertequals("test for 李华", invoke);\n\n\n> 说明: dynabean默认实现了hashcode、equals和tostring三个方法，这三个方法也是默认调用原对象的相应方法。',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"Bean工具-BeanUtil",frontmatter:{title:"Bean工具-BeanUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/BeanUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/07.JavaBean/02.Bean%E5%B7%A5%E5%85%B7-BeanUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/07.JavaBean/02.Bean工具-BeanUtil.md",key:"v-52327694",path:"/pages/BeanUtil/",headers:[{level:2,title:"什么是Bean",slug:"什么是bean",normalizedTitle:"什么是bean",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:27},{level:3,title:"是否为Bean对象",slug:"是否为bean对象",normalizedTitle:"是否为bean对象",charIndex:328},{level:3,title:"内省 Introspector",slug:"内省-introspector",normalizedTitle:"内省 introspector",charIndex:502},{level:3,title:"Bean属性注入",slug:"bean属性注入",normalizedTitle:"bean属性注入",charIndex:915},{level:3,title:"Bean转为Map",slug:"bean转为map",normalizedTitle:"bean转为map",charIndex:3616},{level:3,title:"Bean转Bean",slug:"bean转bean",normalizedTitle:"bean转bean",charIndex:3866},{level:3,title:"Alias注解",slug:"alias注解",normalizedTitle:"alias注解",charIndex:4633}],headersStr:"什么是Bean 方法 是否为Bean对象 内省 Introspector Bean属性注入 Bean转为Map Bean转Bean Alias注解",content:'# 什么是Bean\n\n一个拥有对属性进行set和get方法的类，我们就可以称之为JavaBean。实际上JavaBean就是一个Java类，在这个Java类中默认形成了一种规则——对属性进行设置和获得。而反之，说Java类就一定是JavaBean，这种说法是错误的，因为一个java类中不一定有对属性的设置和获得的方法（也就是不一定有set和get方法）。\n\n通常Java中对Bean的定义是包含setXXX和getXXX方法的对象，在Hutool中，采取一种简单的判定Bean的方法：是否存在只有一个参数的setXXX方法。\n\nBean工具类主要是针对这些setXXX和getXXX方法进行操作，比如将Bean对象转为Map等等。\n\n\n# 方法\n\n\n# 是否为Bean对象\n\nBeanUtil.isBean方法根据是否存在只有一个参数的setXXX方法或者public类型的字段来判定是否是一个Bean对象。这样的判定方法主要目的是保证至少有一个setXXX方法用于属性注入。\n\nboolean isBean = BeanUtil.isBean(HashMap.class);//false\n\n\n\n# 内省 Introspector\n\n把一个类中需要进行设置和获得的属性的访问权限设置为private（私有的），让外部的使用者看不见摸不着，只能通过public（共有的）set和get方法对其属性的值进行设置和获得，而内部的操作具体是怎样的？外界使用的人不用知道，这就称为内省。\n\nHutool中对内省的封装包括：\n\n 1. BeanUtil.getPropertyDescriptors 获得Bean字段描述数组\n\nPropertyDescriptor[] propertyDescriptors = BeanUtil.getPropertyDescriptors(SubPerson.class);\n\n\n 2. BeanUtil.getFieldNamePropertyDescriptorMap 获得字段名和字段描述Map\n 3. BeanUtil.getPropertyDescriptor 获得指定字段的描述\n\n\n# Bean属性注入\n\nBeanUtil.fillBean方法是bean注入的核心方法，此方法传入一个ValueProvider接口，通过实现此接口来获得key对应的值。CopyOptions参数则提供一些注入属性的选项。\n\nCopyOptions的配置项包括：\n\n 1. editable 限制拷贝的属性必须为指定类中的属性，例如我只想从源对象中拷贝目标对象父类中的属性，就可以将editable设置为目标对象父类的Class。\n 2. ignoreNullValue 是否忽略空值，当源对象的值为null时，true: 忽略而不注入此值，false: 注入null\n 3. ignoreProperties 忽略的属性列表，设置一个属性列表，不拷贝这些属性值\n 4. ignoreError 是否忽略字段注入中发生的错误\n\n可以通过CopyOptions.create()方法创建一个默认的配置项，通过setXXX方法设置每个配置项。\n\nValueProvider接口需要实现两个方法：\n\n 1. value 方法是通过key和目标类型来从任何地方获取一个值，并转换为目标类型，如果返回值不和目标类型匹配，将会自动调用Convert.convert 方法转换。\n 2. containsKey方法主要是检测是否包含指定的key，如果不包含这个key，其对应的属性将会忽略注入。\n\n首先定义两个bean：\n\n// Lombok注解\n@Data\npublic class Person {\n    private String name;\n    private int age;\n}\n\n// Lombok注解\n@Data\npublic class SubPerson extends Person {\n    public static final String SUBNAME = "TEST";\n\n    private UUID id;\n    private String subName;\n    private Boolean isSlow;\n}\n\n\n然后注入这个bean：\n\nPerson person = BeanUtil.fillBean(new Person(), new ValueProvider<String>() {\n\n    @Override\n    public Object value(String key, Class<?> valueType) {\n        switch (key) {\n            case "name":\n                return "张三";\n            case "age":\n                return 18;\n        }\n        return null;\n    }\n\n    @Override\n    public boolean containsKey(String key) {\n        //总是存在key\n        return true;\n    }\n\n}, CopyOptions.create());\n\nAssert.assertEquals(person.getName(), "张三");\nAssert.assertEquals(person.getAge(), 18);\n\n\n基于BeanUtil.fillBean方法Hutool还提供了Map对象键值对注入Bean，其方法有：\n\n 1. BeanUtil.fillBeanWithMap 使用Map填充bean\n\nHashMap<String, Object> map = CollUtil.newHashMap();\nmap.put("name","Joe");\nmap.put("age",12);\nmap.put("openId","DFDFSDFWERWER");\n\nSubPerson person = BeanUtil.fillBeanWithMap(map, new SubPerson(), false);\n\n\n 2. BeanUtil.fillBeanWithMapIgnoreCase 使用Map填充bean，忽略大小写\n\nHashMap<String, Object> map = CollUtil.newHashMap();\nmap.put("Name","Joe");\nmap.put("aGe",12);\nmap.put("openId","DFDFSDFWERWER");\n\nSubPerson person = BeanUtil.fillBeanWithMapIgnoreCase(map, new SubPerson(), false);\n\n\n同时，Hutool还提供了BeanUtil.toBean 方法，用于map转bean，与fillBean不同的是，此处并不是传Bean对象，而是Bean类，Hutool会自动调用默认构造方法创建对象。当然，前提是Bean类有默认构造方法（空构造），这些方法有：\n\n 1. BeanUtil.toBean\n\nHashMap<String, Object> map = CollUtil.newHashMap();\nmap.put("a_name","Joe");\nmap.put("b_age",12);\n\n// 设置别名，用于对应bean的字段名\nHashMap<String, String> mapping = CollUtil.newHashMap();\nmapping.put("a_name","name");\nmapping.put("b_age","age");\n\nPerson person = BeanUtil.toBean(map, Person.class, CopyOptions.create().setFieldMapping(mapping));\n\n\n 2. BeanUtil.toBeanIgnoreCase\n\nHashMap<String, Object> map = CollUtil.newHashMap();\nmap.put("Name","Joe");\nmap.put("aGe",12);\n\nPerson person = BeanUtil.toBeanIgnoreCase(map, Person.class, false);\n\n\n\n# Bean转为Map\n\nBeanUtil.beanToMap方法则是将一个Bean对象转为Map对象。\n\nSubPerson person = new SubPerson();\nperson.setAge(14);\nperson.setOpenid("11213232");\nperson.setName("测试A11");\nperson.setSubName("sub名字");\n\nMap<String, Object> map = BeanUtil.beanToMap(person);\n\n\n\n# Bean转Bean\n\nBean之间的转换主要是相同属性的复制，因此方法名为copyProperties，此方法支持Bean和Map之间的字段复制。\n\nBeanUtil.copyProperties方法同样提供一个CopyOptions参数用于自定义属性复制。\n\nSubPerson p1 = new SubPerson();\np1.setSlow(true);\np1.setName("测试");\np1.setSubName("sub测试");\n\nMap<String, Object> map = MapUtil.newHashMap();\n\nBeanUtil.copyProperties(p1, map);\n\n\n5.6.6+加入 copyToList方法，遍历集合中每个Bean，复制其属性到另一个类型的对象中，最后返回一个新的List。\n\n\nList<Student> studentList = new ArrayList<>();\nStudent student = new Student();\nstudent.setName("张三");\nstudent.setAge(123);\nstudent.setNo(3158L);\nstudentList.add(student);\n\nStudent student2 = new Student();\nstudent.setName("李四");\nstudent.setAge(125);\nstudent.setNo(8848L);\nstudentList.add(student2);\n\n// 复制到 Person 类\nList<Person> people = BeanUtil.copyToList(studentList, Person.class);\n\n\n\n# Alias注解\n\n5.x的Hutool中增加了一个自定义注解：@Alias，通过此注解可以给Bean的字段设置别名。\n\n首先我们给Bean加上注解：\n\n// Lombok注解\n@Getter\n@Setter\npublic static class SubPersonWithAlias {\n    @Alias("aliasSubName")\n    private String subName;\n    private Boolean slow;\n\n\n\nSubPersonWithAlias person = new SubPersonWithAlias();\nperson.setSubName("sub名字");\nperson.setSlow(true);\n\n// Bean转换为Map时，自动将subName修改为aliasSubName\nMap<String, Object> map = BeanUtil.beanToMap(person);\n// 返回"sub名字"\nmap.get("aliasSubName")\n\n\n同样Alias注解支持注入Bean时使用别名：\n\nMap<String, Object> map = MapUtil.newHashMap();\nmap.put("aliasSubName","sub名字");\nmap.put("slow",true);\n\nSubPersonWithAlias subPersonWithAlias = BeanUtil.mapToBean(map, SubPersonWithAlias.class, false);\n// 返回"sub名字"\nsubPersonWithAlias.getSubName();\n',normalizedContent:'# 什么是bean\n\n一个拥有对属性进行set和get方法的类，我们就可以称之为javabean。实际上javabean就是一个java类，在这个java类中默认形成了一种规则——对属性进行设置和获得。而反之，说java类就一定是javabean，这种说法是错误的，因为一个java类中不一定有对属性的设置和获得的方法（也就是不一定有set和get方法）。\n\n通常java中对bean的定义是包含setxxx和getxxx方法的对象，在hutool中，采取一种简单的判定bean的方法：是否存在只有一个参数的setxxx方法。\n\nbean工具类主要是针对这些setxxx和getxxx方法进行操作，比如将bean对象转为map等等。\n\n\n# 方法\n\n\n# 是否为bean对象\n\nbeanutil.isbean方法根据是否存在只有一个参数的setxxx方法或者public类型的字段来判定是否是一个bean对象。这样的判定方法主要目的是保证至少有一个setxxx方法用于属性注入。\n\nboolean isbean = beanutil.isbean(hashmap.class);//false\n\n\n\n# 内省 introspector\n\n把一个类中需要进行设置和获得的属性的访问权限设置为private（私有的），让外部的使用者看不见摸不着，只能通过public（共有的）set和get方法对其属性的值进行设置和获得，而内部的操作具体是怎样的？外界使用的人不用知道，这就称为内省。\n\nhutool中对内省的封装包括：\n\n 1. beanutil.getpropertydescriptors 获得bean字段描述数组\n\npropertydescriptor[] propertydescriptors = beanutil.getpropertydescriptors(subperson.class);\n\n\n 2. beanutil.getfieldnamepropertydescriptormap 获得字段名和字段描述map\n 3. beanutil.getpropertydescriptor 获得指定字段的描述\n\n\n# bean属性注入\n\nbeanutil.fillbean方法是bean注入的核心方法，此方法传入一个valueprovider接口，通过实现此接口来获得key对应的值。copyoptions参数则提供一些注入属性的选项。\n\ncopyoptions的配置项包括：\n\n 1. editable 限制拷贝的属性必须为指定类中的属性，例如我只想从源对象中拷贝目标对象父类中的属性，就可以将editable设置为目标对象父类的class。\n 2. ignorenullvalue 是否忽略空值，当源对象的值为null时，true: 忽略而不注入此值，false: 注入null\n 3. ignoreproperties 忽略的属性列表，设置一个属性列表，不拷贝这些属性值\n 4. ignoreerror 是否忽略字段注入中发生的错误\n\n可以通过copyoptions.create()方法创建一个默认的配置项，通过setxxx方法设置每个配置项。\n\nvalueprovider接口需要实现两个方法：\n\n 1. value 方法是通过key和目标类型来从任何地方获取一个值，并转换为目标类型，如果返回值不和目标类型匹配，将会自动调用convert.convert 方法转换。\n 2. containskey方法主要是检测是否包含指定的key，如果不包含这个key，其对应的属性将会忽略注入。\n\n首先定义两个bean：\n\n// lombok注解\n@data\npublic class person {\n    private string name;\n    private int age;\n}\n\n// lombok注解\n@data\npublic class subperson extends person {\n    public static final string subname = "test";\n\n    private uuid id;\n    private string subname;\n    private boolean isslow;\n}\n\n\n然后注入这个bean：\n\nperson person = beanutil.fillbean(new person(), new valueprovider<string>() {\n\n    @override\n    public object value(string key, class<?> valuetype) {\n        switch (key) {\n            case "name":\n                return "张三";\n            case "age":\n                return 18;\n        }\n        return null;\n    }\n\n    @override\n    public boolean containskey(string key) {\n        //总是存在key\n        return true;\n    }\n\n}, copyoptions.create());\n\nassert.assertequals(person.getname(), "张三");\nassert.assertequals(person.getage(), 18);\n\n\n基于beanutil.fillbean方法hutool还提供了map对象键值对注入bean，其方法有：\n\n 1. beanutil.fillbeanwithmap 使用map填充bean\n\nhashmap<string, object> map = collutil.newhashmap();\nmap.put("name","joe");\nmap.put("age",12);\nmap.put("openid","dfdfsdfwerwer");\n\nsubperson person = beanutil.fillbeanwithmap(map, new subperson(), false);\n\n\n 2. beanutil.fillbeanwithmapignorecase 使用map填充bean，忽略大小写\n\nhashmap<string, object> map = collutil.newhashmap();\nmap.put("name","joe");\nmap.put("age",12);\nmap.put("openid","dfdfsdfwerwer");\n\nsubperson person = beanutil.fillbeanwithmapignorecase(map, new subperson(), false);\n\n\n同时，hutool还提供了beanutil.tobean 方法，用于map转bean，与fillbean不同的是，此处并不是传bean对象，而是bean类，hutool会自动调用默认构造方法创建对象。当然，前提是bean类有默认构造方法（空构造），这些方法有：\n\n 1. beanutil.tobean\n\nhashmap<string, object> map = collutil.newhashmap();\nmap.put("a_name","joe");\nmap.put("b_age",12);\n\n// 设置别名，用于对应bean的字段名\nhashmap<string, string> mapping = collutil.newhashmap();\nmapping.put("a_name","name");\nmapping.put("b_age","age");\n\nperson person = beanutil.tobean(map, person.class, copyoptions.create().setfieldmapping(mapping));\n\n\n 2. beanutil.tobeanignorecase\n\nhashmap<string, object> map = collutil.newhashmap();\nmap.put("name","joe");\nmap.put("age",12);\n\nperson person = beanutil.tobeanignorecase(map, person.class, false);\n\n\n\n# bean转为map\n\nbeanutil.beantomap方法则是将一个bean对象转为map对象。\n\nsubperson person = new subperson();\nperson.setage(14);\nperson.setopenid("11213232");\nperson.setname("测试a11");\nperson.setsubname("sub名字");\n\nmap<string, object> map = beanutil.beantomap(person);\n\n\n\n# bean转bean\n\nbean之间的转换主要是相同属性的复制，因此方法名为copyproperties，此方法支持bean和map之间的字段复制。\n\nbeanutil.copyproperties方法同样提供一个copyoptions参数用于自定义属性复制。\n\nsubperson p1 = new subperson();\np1.setslow(true);\np1.setname("测试");\np1.setsubname("sub测试");\n\nmap<string, object> map = maputil.newhashmap();\n\nbeanutil.copyproperties(p1, map);\n\n\n5.6.6+加入 copytolist方法，遍历集合中每个bean，复制其属性到另一个类型的对象中，最后返回一个新的list。\n\n\nlist<student> studentlist = new arraylist<>();\nstudent student = new student();\nstudent.setname("张三");\nstudent.setage(123);\nstudent.setno(3158l);\nstudentlist.add(student);\n\nstudent student2 = new student();\nstudent.setname("李四");\nstudent.setage(125);\nstudent.setno(8848l);\nstudentlist.add(student2);\n\n// 复制到 person 类\nlist<person> people = beanutil.copytolist(studentlist, person.class);\n\n\n\n# alias注解\n\n5.x的hutool中增加了一个自定义注解：@alias，通过此注解可以给bean的字段设置别名。\n\n首先我们给bean加上注解：\n\n// lombok注解\n@getter\n@setter\npublic static class subpersonwithalias {\n    @alias("aliassubname")\n    private string subname;\n    private boolean slow;\n\n\n\nsubpersonwithalias person = new subpersonwithalias();\nperson.setsubname("sub名字");\nperson.setslow(true);\n\n// bean转换为map时，自动将subname修改为aliassubname\nmap<string, object> map = beanutil.beantomap(person);\n// 返回"sub名字"\nmap.get("aliassubname")\n\n\n同样alias注解支持注入bean时使用别名：\n\nmap<string, object> map = maputil.newhashmap();\nmap.put("aliassubname","sub名字");\nmap.put("slow",true);\n\nsubpersonwithalias subpersonwithalias = beanutil.maptobean(map, subpersonwithalias.class, false);\n// 返回"sub名字"\nsubpersonwithalias.getsubname();\n',charsets:{cjk:!0},lastUpdated:"2024/01/31, 10:41:48",lastUpdatedTimestamp:1706668908e3},{title:"Bean描述-BeanDesc",frontmatter:{title:"Bean描述-BeanDesc",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/BeanDesc/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/07.JavaBean/05.Bean%E6%8F%8F%E8%BF%B0-BeanDesc.html",relativePath:"01.指南/02.核心（Hutool-core）/07.JavaBean/05.Bean描述-BeanDesc.md",key:"v-2f4ae390",path:"/pages/BeanDesc/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:407},{level:3,title:"字段getter方法获取",slug:"字段getter方法获取",normalizedTitle:"字段getter方法获取",charIndex:1362},{level:3,title:"字段属性赋值",slug:"字段属性赋值",normalizedTitle:"字段属性赋值",charIndex:1860}],headersStr:"介绍 使用 字段getter方法获取 字段属性赋值",content:'# 介绍\n\nHutool封装了Bean的信息描述来将一个Bean的相关信息全部通过反射解析出来，此类类似于JDK的BeanInfo，也可以理解为是这个类的强化版本。\n\nBeanDesc包含所有字段（属性）及对应的Getter方法和Setter方法，与BeanInfo不同的是，BeanDesc要求属性和getter、setter必须严格对应，即如果有非public属性，它没有对应的getter，则不能获取属性值，没有setter则不能注入属性值。\n\n属性和getter、setter关联规则如下：\n\n 1. 忽略字段和方法名的大小写（匹配时）\n 2. 字段名是XXX，则Getter查找getXXX、isXXX、getIsXXX\n 3. 字段名是XXX，Setter查找setXXX、setIsXXX\n 4. Setter忽略参数值与字段值类型不匹配的情况，因此有多个参数类型的重载时，会调用首次匹配的\n\n\n# 使用\n\n我们定义一个较为复杂的Bean：\n\npublic static class User {\n\tprivate String name;\n\tprivate int age;\n\tprivate boolean isAdmin;\n\tprivate boolean isSuper;\n\tprivate boolean gender;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic User setAge(int age) {\n\t\tthis.age = age;\n\t\treturn this;\n\t}\n\tpublic String testMethod() {\n\t\treturn "test for " + this.name;\n\t}\n\tpublic boolean isAdmin() {\n\t\treturn isAdmin;\n\t}\n\tpublic void setAdmin(boolean isAdmin) {\n\t\tthis.isAdmin = isAdmin;\n\t}\n\tpublic boolean isIsSuper() {\n\t\treturn isSuper;\n\t}\n\tpublic void setIsSuper(boolean isSuper) {\n\t\tthis.isSuper = isSuper;\n\t}\n\tpublic boolean isGender() {\n\t\treturn gender;\n\t}\n\tpublic void setGender(boolean gender) {\n\t\tthis.gender = gender;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn "User [name=" + name + ", age=" + age + ", isAdmin=" + isAdmin + ", gender=" + gender + "]";\n\t}\n}\n\n\n\n# 字段getter方法获取\n\n 1. 一般字段\n\nBeanDesc desc = BeanUtil.getBeanDesc(User.class);\n// User\ndesc.getSimpleName();\n\n// age\ndesc.getField("age").getName();\n// getAge\ndesc.getGetter("age").getName();\n// setAge\ndesc.getSetter("age").getName();\n\n\n 2. Boolean字段\n\n我们会发现User中的boolean字段叫做isAdmin，此时同名的getter也可以获取到：\n\nBeanDesc desc = BeanUtil.getBeanDesc(User.class);\n\n// isAdmin\ndesc.getGetter("isAdmin").getName();\n\n\n当然，用户如果觉得isIsXXX才是正确的，BeanDesc也可以完美获取，我们以isSuper字段为例：\n\n// isIsSuper\ndesc.getGetter("isSuper");\n\n\n\n# 字段属性赋值\n\nBeanDesc desc = BeanUtil.getBeanDesc(User.class);\nUser user = new User();\ndesc.getProp("name").setValue(user, "张三");\n',normalizedContent:'# 介绍\n\nhutool封装了bean的信息描述来将一个bean的相关信息全部通过反射解析出来，此类类似于jdk的beaninfo，也可以理解为是这个类的强化版本。\n\nbeandesc包含所有字段（属性）及对应的getter方法和setter方法，与beaninfo不同的是，beandesc要求属性和getter、setter必须严格对应，即如果有非public属性，它没有对应的getter，则不能获取属性值，没有setter则不能注入属性值。\n\n属性和getter、setter关联规则如下：\n\n 1. 忽略字段和方法名的大小写（匹配时）\n 2. 字段名是xxx，则getter查找getxxx、isxxx、getisxxx\n 3. 字段名是xxx，setter查找setxxx、setisxxx\n 4. setter忽略参数值与字段值类型不匹配的情况，因此有多个参数类型的重载时，会调用首次匹配的\n\n\n# 使用\n\n我们定义一个较为复杂的bean：\n\npublic static class user {\n\tprivate string name;\n\tprivate int age;\n\tprivate boolean isadmin;\n\tprivate boolean issuper;\n\tprivate boolean gender;\n\n\tpublic string getname() {\n\t\treturn name;\n\t}\n\tpublic void setname(string name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getage() {\n\t\treturn age;\n\t}\n\tpublic user setage(int age) {\n\t\tthis.age = age;\n\t\treturn this;\n\t}\n\tpublic string testmethod() {\n\t\treturn "test for " + this.name;\n\t}\n\tpublic boolean isadmin() {\n\t\treturn isadmin;\n\t}\n\tpublic void setadmin(boolean isadmin) {\n\t\tthis.isadmin = isadmin;\n\t}\n\tpublic boolean isissuper() {\n\t\treturn issuper;\n\t}\n\tpublic void setissuper(boolean issuper) {\n\t\tthis.issuper = issuper;\n\t}\n\tpublic boolean isgender() {\n\t\treturn gender;\n\t}\n\tpublic void setgender(boolean gender) {\n\t\tthis.gender = gender;\n\t}\n\t@override\n\tpublic string tostring() {\n\t\treturn "user [name=" + name + ", age=" + age + ", isadmin=" + isadmin + ", gender=" + gender + "]";\n\t}\n}\n\n\n\n# 字段getter方法获取\n\n 1. 一般字段\n\nbeandesc desc = beanutil.getbeandesc(user.class);\n// user\ndesc.getsimplename();\n\n// age\ndesc.getfield("age").getname();\n// getage\ndesc.getgetter("age").getname();\n// setage\ndesc.getsetter("age").getname();\n\n\n 2. boolean字段\n\n我们会发现user中的boolean字段叫做isadmin，此时同名的getter也可以获取到：\n\nbeandesc desc = beanutil.getbeandesc(user.class);\n\n// isadmin\ndesc.getgetter("isadmin").getname();\n\n\n当然，用户如果觉得isisxxx才是正确的，beandesc也可以完美获取，我们以issuper字段为例：\n\n// isissuper\ndesc.getgetter("issuper");\n\n\n\n# 字段属性赋值\n\nbeandesc desc = beanutil.getbeandesc(user.class);\nuser user = new user();\ndesc.getprop("name").setvalue(user, "张三");\n',charsets:{cjk:!0},lastUpdated:"2024/02/04, 10:04:53",lastUpdatedTimestamp:1707012293e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Coll/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/08.%E9%9B%86%E5%90%88%E7%B1%BB/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/02.核心（Hutool-core）/08.集合类/01.概述.md",key:"v-c0b5a14a",path:"/pages/Coll/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"Iterator相关帮助类",slug:"iterator相关帮助类",normalizedTitle:"iterator相关帮助类",charIndex:9}],headersStr:"介绍 Iterator相关帮助类",content:"# 介绍\n\n\n# Iterator相关帮助类\n\n集合包中封装了包括Enumeration、Iterator等的包装，这包括：\n\n * ArrayIterator 数组Iterator，便于数组利用Iterator方式遍历\n * CopiedIterator 为了解决并发情况下Iterator遍历导致的问题而封装的Iterator\n * EnumerationIterator Enumeration的Iterator表现形式\n * IteratorEnumeration Iterator的Enumeration表现形式\n\n同时提供了IterUtil和CollUtil工具类用于简化对Iterator和集合的操作。",normalizedContent:"# 介绍\n\n\n# iterator相关帮助类\n\n集合包中封装了包括enumeration、iterator等的包装，这包括：\n\n * arrayiterator 数组iterator，便于数组利用iterator方式遍历\n * copiediterator 为了解决并发情况下iterator遍历导致的问题而封装的iterator\n * enumerationiterator enumeration的iterator表现形式\n * iteratorenumeration iterator的enumeration表现形式\n\n同时提供了iterutil和collutil工具类用于简化对iterator和集合的操作。",charsets:{cjk:!0},lastUpdated:"2023/10/23, 14:33:13",lastUpdatedTimestamp:1698042793e3},{title:"集合工具-CollUtil",frontmatter:{title:"集合工具-CollUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CollUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/08.%E9%9B%86%E5%90%88%E7%B1%BB/02.%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7-CollUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/08.集合类/02.集合工具-CollUtil.md",key:"v-542d6867",path:"/pages/CollUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"join 方法",slug:"join-方法",normalizedTitle:"join 方法",charIndex:31},{level:3,title:"sortPageAll方法",slug:"sortpageall方法",normalizedTitle:"sortpageall方法",charIndex:300},{level:3,title:"popPart方法",slug:"poppart方法",normalizedTitle:"poppart方法",charIndex:1039},{level:3,title:"append方法",slug:"append方法",normalizedTitle:"append方法",charIndex:1101},{level:3,title:"7. resize方法",slug:"_7-resize方法",normalizedTitle:"7. resize方法",charIndex:1261},{level:3,title:"addAll方法",slug:"addall方法",normalizedTitle:"addall方法",charIndex:1343},{level:3,title:"sub方法",slug:"sub方法",normalizedTitle:"sub方法",charIndex:1379},{level:3,title:"isEmpty、isNotEmpty方法",slug:"isempty、isnotempty方法",normalizedTitle:"isempty、isnotempty方法",charIndex:1472},{level:3,title:"zip方法",slug:"zip方法",normalizedTitle:"zip方法",charIndex:1524}],headersStr:"介绍 join 方法 sortPageAll方法 popPart方法 append方法 7. resize方法 addAll方法 sub方法 isEmpty、isNotEmpty方法 zip方法",content:'# 介绍\n\n这个工具主要增加了对数组、集合类的操作。\n\n\n# join 方法\n\n将集合转换为字符串，这个方法还是挺常用的，是StrUtil.split的反方法。这个方法的参数支持各种类型对象的集合，最后连接每个对象的时候调用其toString()方法。栗子如下：\n\nString[] col= new String[]{"a","b","c","d","e"};\nList<String> colList = CollUtil.newArrayList(col);\n\nString str = CollUtil.join(colList, "#"); //str -> a#b#c#d#e\n\n\n\n# sortPageAll方法\n\n这个方法其实是一个组合方法，功能是：将给定的多个集合放到一个列表（List）中，根据给定的Comparator对象排序，然后分页取数据。这个方法非常类似于数据库多表查询后排序分页，这个方法存在的意义也是在此。使用此方法，栗子如下：\n\n//Integer比较器\nComparator<Integer> comparator = new Comparator<Integer>(){\n\t@Override\n\tpublic int compare(Integer o1, Integer o2) {\n\t\treturn o1.compareTo(o2);\n\t}\n};\n\n//新建三个列表，CollUtil.newArrayList方法表示新建ArrayList并填充元素\nList<Integer> list1 = CollUtil.newArrayList(1, 2, 3);\nList<Integer> list2 = CollUtil.newArrayList(4, 5, 6);\nList<Integer> list3 = CollUtil.newArrayList(7, 8, 9);\n\n//参数表示把list1,list2,list3合并并按照从小到大排序后，取0~2个（包括第0个，不包括第2个），结果是[1,2]\n@SuppressWarnings("unchecked")\nList<Integer> result = CollUtil.sortPageAll(0, 2, comparator, list1, list2, list3);\nSystem.out.println(result);     //输出 [1,2]\n\n\n\n# popPart方法\n\n这个方法传入一个栈对象，然后弹出指定数目的元素对象，弹出是指pop()方法，会从原栈中删掉。\n\n\n# append方法\n\n在给定数组里末尾加一个元素，其实List.add()也是这么实现的，这个方法存在的意义是只有少量的添加元素时使用，因为内部使用了System.arraycopy,每调用一次就要拷贝数组一次。这个方法也是为了在某些只能使用数组的情况下使用，省去了先要转成List，添加元素，再转成Array。\n\n\n# 7. resize方法\n\n重新调整数据的大小，如果调整后的大小比原来小，截断，如果比原来大，则多出的位置空着。（貌似List在扩充的时候会用到类似的方法）\n\n\n# addAll方法\n\n将多个数据添加到一个Collection中\n\n\n# sub方法\n\n对集合切片，其他类型的集合会转换成List，封装List.subList方法，自动修正越界等问题，完全避免IndexOutOfBoundsException异常。\n\n\n# isEmpty、isNotEmpty方法\n\n判断集合是否为空（包括null和没有元素的集合）。\n\n\n# zip方法\n\n此方法也是来源于Python的一个语法糖，给定两个集合，然后两个集合中的元素一一对应，组成一个Map。此方法还有一个重载方法，可以传字符，然后给定分隔符，字符串会被split成列表。栗子：\n\nCollection<String> keys = CollUtil.newArrayList("a", "b", "c", "d");\nCollection<Integer> values = CollUtil.newArrayList(1, 2, 3, 4);\n\n// {a=1,b=2,c=3,d=4}\nMap<String, Integer> map = CollUtil.zip(keys, values);\n',normalizedContent:'# 介绍\n\n这个工具主要增加了对数组、集合类的操作。\n\n\n# join 方法\n\n将集合转换为字符串，这个方法还是挺常用的，是strutil.split的反方法。这个方法的参数支持各种类型对象的集合，最后连接每个对象的时候调用其tostring()方法。栗子如下：\n\nstring[] col= new string[]{"a","b","c","d","e"};\nlist<string> collist = collutil.newarraylist(col);\n\nstring str = collutil.join(collist, "#"); //str -> a#b#c#d#e\n\n\n\n# sortpageall方法\n\n这个方法其实是一个组合方法，功能是：将给定的多个集合放到一个列表（list）中，根据给定的comparator对象排序，然后分页取数据。这个方法非常类似于数据库多表查询后排序分页，这个方法存在的意义也是在此。使用此方法，栗子如下：\n\n//integer比较器\ncomparator<integer> comparator = new comparator<integer>(){\n\t@override\n\tpublic int compare(integer o1, integer o2) {\n\t\treturn o1.compareto(o2);\n\t}\n};\n\n//新建三个列表，collutil.newarraylist方法表示新建arraylist并填充元素\nlist<integer> list1 = collutil.newarraylist(1, 2, 3);\nlist<integer> list2 = collutil.newarraylist(4, 5, 6);\nlist<integer> list3 = collutil.newarraylist(7, 8, 9);\n\n//参数表示把list1,list2,list3合并并按照从小到大排序后，取0~2个（包括第0个，不包括第2个），结果是[1,2]\n@suppresswarnings("unchecked")\nlist<integer> result = collutil.sortpageall(0, 2, comparator, list1, list2, list3);\nsystem.out.println(result);     //输出 [1,2]\n\n\n\n# poppart方法\n\n这个方法传入一个栈对象，然后弹出指定数目的元素对象，弹出是指pop()方法，会从原栈中删掉。\n\n\n# append方法\n\n在给定数组里末尾加一个元素，其实list.add()也是这么实现的，这个方法存在的意义是只有少量的添加元素时使用，因为内部使用了system.arraycopy,每调用一次就要拷贝数组一次。这个方法也是为了在某些只能使用数组的情况下使用，省去了先要转成list，添加元素，再转成array。\n\n\n# 7. resize方法\n\n重新调整数据的大小，如果调整后的大小比原来小，截断，如果比原来大，则多出的位置空着。（貌似list在扩充的时候会用到类似的方法）\n\n\n# addall方法\n\n将多个数据添加到一个collection中\n\n\n# sub方法\n\n对集合切片，其他类型的集合会转换成list，封装list.sublist方法，自动修正越界等问题，完全避免indexoutofboundsexception异常。\n\n\n# isempty、isnotempty方法\n\n判断集合是否为空（包括null和没有元素的集合）。\n\n\n# zip方法\n\n此方法也是来源于python的一个语法糖，给定两个集合，然后两个集合中的元素一一对应，组成一个map。此方法还有一个重载方法，可以传字符，然后给定分隔符，字符串会被split成列表。栗子：\n\ncollection<string> keys = collutil.newarraylist("a", "b", "c", "d");\ncollection<integer> values = collutil.newarraylist(1, 2, 3, 4);\n\n// {a=1,b=2,c=3,d=4}\nmap<string, integer> map = collutil.zip(keys, values);\n',charsets:{cjk:!0},lastUpdated:"2023/10/23, 14:33:13",lastUpdatedTimestamp:1698042793e3},{title:"列表工具-ListUtil",frontmatter:{title:"列表工具-ListUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ListUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/08.%E9%9B%86%E5%90%88%E7%B1%BB/03.%E5%88%97%E8%A1%A8%E5%B7%A5%E5%85%B7-ListUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/08.集合类/03.列表工具-ListUtil.md",key:"v-3808de6c",path:"/pages/ListUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:14},{level:3,title:"获取满足指定规则所有的元素的位置",slug:"获取满足指定规则所有的元素的位置",normalizedTitle:"获取满足指定规则所有的元素的位置",charIndex:62},{level:3,title:"拆分",slug:"拆分",normalizedTitle:"拆分",charIndex:255},{level:3,title:"编辑元素",slug:"编辑元素",normalizedTitle:"编辑元素",charIndex:629},{level:3,title:"查找位置",slug:"查找位置",normalizedTitle:"查找位置",charIndex:837},{level:3,title:"列表截取",slug:"列表截取",normalizedTitle:"列表截取",charIndex:1007},{level:3,title:"排序",slug:"排序",normalizedTitle:"排序",charIndex:1161},{level:3,title:"元素交换",slug:"元素交换",normalizedTitle:"元素交换",charIndex:1550},{level:3,title:"分页",slug:"分页",normalizedTitle:"分页",charIndex:1678},{level:3,title:"分组",slug:"分组",normalizedTitle:"分组",charIndex:1885}],headersStr:"介绍 使用 获取满足指定规则所有的元素的位置 拆分 编辑元素 查找位置 列表截取 排序 元素交换 分页 分组",content:'# 介绍\n\nList在集合中使用最为频繁，因此新版本的Hutool中针对List单独封装了工具方法。\n\n\n# 使用\n\n\n# 获取满足指定规则所有的元素的位置\n\nList<String> a = ListUtil.toLinkedList("1", "2", "3", "4", "3", "2", "1");\n// [1, 5]\nint[] indexArray = ListUtil.indexOfAll(a, "2"::equals);\n\n\n其他方法与CollUtil工具类似，很多工具也有重复。\n\n\n# 拆分\n\n对集合按照指定长度分段，每一个段为单独的集合，返回这个集合的列表：\n\nList<List<Object>> lists = ListUtil.split(Arrays.asList(1, 2, 3, 4), 1);\nList<List<Object>> lists = ListUtil.split(null, 3);\n\n\n也可以平均拆分，即平均分成N份，每份的数量差不超过1：\n\n// [[1, 2, 3, 4]]\nList<List<Object>> lists = ListUtil.splitAvg(Arrays.asList(1, 2, 3, 4), 1);\n\n// [[1, 2], [3], [4]]\nlists = ListUtil.splitAvg(Arrays.asList(1, 2, 3, 4), 3);\n\n\n\n# 编辑元素\n\n我们可以针对集合中所有元素按照给定的lambda定义规则修改元素：\n\nList<String> a = ListUtil.toLinkedList("1", "2", "3");\nfinal List<String> filter = (List<String>) CollUtil.edit(a, str -> "edit" + str);\n\n// edit1\nfilter.get(0);\n\n\n\n# 查找位置\n\nList<String> a = ListUtil.toLinkedList("1", "2", "3", "4", "3", "2", "1");\n\n// 查找所有2的位置\n// [1,5]\nfinal int[] indexArray = ListUtil.indexOfAll(a, "2"::equals);\n\n\n\n# 列表截取\n\nfinal List<Integer> of = ListUtil.of(1, 2, 3, 4);\n\n// [3, 4]\nfinal List<Integer> sub = ListUtil.sub(of, 2, 4);\n\n// 对子列表操作不影响原列表\nsub.remove(0);\n\n\n\n# 排序\n\n如我们想按照bean对象的order字段值排序：\n\n@Data\n@AllArgsConstructor\nclass TestBean{\n\tprivate int order;\n\tprivate String name;\n}\n\nfinal List<TestBean> beanList = ListUtil.toList(\n\t\tnew TestBean(2, "test2"),\n\t\tnew TestBean(1, "test1"),\n\t\tnew TestBean(5, "test5"),\n\t\tnew TestBean(4, "test4"),\n\t\tnew TestBean(3, "test3")\n\t\t);\n\nfinal List<TestBean> order = ListUtil.sortByProperty(beanList, "order");\n\n\n\n# 元素交换\n\n将指定元素和指定下标位置的元素交换位置\n\nList<Integer> list = Arrays.asList(7, 2, 8, 9);\n\n// 将元素8和下标为1的元素交换\nListUtil.swapTo(list, 8, 1);\n\n\n\n# 分页\n\n根据传入页码和每页条目数，返回该页拥有的所有数据（第一页的页码取决于PageUtil.getFirstPageNo()，默认为0）\n\nList<String> list = new ArrayList<>();\nlist.add("a");\nlist.add("b");\nlist.add("c");\nList<String> page = ListUtil.page(1, 2, list);\n\n\n\n# 分组\n\n通过传入分区长度，将指定列表为不同的块，每块区域的长度相同（最后一块可能小于长度）\n\nList<String> list = new ArrayList<>();\nlist.add("a");\nlist.add("b");\nlist.add("c");\nList<List<String>> partition = ListUtil.partition(list, 2);\n',normalizedContent:'# 介绍\n\nlist在集合中使用最为频繁，因此新版本的hutool中针对list单独封装了工具方法。\n\n\n# 使用\n\n\n# 获取满足指定规则所有的元素的位置\n\nlist<string> a = listutil.tolinkedlist("1", "2", "3", "4", "3", "2", "1");\n// [1, 5]\nint[] indexarray = listutil.indexofall(a, "2"::equals);\n\n\n其他方法与collutil工具类似，很多工具也有重复。\n\n\n# 拆分\n\n对集合按照指定长度分段，每一个段为单独的集合，返回这个集合的列表：\n\nlist<list<object>> lists = listutil.split(arrays.aslist(1, 2, 3, 4), 1);\nlist<list<object>> lists = listutil.split(null, 3);\n\n\n也可以平均拆分，即平均分成n份，每份的数量差不超过1：\n\n// [[1, 2, 3, 4]]\nlist<list<object>> lists = listutil.splitavg(arrays.aslist(1, 2, 3, 4), 1);\n\n// [[1, 2], [3], [4]]\nlists = listutil.splitavg(arrays.aslist(1, 2, 3, 4), 3);\n\n\n\n# 编辑元素\n\n我们可以针对集合中所有元素按照给定的lambda定义规则修改元素：\n\nlist<string> a = listutil.tolinkedlist("1", "2", "3");\nfinal list<string> filter = (list<string>) collutil.edit(a, str -> "edit" + str);\n\n// edit1\nfilter.get(0);\n\n\n\n# 查找位置\n\nlist<string> a = listutil.tolinkedlist("1", "2", "3", "4", "3", "2", "1");\n\n// 查找所有2的位置\n// [1,5]\nfinal int[] indexarray = listutil.indexofall(a, "2"::equals);\n\n\n\n# 列表截取\n\nfinal list<integer> of = listutil.of(1, 2, 3, 4);\n\n// [3, 4]\nfinal list<integer> sub = listutil.sub(of, 2, 4);\n\n// 对子列表操作不影响原列表\nsub.remove(0);\n\n\n\n# 排序\n\n如我们想按照bean对象的order字段值排序：\n\n@data\n@allargsconstructor\nclass testbean{\n\tprivate int order;\n\tprivate string name;\n}\n\nfinal list<testbean> beanlist = listutil.tolist(\n\t\tnew testbean(2, "test2"),\n\t\tnew testbean(1, "test1"),\n\t\tnew testbean(5, "test5"),\n\t\tnew testbean(4, "test4"),\n\t\tnew testbean(3, "test3")\n\t\t);\n\nfinal list<testbean> order = listutil.sortbyproperty(beanlist, "order");\n\n\n\n# 元素交换\n\n将指定元素和指定下标位置的元素交换位置\n\nlist<integer> list = arrays.aslist(7, 2, 8, 9);\n\n// 将元素8和下标为1的元素交换\nlistutil.swapto(list, 8, 1);\n\n\n\n# 分页\n\n根据传入页码和每页条目数，返回该页拥有的所有数据（第一页的页码取决于pageutil.getfirstpageno()，默认为0）\n\nlist<string> list = new arraylist<>();\nlist.add("a");\nlist.add("b");\nlist.add("c");\nlist<string> page = listutil.page(1, 2, list);\n\n\n\n# 分组\n\n通过传入分区长度，将指定列表为不同的块，每块区域的长度相同（最后一块可能小于长度）\n\nlist<string> list = new arraylist<>();\nlist.add("a");\nlist.add("b");\nlist.add("c");\nlist<list<string>> partition = listutil.partition(list, 2);\n',charsets:{cjk:!0},lastUpdated:"2023/10/23, 14:33:13",lastUpdatedTimestamp:1698042793e3},{title:"表达式解析-BeanPath",frontmatter:{title:"表达式解析-BeanPath",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/BeanPath/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/07.JavaBean/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90-BeanPath.html",relativePath:"01.指南/02.核心（Hutool-core）/07.JavaBean/04.表达式解析-BeanPath.md",key:"v-aca3c1ea",path:"/pages/BeanPath/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:122},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:80}],headersStr:"由来 原理 使用",content:'# 由来\n\n很多JavaBean嵌套着很多层对象，这其中还夹杂着Map、Collection等对象，因此获取太深的嵌套对象会让代码变得冗长不堪。因此我们可以考虑使用一种表达式来获取指定深度的对象，于是BeanResolver应运而生。\n\n\n# 原理\n\n通过传入一个表达式，按照表达式的规则获取bean中指定的字段值。\n\n表达式分为两种：\n\n * .表达式，可以获取Bean对象中的属性（字段）值或者Map中key对应的值\n * []表达式，可以获取集合等对象中对应index的值\n\n栗子：\n\n 1. person 获取Bean对象下person字段的值，或者Bean本身如果是Person对象，返回本身。\n 2. person.name 获取Bean中person字段下name字段的值，或者Bean本身如果是Person对象，返回其name字段的值。\n 3. persons[3] 获取persons字段下第三个元素的值（假设person是数组或Collection对象）\n 4. person.friends[5].name 获取person字段下friends列表（或数组）的第5个元素对象的name属性\n\n\n# 使用\n\n由于嵌套Bean定义过于复杂，在此我们省略，有兴趣的可以看下这里：cn.hutool.core.lang.test.bean（src/test/java下）下定义了测试用例用的bean。\n\n首先我们创建这个复杂的Bean（实际当中这个复杂的Bean可能是从数据库中获取，或者从JSON转入）\n\n这个复杂Bean的关系是这样的：\n\n定义一个Map包含用户信息（UserInfoDict）和一个标志位（flag），用户信息包括一些基本信息和一个考试信息列表（ExamInfoDict）。\n\n//------------------------------------------------- 考试信息列表\nExamInfoDict examInfoDict = new ExamInfoDict();\nexamInfoDict.setId(1);\nexamInfoDict.setExamType(0);\nexamInfoDict.setAnswerIs(1);\n\nExamInfoDict examInfoDict1 = new ExamInfoDict();\nexamInfoDict1.setId(2);\nexamInfoDict1.setExamType(0);\nexamInfoDict1.setAnswerIs(0);\n\nExamInfoDict examInfoDict2 = new ExamInfoDict();\nexamInfoDict2.setId(3);\nexamInfoDict2.setExamType(1);\nexamInfoDict2.setAnswerIs(0);\n\nList<ExamInfoDict> examInfoDicts = new ArrayList<ExamInfoDict>();\nexamInfoDicts.add(examInfoDict);\nexamInfoDicts.add(examInfoDict1);\nexamInfoDicts.add(examInfoDict2);\n\n//------------------------------------------------- 用户信息\nUserInfoDict userInfoDict = new UserInfoDict();\nuserInfoDict.setId(1);\nuserInfoDict.setPhotoPath("https://doc.hutool.cn/assets/js/yx.mm.com");\nuserInfoDict.setRealName("张三");\nuserInfoDict.setExamInfoDict(examInfoDicts);\n\nMap<String, Object> tempMap = new HashMap<String, Object>();\ntempMap.put("userInfo", userInfoDict);\ntempMap.put("flag", 1);\n\n\n下面，我们使用BeanPath获取这个Map下此用户第一门考试的ID：\n\nBeanPath resolver = new BeanPath("https://doc.hutool.cn/assets/js/userInfo.examInfoDict[0].id");\nObject result = resolver.get(tempMap);//ID为1\n\n\n只需两句（甚至一句）即可完成复杂Bean中各层次对象的获取。\n\n> 说明： 为了简化BeanPath的使用，Hutool在BeanUtil中也加入了快捷入口方法：BeanUtil.getProperty，这个方法的命名更容易理解（毕竟BeanPath不但可以解析Bean，而且可以解析Map和集合）。',normalizedContent:'# 由来\n\n很多javabean嵌套着很多层对象，这其中还夹杂着map、collection等对象，因此获取太深的嵌套对象会让代码变得冗长不堪。因此我们可以考虑使用一种表达式来获取指定深度的对象，于是beanresolver应运而生。\n\n\n# 原理\n\n通过传入一个表达式，按照表达式的规则获取bean中指定的字段值。\n\n表达式分为两种：\n\n * .表达式，可以获取bean对象中的属性（字段）值或者map中key对应的值\n * []表达式，可以获取集合等对象中对应index的值\n\n栗子：\n\n 1. person 获取bean对象下person字段的值，或者bean本身如果是person对象，返回本身。\n 2. person.name 获取bean中person字段下name字段的值，或者bean本身如果是person对象，返回其name字段的值。\n 3. persons[3] 获取persons字段下第三个元素的值（假设person是数组或collection对象）\n 4. person.friends[5].name 获取person字段下friends列表（或数组）的第5个元素对象的name属性\n\n\n# 使用\n\n由于嵌套bean定义过于复杂，在此我们省略，有兴趣的可以看下这里：cn.hutool.core.lang.test.bean（src/test/java下）下定义了测试用例用的bean。\n\n首先我们创建这个复杂的bean（实际当中这个复杂的bean可能是从数据库中获取，或者从json转入）\n\n这个复杂bean的关系是这样的：\n\n定义一个map包含用户信息（userinfodict）和一个标志位（flag），用户信息包括一些基本信息和一个考试信息列表（examinfodict）。\n\n//------------------------------------------------- 考试信息列表\nexaminfodict examinfodict = new examinfodict();\nexaminfodict.setid(1);\nexaminfodict.setexamtype(0);\nexaminfodict.setansweris(1);\n\nexaminfodict examinfodict1 = new examinfodict();\nexaminfodict1.setid(2);\nexaminfodict1.setexamtype(0);\nexaminfodict1.setansweris(0);\n\nexaminfodict examinfodict2 = new examinfodict();\nexaminfodict2.setid(3);\nexaminfodict2.setexamtype(1);\nexaminfodict2.setansweris(0);\n\nlist<examinfodict> examinfodicts = new arraylist<examinfodict>();\nexaminfodicts.add(examinfodict);\nexaminfodicts.add(examinfodict1);\nexaminfodicts.add(examinfodict2);\n\n//------------------------------------------------- 用户信息\nuserinfodict userinfodict = new userinfodict();\nuserinfodict.setid(1);\nuserinfodict.setphotopath("https://doc.hutool.cn/assets/js/yx.mm.com");\nuserinfodict.setrealname("张三");\nuserinfodict.setexaminfodict(examinfodicts);\n\nmap<string, object> tempmap = new hashmap<string, object>();\ntempmap.put("userinfo", userinfodict);\ntempmap.put("flag", 1);\n\n\n下面，我们使用beanpath获取这个map下此用户第一门考试的id：\n\nbeanpath resolver = new beanpath("https://doc.hutool.cn/assets/js/userinfo.examinfodict[0].id");\nobject result = resolver.get(tempmap);//id为1\n\n\n只需两句（甚至一句）即可完成复杂bean中各层次对象的获取。\n\n> 说明： 为了简化beanpath的使用，hutool在beanutil中也加入了快捷入口方法：beanutil.getproperty，这个方法的命名更容易理解（毕竟beanpath不但可以解析bean，而且可以解析map和集合）。',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"Iterator工具-IterUtil",frontmatter:{title:"Iterator工具-IterUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/IterUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/08.%E9%9B%86%E5%90%88%E7%B1%BB/04.Iterator%E5%B7%A5%E5%85%B7-IterUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/08.集合类/04.Iterator工具-IterUtil.md",key:"v-2a9d6a55",path:"/pages/IterUtil/",headers:[{level:2,title:"来源",slug:"来源",normalizedTitle:"来源",charIndex:2},{level:2,title:"方法介绍",slug:"方法介绍",normalizedTitle:"方法介绍",charIndex:57}],headersStr:"来源 方法介绍",content:"# 来源\n\n最早此工具类中的方法是在CollUtil中的，由于经过抽象，因此单独拿出来以适应更广的场景。\n\n\n# 方法介绍\n\n * isEmpty 是否为null或者无元素\n * isNotEmpty 是否为非null或者至少有一个元素\n * hasNull 是否有null元素\n * isAllNull 是否全部为null元素\n * countMap 根据集合返回一个元素计数的Map，所谓元素计数就是假如这个集合中某个元素出现了n次，那将这个元素做为key，n做为value\n * join 使用分隔符将集合转换为字符串\n * toMap 将Entry列表转为Map，或者将key列表和value列表合并为Map\n * asIterator Enumeration转Iterator\n * asIterable Iterator转Iterable\n * getFirst 获取列表的第一个元素\n * getElementType 获取元素类型",normalizedContent:"# 来源\n\n最早此工具类中的方法是在collutil中的，由于经过抽象，因此单独拿出来以适应更广的场景。\n\n\n# 方法介绍\n\n * isempty 是否为null或者无元素\n * isnotempty 是否为非null或者至少有一个元素\n * hasnull 是否有null元素\n * isallnull 是否全部为null元素\n * countmap 根据集合返回一个元素计数的map，所谓元素计数就是假如这个集合中某个元素出现了n次，那将这个元素做为key，n做为value\n * join 使用分隔符将集合转换为字符串\n * tomap 将entry列表转为map，或者将key列表和value列表合并为map\n * asiterator enumeration转iterator\n * asiterable iterator转iterable\n * getfirst 获取列表的第一个元素\n * getelementtype 获取元素类型",charsets:{cjk:!0},lastUpdated:"2023/10/23, 14:33:13",lastUpdatedTimestamp:1698042793e3},{title:"有界优先队列-BoundedPriorityQueue",frontmatter:{title:"有界优先队列-BoundedPriorityQueue",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/BoundedPriorityQueue/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/08.%E9%9B%86%E5%90%88%E7%B1%BB/05.%E6%9C%89%E7%95%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-BoundedPriorityQueue.html",relativePath:"01.指南/02.核心（Hutool-core）/08.集合类/05.有界优先队列-BoundedPriorityQueue.md",key:"v-74b8d654",path:"/pages/BoundedPriorityQueue/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2}],headersStr:"简介",content:"# 简介\n\n举个例子。我有一个用户表，这个表根据用户名被Hash到不同的数据库实例上，我要找出这些用户中最热门的5个，怎么做？我是这么做的：\n\n 1. 在每个数据库实例上找出最热门的5个\n 2. 将每个数据库实例上的这5条数据按照热门程度排序，最后取出前5条\n\n这个过程看似简单，但是你应用服务器上的代码要写不少。首先需要Query N个列表，加入到一个新列表中，排序，再取前5。这个过程不但代码繁琐，而且牵涉到多个列表，非常浪费空间。\n\n于是，BoundedPriorityQueue应运而生。\n\n先看Demo：\n\n/**\n * 有界优先队列Demo\n * @author Looly\n *\n */\npublic class BoundedPriorityQueueDemo {\n\t\n\tpublic static void main(String[] args) {\n\t\t//初始化队列，设置队列的容量为5（只能容纳5个元素），元素类型为integer使用默认比较器，在队列内部将按照从小到大排序\n\t\tBoundedPriorityQueue<Integer> queue = new BoundedPriorityQueue<Integer>(5);\n\t\t\n\t\t//初始化队列，使用自定义的比较器\n\t\tqueue = new BoundedPriorityQueue<>(5, new Comparator<Integer>(){\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o1.compareTo(o2);\n\t\t\t}\n\t\t});\n\t\t\n\t\t//定义了6个元素，当元素加入到队列中，会按照从小到大排序，当加入第6个元素的时候，队列末尾（最大的元素）将会被抛弃\n\t\tint[] array = new int[]{5,7,9,2,3,8};\n\t\tfor (int i : array) {\n\t\t\tqueue.offer(i);\n\t\t}\n\t\t\n\t\t//队列可以转换为List哦~~\n\t\tArrayList<Integer> list = queue.toList();\n\n\t\tSystem.out.println(queue);\n\t}\n}\n\n\n原理非常简单。设定好队列的容量，然后把所有的数据add或者offer进去（两个方法相同），就会得到前5条数据了。",normalizedContent:"# 简介\n\n举个例子。我有一个用户表，这个表根据用户名被hash到不同的数据库实例上，我要找出这些用户中最热门的5个，怎么做？我是这么做的：\n\n 1. 在每个数据库实例上找出最热门的5个\n 2. 将每个数据库实例上的这5条数据按照热门程度排序，最后取出前5条\n\n这个过程看似简单，但是你应用服务器上的代码要写不少。首先需要query n个列表，加入到一个新列表中，排序，再取前5。这个过程不但代码繁琐，而且牵涉到多个列表，非常浪费空间。\n\n于是，boundedpriorityqueue应运而生。\n\n先看demo：\n\n/**\n * 有界优先队列demo\n * @author looly\n *\n */\npublic class boundedpriorityqueuedemo {\n\t\n\tpublic static void main(string[] args) {\n\t\t//初始化队列，设置队列的容量为5（只能容纳5个元素），元素类型为integer使用默认比较器，在队列内部将按照从小到大排序\n\t\tboundedpriorityqueue<integer> queue = new boundedpriorityqueue<integer>(5);\n\t\t\n\t\t//初始化队列，使用自定义的比较器\n\t\tqueue = new boundedpriorityqueue<>(5, new comparator<integer>(){\n\n\t\t\t@override\n\t\t\tpublic int compare(integer o1, integer o2) {\n\t\t\t\treturn o1.compareto(o2);\n\t\t\t}\n\t\t});\n\t\t\n\t\t//定义了6个元素，当元素加入到队列中，会按照从小到大排序，当加入第6个元素的时候，队列末尾（最大的元素）将会被抛弃\n\t\tint[] array = new int[]{5,7,9,2,3,8};\n\t\tfor (int i : array) {\n\t\t\tqueue.offer(i);\n\t\t}\n\t\t\n\t\t//队列可以转换为list哦~~\n\t\tarraylist<integer> list = queue.tolist();\n\n\t\tsystem.out.println(queue);\n\t}\n}\n\n\n原理非常简单。设定好队列的容量，然后把所有的数据add或者offer进去（两个方法相同），就会得到前5条数据了。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"线程安全的HashSet-ConcurrentHashSet",frontmatter:{title:"线程安全的HashSet-ConcurrentHashSet",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ConcurrentHashSet/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/08.%E9%9B%86%E5%90%88%E7%B1%BB/06.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashSet-ConcurrentHashSet.html",relativePath:"01.指南/02.核心（Hutool-core）/08.集合类/06.线程安全的HashSet-ConcurrentHashSet.md",key:"v-04450b9b",path:"/pages/ConcurrentHashSet/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:131}],headersStr:"简介 使用",content:'# 简介\n\n我们知道，JDK提供了线程安全的HashMap：ConcurrentHashMap，但是没有提供对应的ConcurrentHashSet，Hutool借助ConcurrentHashMap封装了线程安全的ConcurrentHashSet。\n\n\n# 使用\n\n与普通的HashSet使用一致:\n\nSet<String> set = new ConcurrentHashSet<>();\nset.add("a");\nset.add("b");\n',normalizedContent:'# 简介\n\n我们知道，jdk提供了线程安全的hashmap：concurrenthashmap，但是没有提供对应的concurrenthashset，hutool借助concurrenthashmap封装了线程安全的concurrenthashset。\n\n\n# 使用\n\n与普通的hashset使用一致:\n\nset<string> set = new concurrenthashset<>();\nset.add("a");\nset.add("b");\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"空检查属性获取-Opt",frontmatter:{title:"空检查属性获取-Opt",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Opt/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/07.JavaBean/06.%E7%A9%BA%E6%A3%80%E6%9F%A5%E5%B1%9E%E6%80%A7%E8%8E%B7%E5%8F%96-Opt.html",relativePath:"01.指南/02.核心（Hutool-core）/07.JavaBean/06.空检查属性获取-Opt.md",key:"v-e4981322",path:"/pages/Opt/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:71},{level:2,title:"学习：",slug:"学习",normalizedTitle:"学习：",charIndex:2574}],headersStr:"介绍 使用 学习：",content:'# 介绍\n\n在嵌套对象的属性获取中，由于子对象无法得知是否为null，每次获取属性都要检查属性对象是否为null，使得代码会变得特备臃肿，因此使用Opt来优雅的链式获取属性对象值。\n\n> 声明：此类的作者：阿超 ，PR来自：https://gitee.com/dromara/hutool/pulls/426\n\n\n# 使用\n\n我们先定义一个嵌套的Bean：\n\n// Lombok注解\n@Data\npublic static class User {\n\tprivate String name;\n\tprivate String gender;\n\tprivate School school;\n\t\n\t@Data\n\tpublic static class School {\n\t\tprivate String name;\n\t\tprivate String address;\n\t}\n}\n\n\n假设我们想获取address属性，则：\n\nUser user = new User();\nuser.setName("hello");\n\n// null\nString addressValue = Opt.ofNullable(user)\n\t\t.map(User::getSchool)\n\t\t.map(User.School::getAddress).get();\n\n\n由于school对象的值为null，一般直接获取会报空指针，使用Opt即可避免判断。\n\n * ofBlankAble函数基于ofNullable的逻辑下，额外进行了空字符串判断\n\n// ofBlankAble相对于ofNullable考虑了字符串为空串的情况\nString hutool = Opt.ofBlankAble("").orElse("hutool");\nAssert.equals("hutool", hutool);\n\n\n * 和原版Optional有区别的是，Opt.get()不会抛出NoSuchElementException\n * 如果想像原版Optional中的get那样，获取一个一定不为空的值，则应该使用orElseThrow\n\nObject opt = Opt.ofNullable(null).get();\nAssert.isNull(isEmpty);\n\n\n * 这是参考了jdk11 Optional中的新函数isEmpty，用于判断不存在值的情况\n\n// 判断包裹内元素是否为空，注意并没有判断空字符串的情况\nboolean isEmpty = Opt.empty().isEmpty();\nAssert.isTrue(isEmpty);\n\n\n * 灵感来源于jdk9 Optional中的新函数ifPresentOrElse，用于 存在值时执行某些操作，不存在值时执行另一个操作，支持链式编程\n\n// 存在就打印对应的值，不存在则用System.err.println打印另一句字符串\nOpt.ofNullable("Hello Hutool!").ifPresentOrElse(System.out::println, () -> System.err.println("Ops!Something is wrong!"));\nOpt.empty().ifPresentOrElse(System.out::println, () -> System.err.println("Ops!Something is wrong!"));\n\n\n * 新增了peek函数，相当于ifPresent的链式调用（个人常用）\n\nUser user = new User();\n// 相当于ifPresent的链式调用\nOpt.ofNullable("hutool").peek(user::setUsername).peek(user::setNickname);\nAssert.equals("hutool", user.getNickname());\nAssert.equals("hutool", user.getUsername());\n\n// 注意，传入的lambda中，对包裹内的元素执行赋值操作并不会影响到原来的元素\nString name = Opt.ofNullable("hutool").peek(username -> username = "123").peek(username -> username = "456").get();\nAssert.equals("hutool", name);\n\n\n * 灵感来源于jdk11 Optional中的新函数or，用于值不存在时，用别的Opt代替\n\n// 给一个替代的Opt\nString str = Opt.<String>ofNullable(null).or(() -> Opt.ofNullable("Hello hutool!")).map(String::toUpperCase).orElseThrow();\nAssert.equals("HELLO HUTOOL!", str);\n\nUser user = User.builder().username("hutool").build();\nOpt<User> userOpt = Opt.of(user);\n// 获取昵称，获取不到则获取用户名\nString name = userOpt.map(User::getNickname).or(() -> userOpt.map(User::getUsername)).get();\nAssert.equals("hutool", name);\n\n\n * 对orElseThrow进行了重载，支持 双冒号+自定义提示语 写法，比原来的更加优雅。\n\n原来的写法：\n\norElseThrow(() -> new IllegalStateException("Ops!Something is wrong!"))\n\n\n修改后写法：\n\norElseThrow(IllegalStateException::new, "Ops!Something is wrong!")\n\n\n\n# 学习：\n\n经常有朋友问我，你这个Opt，参数怎么都是一些lambda，我怎么知道对应的lambda怎么写呢？\n\n这函数式编程，真是一件美事啊~\n\n对于这种情况，我们依靠我们强大的idea即可\n\n例如此处我写到这里不会写了\n\nUser user = new User();\nOpt.ofNullable(user).map(|光标停在此处)\n// idea会提示方法参数，如果没显示，光标放到括号里按ctrl+p主动呼出            \n        |Function<? super User,?> mapper|\n\n\n这里idea为我们提示了参数类型，可这个Function我也不知道它是个什么\n\n实际上，我们new一个就好了\n\nOpt.ofNullable(user).map(new Fun)\n                            |Function<User, Object>{...} (java.util.function)   |  <-戳我\n                            |Func<P,R> cn.hutool.core.lang.func                 |\n\n\n这里idea提示了剩下的代码，我们选Function就行了，接下来如下：\n\nOpt.ofNullable(user).map(new Function<User, Object>() {\n})\n\n\n此处开始编译报错了，不要着急，我们这里根据具体操作选取返回值\n\n例如我这里是想判断user是否为空，不为空时调用getSchool，从而获取其中的返回值String类型的school\n\n我们就如下写法，将第二个泛型，也就是象征返回值的泛型改为String：\n\nOpt.ofNullable(user).map(new Function<User, String>() {\n})\n\n\n然后我们使用idea的修复所有，默认快捷键alt+回车\n\nOpt.ofNullable(user).map(new Function<User, String>() {\n})                                                | 💡 Implement methods                  |  <-选我\n                                                  | ✍  Introduce local variable          |\n                                                  | ↩  Rollback changes in current line   |\n\n\n选择第一个Implement methods即可，这时候弹出一个框，提示让你选择你想要实现的方法\n\n这里就选择我们的apply方法吧，按下一个回车就可以了，或者点击选中apply，再按一下OK按钮\n\n    ||IJ| Select Methods to Implement                        X |\n    |                                                          |\n    | 👇  ©  |  ↹  ↸                                          |\n    | -------------------------------------------------------- |\n    | | java.util.function.Function                            |\n    | | ⒨ 🔓 apply(t:T):R                                     |      <-选我选我\n    | | ⒨ 🔓 compose(before:Function<? super V,? extents T):Fu|\n    | | ⒨ 🔓 andThen(after:Function<? super R,? extends V>):Fu|\n    | |                                                        |\n    | | ========================================               |                                        \n    | -------------------------------------------------------- |\n    |  ☐ Copy JavaDoc                                          |\n    |  ☑ Insert @Override               |  OK  |  | CANCEL |   |     <-选完点我点我\n\n\n此时此刻，代码变成了这样子\n\nOpt.ofNullable(user).map(new Function<User, String>() {\n    @Override\n    public String apply(User user) {\n        return null;\n    }\n})\n\n\n这里重写的方法里面就写你自己的逻辑(别忘了补全最后小括号后面的分号)\n\nOpt.ofNullable(user).map(new Function<User, String>() {\n    @Override\n    public String apply(User user) {\n        return user.getSchool();\n    }\n});\n\n\n我们可以看到，上边的new Function<User, String>()变成了灰色\n\n我们让光标移动到灰色字符上面，按一下alt+enter(回车)\n\nOpt.ofNullable(user).map(new Function<User, String>() {\n    @Override                              | 💡 Replace with lambda             > |  <-选我啦\n    public String apply(User user) {       | 💡 Replace with method reference   > |\n        return user.getSchool();           | 💎 balabala...                     > |\n    }\n});\n\n\n选择第一个Replace with lambda，就会自动缩写为lambda啦\n\nOpt.ofNullable(user).map(user1 -> user1.getSchool());\n\n\n如果选择第二个，则会缩写为我们双冒号格式\n\nOpt.ofNullable(user).map(User::getSchool);\n\n\n看，是不是很简单！',normalizedContent:'# 介绍\n\n在嵌套对象的属性获取中，由于子对象无法得知是否为null，每次获取属性都要检查属性对象是否为null，使得代码会变得特备臃肿，因此使用opt来优雅的链式获取属性对象值。\n\n> 声明：此类的作者：阿超 ，pr来自：https://gitee.com/dromara/hutool/pulls/426\n\n\n# 使用\n\n我们先定义一个嵌套的bean：\n\n// lombok注解\n@data\npublic static class user {\n\tprivate string name;\n\tprivate string gender;\n\tprivate school school;\n\t\n\t@data\n\tpublic static class school {\n\t\tprivate string name;\n\t\tprivate string address;\n\t}\n}\n\n\n假设我们想获取address属性，则：\n\nuser user = new user();\nuser.setname("hello");\n\n// null\nstring addressvalue = opt.ofnullable(user)\n\t\t.map(user::getschool)\n\t\t.map(user.school::getaddress).get();\n\n\n由于school对象的值为null，一般直接获取会报空指针，使用opt即可避免判断。\n\n * ofblankable函数基于ofnullable的逻辑下，额外进行了空字符串判断\n\n// ofblankable相对于ofnullable考虑了字符串为空串的情况\nstring hutool = opt.ofblankable("").orelse("hutool");\nassert.equals("hutool", hutool);\n\n\n * 和原版optional有区别的是，opt.get()不会抛出nosuchelementexception\n * 如果想像原版optional中的get那样，获取一个一定不为空的值，则应该使用orelsethrow\n\nobject opt = opt.ofnullable(null).get();\nassert.isnull(isempty);\n\n\n * 这是参考了jdk11 optional中的新函数isempty，用于判断不存在值的情况\n\n// 判断包裹内元素是否为空，注意并没有判断空字符串的情况\nboolean isempty = opt.empty().isempty();\nassert.istrue(isempty);\n\n\n * 灵感来源于jdk9 optional中的新函数ifpresentorelse，用于 存在值时执行某些操作，不存在值时执行另一个操作，支持链式编程\n\n// 存在就打印对应的值，不存在则用system.err.println打印另一句字符串\nopt.ofnullable("hello hutool!").ifpresentorelse(system.out::println, () -> system.err.println("ops!something is wrong!"));\nopt.empty().ifpresentorelse(system.out::println, () -> system.err.println("ops!something is wrong!"));\n\n\n * 新增了peek函数，相当于ifpresent的链式调用（个人常用）\n\nuser user = new user();\n// 相当于ifpresent的链式调用\nopt.ofnullable("hutool").peek(user::setusername).peek(user::setnickname);\nassert.equals("hutool", user.getnickname());\nassert.equals("hutool", user.getusername());\n\n// 注意，传入的lambda中，对包裹内的元素执行赋值操作并不会影响到原来的元素\nstring name = opt.ofnullable("hutool").peek(username -> username = "123").peek(username -> username = "456").get();\nassert.equals("hutool", name);\n\n\n * 灵感来源于jdk11 optional中的新函数or，用于值不存在时，用别的opt代替\n\n// 给一个替代的opt\nstring str = opt.<string>ofnullable(null).or(() -> opt.ofnullable("hello hutool!")).map(string::touppercase).orelsethrow();\nassert.equals("hello hutool!", str);\n\nuser user = user.builder().username("hutool").build();\nopt<user> useropt = opt.of(user);\n// 获取昵称，获取不到则获取用户名\nstring name = useropt.map(user::getnickname).or(() -> useropt.map(user::getusername)).get();\nassert.equals("hutool", name);\n\n\n * 对orelsethrow进行了重载，支持 双冒号+自定义提示语 写法，比原来的更加优雅。\n\n原来的写法：\n\norelsethrow(() -> new illegalstateexception("ops!something is wrong!"))\n\n\n修改后写法：\n\norelsethrow(illegalstateexception::new, "ops!something is wrong!")\n\n\n\n# 学习：\n\n经常有朋友问我，你这个opt，参数怎么都是一些lambda，我怎么知道对应的lambda怎么写呢？\n\n这函数式编程，真是一件美事啊~\n\n对于这种情况，我们依靠我们强大的idea即可\n\n例如此处我写到这里不会写了\n\nuser user = new user();\nopt.ofnullable(user).map(|光标停在此处)\n// idea会提示方法参数，如果没显示，光标放到括号里按ctrl+p主动呼出            \n        |function<? super user,?> mapper|\n\n\n这里idea为我们提示了参数类型，可这个function我也不知道它是个什么\n\n实际上，我们new一个就好了\n\nopt.ofnullable(user).map(new fun)\n                            |function<user, object>{...} (java.util.function)   |  <-戳我\n                            |func<p,r> cn.hutool.core.lang.func                 |\n\n\n这里idea提示了剩下的代码，我们选function就行了，接下来如下：\n\nopt.ofnullable(user).map(new function<user, object>() {\n})\n\n\n此处开始编译报错了，不要着急，我们这里根据具体操作选取返回值\n\n例如我这里是想判断user是否为空，不为空时调用getschool，从而获取其中的返回值string类型的school\n\n我们就如下写法，将第二个泛型，也就是象征返回值的泛型改为string：\n\nopt.ofnullable(user).map(new function<user, string>() {\n})\n\n\n然后我们使用idea的修复所有，默认快捷键alt+回车\n\nopt.ofnullable(user).map(new function<user, string>() {\n})                                                | 💡 implement methods                  |  <-选我\n                                                  | ✍  introduce local variable          |\n                                                  | ↩  rollback changes in current line   |\n\n\n选择第一个implement methods即可，这时候弹出一个框，提示让你选择你想要实现的方法\n\n这里就选择我们的apply方法吧，按下一个回车就可以了，或者点击选中apply，再按一下ok按钮\n\n    ||ij| select methods to implement                        x |\n    |                                                          |\n    | 👇  ©  |  ↹  ↸                                          |\n    | -------------------------------------------------------- |\n    | | java.util.function.function                            |\n    | | ⒨ 🔓 apply(t:t):r                                     |      <-选我选我\n    | | ⒨ 🔓 compose(before:function<? super v,? extents t):fu|\n    | | ⒨ 🔓 andthen(after:function<? super r,? extends v>):fu|\n    | |                                                        |\n    | | ========================================               |                                        \n    | -------------------------------------------------------- |\n    |  ☐ copy javadoc                                          |\n    |  ☑ insert @override               |  ok  |  | cancel |   |     <-选完点我点我\n\n\n此时此刻，代码变成了这样子\n\nopt.ofnullable(user).map(new function<user, string>() {\n    @override\n    public string apply(user user) {\n        return null;\n    }\n})\n\n\n这里重写的方法里面就写你自己的逻辑(别忘了补全最后小括号后面的分号)\n\nopt.ofnullable(user).map(new function<user, string>() {\n    @override\n    public string apply(user user) {\n        return user.getschool();\n    }\n});\n\n\n我们可以看到，上边的new function<user, string>()变成了灰色\n\n我们让光标移动到灰色字符上面，按一下alt+enter(回车)\n\nopt.ofnullable(user).map(new function<user, string>() {\n    @override                              | 💡 replace with lambda             > |  <-选我啦\n    public string apply(user user) {       | 💡 replace with method reference   > |\n        return user.getschool();           | 💎 balabala...                     > |\n    }\n});\n\n\n选择第一个replace with lambda，就会自动缩写为lambda啦\n\nopt.ofnullable(user).map(user1 -> user1.getschool());\n\n\n如果选择第二个，则会缩写为我们双冒号格式\n\nopt.ofnullable(user).map(user::getschool);\n\n\n看，是不是很简单！',charsets:{cjk:!0},lastUpdated:"2023/10/21, 16:55:17",lastUpdatedTimestamp:1697878517e3},{title:"行遍历器-LineIter",frontmatter:{title:"行遍历器-LineIter",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/LineIter/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/08.%E9%9B%86%E5%90%88%E7%B1%BB/08.%E8%A1%8C%E9%81%8D%E5%8E%86%E5%99%A8-LineIter.html",relativePath:"01.指南/02.核心（Hutool-core）/08.集合类/08.行遍历器-LineIter.md",key:"v-1d7176e4",path:"/pages/LineIter/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:74}],headersStr:"介绍 使用",content:'# 介绍\n\n此工具分别参考和Apache Commons io和Guava项目。\n\n将Reader包装为一个按照行读取的Iterator。\n\n\n# 使用\n\nfinal LineIter lineIter = new LineIter(ResourceUtil.getUtf8Reader("https://doc.hutool.cn/assets/js/test_lines.csv"));\n\nfor (String line : lineIter) {\n\tConsole.log(line);\n}\n',normalizedContent:'# 介绍\n\n此工具分别参考和apache commons io和guava项目。\n\n将reader包装为一个按照行读取的iterator。\n\n\n# 使用\n\nfinal lineiter lineiter = new lineiter(resourceutil.getutf8reader("https://doc.hutool.cn/assets/js/test_lines.csv"));\n\nfor (string line : lineiter) {\n\tconsole.log(line);\n}\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/map/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/09.Map/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/02.核心（Hutool-core）/09.Map/01.概述.md",key:"v-db2b878c",path:"/pages/map/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:92},{level:3,title:"特殊Map",slug:"特殊map",normalizedTitle:"特殊map",charIndex:99},{level:3,title:"工具",slug:"工具",normalizedTitle:"工具",charIndex:14}],headersStr:"由来 使用 特殊Map 工具",content:'# 由来\n\n最早Map的相关工具是被包含在CollUtil中的，但是考虑到Map和集合非同一类数据结构，因此独立出来，且Hutool封装了许多自定义的Map类，因此单独成包。\n\n\n# 使用\n\n\n# 特殊Map\n\n * CaseInsensitiveMap 忽略大小写的Map,对KEY忽略大小写，get("Value")和get("value")获得的值相同，put进入的值也会被覆盖\n\n * CaseInsensitiveLinkedMap 忽略大小写的LinkedHashMap,对KEY忽略大小写，get("Value")和get("value")获得的值相同，put进入的值也会被覆盖\n\n * MapBuilder Map创建器，可以链式创建Map\n\n * MapProxy Map代理类，通过代理包装Map，提供一系列的getXXX方法\n\n\n# 工具\n\n * MapUtil 提供对Map常用操作的封装',normalizedContent:'# 由来\n\n最早map的相关工具是被包含在collutil中的，但是考虑到map和集合非同一类数据结构，因此独立出来，且hutool封装了许多自定义的map类，因此单独成包。\n\n\n# 使用\n\n\n# 特殊map\n\n * caseinsensitivemap 忽略大小写的map,对key忽略大小写，get("value")和get("value")获得的值相同，put进入的值也会被覆盖\n\n * caseinsensitivelinkedmap 忽略大小写的linkedhashmap,对key忽略大小写，get("value")和get("value")获得的值相同，put进入的值也会被覆盖\n\n * mapbuilder map创建器，可以链式创建map\n\n * mapproxy map代理类，通过代理包装map，提供一系列的getxxx方法\n\n\n# 工具\n\n * maputil 提供对map常用操作的封装',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"可重复键值Map-TableMap",frontmatter:{title:"可重复键值Map-TableMap",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/TableMap/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/09.Map/04.%E5%8F%AF%E9%87%8D%E5%A4%8D%E9%94%AE%E5%80%BCMap-TableMap.html",relativePath:"01.指南/02.核心（Hutool-core）/09.Map/04.可重复键值Map-TableMap.md",key:"v-e23094cc",path:"/pages/TableMap/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:215}],headersStr:"介绍 使用",content:'# 介绍\n\n有时候我们需要键值对一一对应，但是又有可能有重复的键，也可能有重复的值，就像一个2列的表格一样：\n\n键      值\nkey1   value1\nkey2   value2\n\n因此，Hutool创建了TableMap这类数据结构，通过键值单独建立List方式，使键值对一一对应，实现正向和反向两种查找。\n\n当然，这种Map无论是正向还是反向，都是遍历列表查找过程，相比标准的HashMap要慢，数据越多越慢。\n\n\n# 使用\n\nTableMap<String, Integer> tableMap = new TableMap<>(new HashMap<>());\ntableMap.put("aaa", 111);\ntableMap.put("bbb", 222);\n\n// 111\ntableMap.get("aaa");\n// 222\ntableMap.get("bbb");\n\n// aaa\ntableMap.getKey(111);\n// bbb\ntableMap.getKey(222);\n\n// [111]\ntableMap.getValues("aaa");\n\n//[aaa]\ntableMap.getKeys(111);\n',normalizedContent:'# 介绍\n\n有时候我们需要键值对一一对应，但是又有可能有重复的键，也可能有重复的值，就像一个2列的表格一样：\n\n键      值\nkey1   value1\nkey2   value2\n\n因此，hutool创建了tablemap这类数据结构，通过键值单独建立list方式，使键值对一一对应，实现正向和反向两种查找。\n\n当然，这种map无论是正向还是反向，都是遍历列表查找过程，相比标准的hashmap要慢，数据越多越慢。\n\n\n# 使用\n\ntablemap<string, integer> tablemap = new tablemap<>(new hashmap<>());\ntablemap.put("aaa", 111);\ntablemap.put("bbb", 222);\n\n// 111\ntablemap.get("aaa");\n// 222\ntablemap.get("bbb");\n\n// aaa\ntablemap.getkey(111);\n// bbb\ntablemap.getkey(222);\n\n// [111]\ntablemap.getvalues("aaa");\n\n//[aaa]\ntablemap.getkeys(111);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"双向查找Map-BiMap",frontmatter:{title:"双向查找Map-BiMap",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/BiMap/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/09.Map/03.%E5%8F%8C%E5%90%91%E6%9F%A5%E6%89%BEMap-BiMap.html",relativePath:"01.指南/02.核心（Hutool-core）/09.Map/03.双向查找Map-BiMap.md",key:"v-184ae15c",path:"/pages/BiMap/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:266}],headersStr:"介绍 使用",content:'# 介绍\n\n我们知道在Guava中提供了一种特殊的Map结构，叫做BiMap，它实现了一种双向查找的功能，即根据key查找value和根据value查找key，Hutool也同样提供此对象。\n\nBiMap要求key和value都不能重复（非强制要求），如果key重复了，后加入的键值对会覆盖之前的键值对，如果value重复了，则会按照不确定的顺序覆盖key，这完全取决于map实现。比如HashMap无序（按照hash顺序），则谁覆盖谁和hash算法有关；如果是LinkedHashMap，则有序，是后加入的覆盖先加入的。\n\n\n# 使用\n\nBiMap<String, Integer> biMap = new BiMap<>(new HashMap<>());\nbiMap.put("aaa", 111);\nbiMap.put("bbb", 222);\n\n// 111\nbiMap.get("aaa");\n// 222\nbiMap.get("bbb");\n\n// aaa\nbiMap.getKey(111);\n// bbb\nbiMap.getKey(222);\n',normalizedContent:'# 介绍\n\n我们知道在guava中提供了一种特殊的map结构，叫做bimap，它实现了一种双向查找的功能，即根据key查找value和根据value查找key，hutool也同样提供此对象。\n\nbimap要求key和value都不能重复（非强制要求），如果key重复了，后加入的键值对会覆盖之前的键值对，如果value重复了，则会按照不确定的顺序覆盖key，这完全取决于map实现。比如hashmap无序（按照hash顺序），则谁覆盖谁和hash算法有关；如果是linkedhashmap，则有序，是后加入的覆盖先加入的。\n\n\n# 使用\n\nbimap<string, integer> bimap = new bimap<>(new hashmap<>());\nbimap.put("aaa", 111);\nbimap.put("bbb", 222);\n\n// 111\nbimap.get("aaa");\n// 222\nbimap.get("bbb");\n\n// aaa\nbimap.getkey(111);\n// bbb\nbimap.getkey(222);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Map工具-MapUtil",frontmatter:{title:"Map工具-MapUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/MapUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/09.Map/02.Map%E5%B7%A5%E5%85%B7-MapUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/09.Map/02.Map工具-MapUtil.md",key:"v-0a783e44",path:"/pages/MapUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:25}],headersStr:"介绍 方法",content:'# 介绍\n\nMapUtil是针对Map的一系列工具方法的封装，包括getXXX的快捷值转换方法。\n\n\n# 方法\n\n * isEmpty、isNotEmpty 判断Map为空和非空的方法，空的定义为null或没有值\n * newHashMap 快速创建多种类型的HashMap实例\n * createMap 创建自定义的Map类型的Map\n * of 此方法将一个或多个键值对加入到一个新建的Map中，下面是栗子:\n\nMap<Object, Object> colorMap = MapUtil.of(new String[][] {\n     {"RED", "#FF0000"},\n     {"GREEN", "#00FF00"},\n     {"BLUE", "#0000FF"}\n});\n\n\n * toListMap 行转列，合并相同的键，值合并为列表，将Map列表中相同key的值组成列表做为Map的value，例如传入数据是：\n\n[\n  {a: 1, b: 1, c: 1},\n  {a: 2, b: 2},\n  {a: 3, b: 3},\n  {a: 4}\n]\n\n\n结果为：\n\n{\n   a: [1,2,3,4],\n   b: [1,2,3,],\n   c: [1]\n}\n\n\n * toMapList 列转行。将Map中值列表分别按照其位置与key组成新的map，例如传入数据：\n\n{\n   a: [1,2,3,4],\n   b: [1,2,3,],\n   c: [1]\n}\n\n\n结果为：\n\n[\n  {a: 1, b: 1, c: 1},\n  {a: 2, b: 2},\n  {a: 3, b: 3},\n  {a: 4}\n]\n\n\n * join、joinIgnoreNull、sortJoin将Map按照给定的分隔符转换为字符串，此方法一般用于签名。\n\nMap<String, String> build = MapUtil.builder(new HashMap<String, String>())\n\t.put("key1", "value1")\n\t.put("key3", "value3")\n\t.put("key2", "value2").build();\n\n// key1value1key2value2key3value3\nString join1 = MapUtil.sortJoin(build, StrUtil.EMPTY, StrUtil.EMPTY, false);\n// key1value1key2value2key3value3123\nString join2 = MapUtil.sortJoin(build, StrUtil.EMPTY, StrUtil.EMPTY, false, "123");\n\n\n * filter 通过传入的Filter实现来筛选需要的元素内容，返回true则保留这个元素，false则过滤元素。\n\nMap<String, String> map = MapUtil.newHashMap();\nmap.put("a", "1");\nmap.put("b", "2");\nmap.put("c", "3");\nmap.put("d", "4");\n\nMap<String, String> map2 = MapUtil.filter(map,(Filter<Entry<String, String>>) t -> Convert.toInt(t.getValue()) % 2 == 0);\n\n\n结果为\n\n{\n   b: "2",\n   d: "4"\n}\n\n\n * map 通过传入的BiFunction实现来修改value，返回一个新的map\n\n定义个小枚举\n\nenum PeopleEnum {GIRL, BOY, CHILD}\n\n\n开始操作\n\nMap<Integer, String> adjectivesMap = MapUtil.<Integer, String>builder()\n.put(0, "lovely")\n.put(1, "friendly")\n.put(2, "happily")\n.build();\n\nMap<Integer, String> resultMap = MapUtil.map(adjectivesMap, (k, v) -> v + " " + PeopleEnum.values()[k].name().toLowerCase());\n\n\n结果为\n\n{\n  0: "lovely girl",\n  1: "friendly boy",\n  2: "happily child"\n}\n\n\n * reverse Map的键和值互换\n\nMap<String, String> map = MapUtil.newHashMap();\n\t\tmap.put("a", "1");\n\t\tmap.put("b", "2");\n\t\tmap.put("c", "3");\n\t\tmap.put("d", "4");\n\nMap<String, String> map2 = MapUtil.reverse(map);\n\n\n结果为：\n\n{\n   "1": "a",\n   "2": "b",\n   "3": "c",\n   "4": "d",\n}\n\n\n * sort 排序Map\n * getAny 获取Map的部分key生成新的Map\n * get、getXXX 获取Map中指定类型的值',normalizedContent:'# 介绍\n\nmaputil是针对map的一系列工具方法的封装，包括getxxx的快捷值转换方法。\n\n\n# 方法\n\n * isempty、isnotempty 判断map为空和非空的方法，空的定义为null或没有值\n * newhashmap 快速创建多种类型的hashmap实例\n * createmap 创建自定义的map类型的map\n * of 此方法将一个或多个键值对加入到一个新建的map中，下面是栗子:\n\nmap<object, object> colormap = maputil.of(new string[][] {\n     {"red", "#ff0000"},\n     {"green", "#00ff00"},\n     {"blue", "#0000ff"}\n});\n\n\n * tolistmap 行转列，合并相同的键，值合并为列表，将map列表中相同key的值组成列表做为map的value，例如传入数据是：\n\n[\n  {a: 1, b: 1, c: 1},\n  {a: 2, b: 2},\n  {a: 3, b: 3},\n  {a: 4}\n]\n\n\n结果为：\n\n{\n   a: [1,2,3,4],\n   b: [1,2,3,],\n   c: [1]\n}\n\n\n * tomaplist 列转行。将map中值列表分别按照其位置与key组成新的map，例如传入数据：\n\n{\n   a: [1,2,3,4],\n   b: [1,2,3,],\n   c: [1]\n}\n\n\n结果为：\n\n[\n  {a: 1, b: 1, c: 1},\n  {a: 2, b: 2},\n  {a: 3, b: 3},\n  {a: 4}\n]\n\n\n * join、joinignorenull、sortjoin将map按照给定的分隔符转换为字符串，此方法一般用于签名。\n\nmap<string, string> build = maputil.builder(new hashmap<string, string>())\n\t.put("key1", "value1")\n\t.put("key3", "value3")\n\t.put("key2", "value2").build();\n\n// key1value1key2value2key3value3\nstring join1 = maputil.sortjoin(build, strutil.empty, strutil.empty, false);\n// key1value1key2value2key3value3123\nstring join2 = maputil.sortjoin(build, strutil.empty, strutil.empty, false, "123");\n\n\n * filter 通过传入的filter实现来筛选需要的元素内容，返回true则保留这个元素，false则过滤元素。\n\nmap<string, string> map = maputil.newhashmap();\nmap.put("a", "1");\nmap.put("b", "2");\nmap.put("c", "3");\nmap.put("d", "4");\n\nmap<string, string> map2 = maputil.filter(map,(filter<entry<string, string>>) t -> convert.toint(t.getvalue()) % 2 == 0);\n\n\n结果为\n\n{\n   b: "2",\n   d: "4"\n}\n\n\n * map 通过传入的bifunction实现来修改value，返回一个新的map\n\n定义个小枚举\n\nenum peopleenum {girl, boy, child}\n\n\n开始操作\n\nmap<integer, string> adjectivesmap = maputil.<integer, string>builder()\n.put(0, "lovely")\n.put(1, "friendly")\n.put(2, "happily")\n.build();\n\nmap<integer, string> resultmap = maputil.map(adjectivesmap, (k, v) -> v + " " + peopleenum.values()[k].name().tolowercase());\n\n\n结果为\n\n{\n  0: "lovely girl",\n  1: "friendly boy",\n  2: "happily child"\n}\n\n\n * reverse map的键和值互换\n\nmap<string, string> map = maputil.newhashmap();\n\t\tmap.put("a", "1");\n\t\tmap.put("b", "2");\n\t\tmap.put("c", "3");\n\t\tmap.put("d", "4");\n\nmap<string, string> map2 = maputil.reverse(map);\n\n\n结果为：\n\n{\n   "1": "a",\n   "2": "b",\n   "3": "c",\n   "4": "d",\n}\n\n\n * sort 排序map\n * getany 获取map的部分key生成新的map\n * get、getxxx 获取map中指定类型的值',charsets:{cjk:!0},lastUpdated:"2023/10/23, 14:33:13",lastUpdatedTimestamp:1698042793e3},{title:"Map流式构建器-MapBuilder",frontmatter:{title:"Map流式构建器-MapBuilder",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/MapBuilder/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/09.Map/05.Map%E6%B5%81%E5%BC%8F%E6%9E%84%E5%BB%BA%E5%99%A8-MapBuilder%20copy.html",relativePath:"01.指南/02.核心（Hutool-core）/09.Map/05.Map流式构建器-MapBuilder copy.md",key:"v-d73b26c8",path:"/pages/MapBuilder/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:37}],headersStr:"介绍 使用",content:'# 介绍\n\nMapBuilder提供了一种流式的Map创建方法。\n\n\n# 使用\n\nMap<String, Object> srcMap = MapBuilder\n\t.create(new HashMap<String, Object>())\n\t.put("name", "AAA")\n\t.put("age", 45).map();\n',normalizedContent:'# 介绍\n\nmapbuilder提供了一种流式的map创建方法。\n\n\n# 使用\n\nmap<string, object> srcmap = mapbuilder\n\t.create(new hashmap<string, object>())\n\t.put("name", "aaa")\n\t.put("age", 45).map();\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Base64编码解码-Base64",frontmatter:{title:"Base64编码解码-Base64",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Base64/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/10.Codec%E7%BC%96%E7%A0%81/02.Base64%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-Base64.html",relativePath:"01.指南/02.核心（Hutool-core）/10.Codec编码/02.Base64编码解码-Base64.md",key:"v-24b05c4c",path:"/pages/Base64/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:24},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:123}],headersStr:"介绍 使用",content:'# Base64编码解码-Base64\n\n\n# 介绍\n\nBase64编码是用64（2的6次方）个ASCII字符来表示256（2的8次方）个ASCII字符，也就是三位二进制数组经过编码后变为四位的ASCII字符显示，长度比原来增加1/3。\n\n\n# 使用\n\nString a = "伦家是一个非常长的字符串";\n//5Lym5a625piv5LiA5Liq6Z2e5bi46ZW/55qE5a2X56ym5Liy\nString encode = Base64.encode(a);\n\n// 还原为a\nString decodeStr = Base64.decodeStr(encode);\n',normalizedContent:'# base64编码解码-base64\n\n\n# 介绍\n\nbase64编码是用64（2的6次方）个ascii字符来表示256（2的8次方）个ascii字符，也就是三位二进制数组经过编码后变为四位的ascii字符显示，长度比原来增加1/3。\n\n\n# 使用\n\nstring a = "伦家是一个非常长的字符串";\n//5lym5a625piv5lia5liq6z2e5bi46zw/55qe5a2x56ym5liy\nstring encode = base64.encode(a);\n\n// 还原为a\nstring decodestr = base64.decodestr(encode);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Base32编码解码-Base32",frontmatter:{title:"Base32编码解码-Base32",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Base32/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/10.Codec%E7%BC%96%E7%A0%81/03.Base32%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-Base32.html",relativePath:"01.指南/02.核心（Hutool-core）/10.Codec编码/03.Base32编码解码-Base32.md",key:"v-cbdc4a6c",path:"/pages/Base32/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:24},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:132}],headersStr:"介绍 使用",content:'# Base32编码解码-Base32\n\n\n# 介绍\n\nBase32就是用32（2的5次方）个特定ASCII码来表示256个ASCII码。所以，5个ASCII字符经过base32编码后会变为8个字符（公约数为40），长度增加3/5.不足8n用“=”补足。\n\n\n# 使用\n\nString a = "伦家是一个非常长的字符串";\n\nString encode = Base32.encode(a);\nAssert.assertEquals("4S6KNZNOW3TJRL7EXCAOJOFK5GOZ5ZNYXDUZLP7HTKCOLLMX46WKNZFYWI", encode);\n\t\t\nString decodeStr = Base32.decodeStr(encode);\nAssert.assertEquals(a, decodeStr);\n',normalizedContent:'# base32编码解码-base32\n\n\n# 介绍\n\nbase32就是用32（2的5次方）个特定ascii码来表示256个ascii码。所以，5个ascii字符经过base32编码后会变为8个字符（公约数为40），长度增加3/5.不足8n用“=”补足。\n\n\n# 使用\n\nstring a = "伦家是一个非常长的字符串";\n\nstring encode = base32.encode(a);\nassert.assertequals("4s6knznow3tjrl7excaojofk5goz5znyxduzlp7htkcollmx46wknzfywi", encode);\n\t\t\nstring decodestr = base32.decodestr(encode);\nassert.assertequals(a, decodestr);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"莫尔斯电码-Morse",frontmatter:{title:"莫尔斯电码-Morse",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Morse/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/10.Codec%E7%BC%96%E7%A0%81/04.%E8%8E%AB%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81-Morse.html",relativePath:"01.指南/02.核心（Hutool-core）/10.Codec编码/04.莫尔斯电码-Morse.md",key:"v-7e4025a8",path:"/pages/Morse/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:100},{level:3,title:"编码",slug:"编码",normalizedTitle:"编码",charIndex:107},{level:3,title:"解码",slug:"解码",normalizedTitle:"解码",charIndex:271}],headersStr:"介绍 实现 编码 解码",content:'# 介绍\n\n摩尔斯电码也被称作摩斯密码，是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。\n\n摩尔斯电码是由点dot（.）划dash（-）这两种符号所组成的。\n\n\n# 实现\n\n\n# 编码\n\nfinal Morse morseCoder = new Morse();\n\nString text = "Hello World!";\n\n// ...././.-../.-../---/-...../.--/---/.-./.-../-../-.-.--/\nmorseCoder.encode(text);\n\n\n\n# 解码\n\nString text = "你好，世界！";\n\n// -..----.--...../-.--..-.-----.-/--------....--../-..---....-.--./---.-.-.-..--../--------.......-/\nString morse = morseCoder.encode(text);\n\nmorseCoder.decode(morse);\n',normalizedContent:'# 介绍\n\n摩尔斯电码也被称作摩斯密码，是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。\n\n摩尔斯电码是由点dot（.）划dash（-）这两种符号所组成的。\n\n\n# 实现\n\n\n# 编码\n\nfinal morse morsecoder = new morse();\n\nstring text = "hello world!";\n\n// ...././.-../.-../---/-...../.--/---/.-./.-../-../-.-.--/\nmorsecoder.encode(text);\n\n\n\n# 解码\n\nstring text = "你好，世界！";\n\n// -..----.--...../-.--..-.-----.-/--------....--../-..---....-.--./---.-.-.-..--../--------.......-/\nstring morse = morsecoder.encode(text);\n\nmorsecoder.decode(morse);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Base62编码解码-Base62",frontmatter:{title:"Base62编码解码-Base62",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Base62/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/10.Codec%E7%BC%96%E7%A0%81/01.Base62%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-Base62.html",relativePath:"01.指南/02.核心（Hutool-core）/10.Codec编码/01.Base62编码解码-Base62.md",key:"v-5d0726e4",path:"/pages/Base62/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:24},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:86}],headersStr:"介绍 使用",content:'# Base62编码解码-Base62\n\n\n# 介绍\n\nBase62编码是由10个数字、26个大写英文字母和26个小写英文字母组成，多用于安全领域和短URL生成。\n\n\n# 使用\n\nString a = "伦家是一个非常长的字符串66";\n\n// 17vKU8W4JMG8dQF8lk9VNnkdMOeWn4rJMva6F0XsLrrT53iKBnqo\nString encode = Base62.encode(a);\n\n// 还原为a\nString decodeStr = Base62.decodeStr(encode);\n',normalizedContent:'# base62编码解码-base62\n\n\n# 介绍\n\nbase62编码是由10个数字、26个大写英文字母和26个小写英文字母组成，多用于安全领域和短url生成。\n\n\n# 使用\n\nstring a = "伦家是一个非常长的字符串66";\n\n// 17vku8w4jmg8dqf8lk9vnnkdmoewn4rjmva6f0xslrrt53ikbnqo\nstring encode = base62.encode(a);\n\n// 还原为a\nstring decodestr = base62.decodestr(encode);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"BCD码-BCD",frontmatter:{title:"BCD码-BCD",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/codec/BCD/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/10.Codec%E7%BC%96%E7%A0%81/05.BCD%E7%A0%81-BCD.html",relativePath:"01.指南/02.核心（Hutool-core）/10.Codec编码/05.BCD码-BCD.md",key:"v-3feacd60",path:"/pages/codec/BCD/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:106}],headersStr:"介绍 使用",content:'# 介绍\n\nBCD码（Binary-Coded Decimal）亦称二进码十进数或二-十进制代码。\n\nBCD码这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。\n\n\n# 使用\n\nString strForTest = "123456ABCDEF";\n\n// 转BCD\nbyte[] bcd = BCD.strToBcd(strForTest);\n\n// 解码BCD\nString str = BCD.bcdToStr(bcd);\n',normalizedContent:'# 介绍\n\nbcd码（binary-coded decimal）亦称二进码十进数或二-十进制代码。\n\nbcd码这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。\n\n\n# 使用\n\nstring strfortest = "123456abcdef";\n\n// 转bcd\nbyte[] bcd = bcd.strtobcd(strfortest);\n\n// 解码bcd\nstring str = bcd.bcdtostr(bcd);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"回转N位密码-Rot",frontmatter:{title:"回转N位密码-Rot",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Rot/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/10.Codec%E7%BC%96%E7%A0%81/06.%E5%9B%9E%E8%BD%ACN%E4%BD%8D%E5%AF%86%E7%A0%81-Rot.html",relativePath:"01.指南/02.核心（Hutool-core）/10.Codec编码/06.回转N位密码-Rot.md",key:"v-d4d865d6",path:"/pages/Rot/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:76}],headersStr:"介绍 使用",content:'# 介绍\n\nRotN（rotate by N places），回转N位密码，是一种简易的替换式密码，也是过去在古罗马开发的凯撒加密的一种变体。\n\n\n# 使用\n\n以Rot-13为例：\n\nString str = "1f2e9df6131b480b9fdddc633cf24996";\n\n// 4s5r2qs9464o713o2sqqqp966ps57229\nString encode13 = Rot.encode13(str);\n\n// 解码\nString decode13 = Rot.decode13(encode13);\n',normalizedContent:'# 介绍\n\nrotn（rotate by n places），回转n位密码，是一种简易的替换式密码，也是过去在古罗马开发的凯撒加密的一种变体。\n\n\n# 使用\n\n以rot-13为例：\n\nstring str = "1f2e9df6131b480b9fdddc633cf24996";\n\n// 4s5r2qs9464o713o2sqqqp966ps57229\nstring encode13 = rot.encode13(str);\n\n// 解码\nstring decode13 = rot.decode13(encode13);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"集合串行流工具-CollStreamUtil",frontmatter:{title:"集合串行流工具-CollStreamUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CollStreamUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/08.%E9%9B%86%E5%90%88%E7%B1%BB/07.%E9%9B%86%E5%90%88%E4%B8%B2%E8%A1%8C%E6%B5%81%E5%B7%A5%E5%85%B7-CollStreamUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/08.集合类/07.集合串行流工具-CollStreamUtil.md",key:"v-5a1660c6",path:"/pages/CollStreamUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:50},{level:3,title:"集合转Map",slug:"集合转map",normalizedTitle:"集合转map",charIndex:57},{level:3,title:"分组",slug:"分组",normalizedTitle:"分组",charIndex:722},{level:3,title:"转换提取",slug:"转换提取",normalizedTitle:"转换提取",charIndex:1064},{level:3,title:"合并",slug:"合并",normalizedTitle:"合并",charIndex:1170}],headersStr:"介绍 使用 集合转Map 分组 转换提取 合并",content:'# 介绍\n\nJava8中的新特性之一就是Stream，Hutool针对常用操作做了一些封装\n\n\n# 使用\n\n\n# 集合转Map\n\n@Data\n@AllArgsConstructor\n@ToString\npublic static class Student {\n\tprivate long termId;//学期id\n\tprivate long classId;//班级id\n\tprivate long studentId;//班级id\n\tprivate String name;//学生名称\n}\n\n\n我们可以建立一个学生id和学生对象之间的map：\n\nList<Student> list = new ArrayList<>();\nlist.add(new Student(1, 1, 1, "张三"));\nlist.add(new Student(1, 1, 2, "李四"));\nlist.add(new Student(1, 1, 3, "王五"));\n\nMap<Long, Student> map = CollStreamUtil.toIdentityMap(list, Student::getStudentId);\n\n// 张三\nmap.get(1L).getName();\n\n\n我们也可以自定义Map的key和value放的内容，如我们可以将学生信息的id和姓名生成map：\n\nMap<Long, String> map = map = CollStreamUtil.toMap(list, Student::getStudentId, Student::getName);\n\n// 张三\nmap.get(1L);\n\n\n\n# 分组\n\n我们将学生按照班级分组：\n\nList<Student> list = new ArrayList<>();\nlist.add(new Student(1, 1, 1, "张三"));\nlist.add(new Student(1, 2, 2, "李四"));\nlist.add(new Student(2, 1, 1, "擎天柱"));\nlist.add(new Student(2, 2, 2, "威震天"));\nlist.add(new Student(2, 3, 2, "霸天虎"));\n\nMap<Long, List<Student>> map = CollStreamUtil.groupByKey(list, Student::getClassId);\n\n\n\n# 转换提取\n\n我们可以将学生信息列表转换提取为姓名的列表：\n\nList<String> nameList = CollStreamUtil.toList(list, Student::getName);\n\n\n\n# 合并\n\n合并两个相同key类型的map，可自定义合并的lambda，将 value1和value2合并成最终的类型，需要自行处理value为空的情况。\n\nMap<Long, Student> map1 = new HashMap<>();\nmap1.put(1L, new Student(1, 1, 1, "张三"));\n\nMap<Long, Student> map2 = new HashMap<>();\nmap2.put(1L, new Student(2, 1, 1, "李四"));\n\n\n定义merge规则：\n\nprivate String merge(Student student1, Student student2) {\n\tif (student1 == null && student2 == null) {\n\t\treturn null;\n\t} else if (student1 == null) {\n\t\treturn student2.getName();\n\t} else if (student2 == null) {\n\t\treturn student1.getName();\n\t} else {\n\t\treturn student1.getName() + student2.getName();\n\t}\n\n\n\nMap<Long, String> map = CollStreamUtil.merge(map1, map2, this::merge);\n',normalizedContent:'# 介绍\n\njava8中的新特性之一就是stream，hutool针对常用操作做了一些封装\n\n\n# 使用\n\n\n# 集合转map\n\n@data\n@allargsconstructor\n@tostring\npublic static class student {\n\tprivate long termid;//学期id\n\tprivate long classid;//班级id\n\tprivate long studentid;//班级id\n\tprivate string name;//学生名称\n}\n\n\n我们可以建立一个学生id和学生对象之间的map：\n\nlist<student> list = new arraylist<>();\nlist.add(new student(1, 1, 1, "张三"));\nlist.add(new student(1, 1, 2, "李四"));\nlist.add(new student(1, 1, 3, "王五"));\n\nmap<long, student> map = collstreamutil.toidentitymap(list, student::getstudentid);\n\n// 张三\nmap.get(1l).getname();\n\n\n我们也可以自定义map的key和value放的内容，如我们可以将学生信息的id和姓名生成map：\n\nmap<long, string> map = map = collstreamutil.tomap(list, student::getstudentid, student::getname);\n\n// 张三\nmap.get(1l);\n\n\n\n# 分组\n\n我们将学生按照班级分组：\n\nlist<student> list = new arraylist<>();\nlist.add(new student(1, 1, 1, "张三"));\nlist.add(new student(1, 2, 2, "李四"));\nlist.add(new student(2, 1, 1, "擎天柱"));\nlist.add(new student(2, 2, 2, "威震天"));\nlist.add(new student(2, 3, 2, "霸天虎"));\n\nmap<long, list<student>> map = collstreamutil.groupbykey(list, student::getclassid);\n\n\n\n# 转换提取\n\n我们可以将学生信息列表转换提取为姓名的列表：\n\nlist<string> namelist = collstreamutil.tolist(list, student::getname);\n\n\n\n# 合并\n\n合并两个相同key类型的map，可自定义合并的lambda，将 value1和value2合并成最终的类型，需要自行处理value为空的情况。\n\nmap<long, student> map1 = new hashmap<>();\nmap1.put(1l, new student(1, 1, 1, "张三"));\n\nmap<long, student> map2 = new hashmap<>();\nmap2.put(1l, new student(2, 1, 1, "李四"));\n\n\n定义merge规则：\n\nprivate string merge(student student1, student student2) {\n\tif (student1 == null && student2 == null) {\n\t\treturn null;\n\t} else if (student1 == null) {\n\t\treturn student2.getname();\n\t} else if (student2 == null) {\n\t\treturn student1.getname();\n\t} else {\n\t\treturn student1.getname() + student2.getname();\n\t}\n\n\n\nmap<long, string> map = collstreamutil.merge(map1, map2, this::merge);\n',charsets:{cjk:!0},lastUpdated:"2023/10/23, 14:33:13",lastUpdatedTimestamp:1698042793e3},{title:"Punycode实现-PunyCode",frontmatter:{title:"Punycode实现-PunyCode",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/PunyCode/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/10.Codec%E7%BC%96%E7%A0%81/07.Punycode%E5%AE%9E%E7%8E%B0-PunyCode.html",relativePath:"01.指南/02.核心（Hutool-core）/10.Codec编码/07.Punycode实现-PunyCode.md",key:"v-7be59aea",path:"/pages/PunyCode/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:98}],headersStr:"介绍 使用",content:'# 介绍\n\nPunycode是一个根据RFC 3492标准而制定的编码系统，主要用于把域名从地方语言所采用的Unicode编码转换成为可用于DNS系统的编码。\n\n具体见：RFC 3492\n\n\n# 使用\n\nString text = "Hutool编码器";\n\n// Hutool-ux9js33tgln\nString strPunyCode = PunyCode.encode(text);\n\n// Hutool编码器\nString decode = PunyCode.decode("Hutool-ux9js33tgln");\n\n// Hutool编码器\ndecode = PunyCode.decode("xn--Hutool-ux9js33tgln");\n',normalizedContent:'# 介绍\n\npunycode是一个根据rfc 3492标准而制定的编码系统，主要用于把域名从地方语言所采用的unicode编码转换成为可用于dns系统的编码。\n\n具体见：rfc 3492\n\n\n# 使用\n\nstring text = "hutool编码器";\n\n// hutool-ux9js33tgln\nstring strpunycode = punycode.encode(text);\n\n// hutool编码器\nstring decode = punycode.decode("hutool-ux9js33tgln");\n\n// hutool编码器\ndecode = punycode.decode("xn--hutool-ux9js33tgln");\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"CSV文件处理工具-CsvUtil",frontmatter:{title:"CSV文件处理工具-CsvUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CsvUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/11.%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C/01.CSV%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-CsvUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/11.文本操作/01.CSV文件处理工具-CsvUtil.md",key:"v-cf40e806",path:"/pages/CsvUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:24},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:297},{level:3,title:"读取CSV文件",slug:"读取csv文件",normalizedTitle:"读取csv文件",charIndex:304},{level:4,title:"读取为CsvRow",slug:"读取为csvrow",normalizedTitle:"读取为csvrow",charIndex:315},{level:4,title:"读取为Bean列表",slug:"读取为bean列表",normalizedTitle:"读取为bean列表",charIndex:627},{level:3,title:"生成CSV文件",slug:"生成csv文件",normalizedTitle:"生成csv文件",charIndex:237},{level:3,title:"乱码问题",slug:"乱码问题",normalizedTitle:"乱码问题",charIndex:1555}],headersStr:"介绍 使用 读取CSV文件 读取为CsvRow 读取为Bean列表 生成CSV文件 乱码问题",content:'# CSV文件处理工具-CsvUtil\n\n\n# 介绍\n\n逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。\n\nHutool针对此格式，参考FastCSV项目做了对CSV文件读写的实现(Hutool实现完全独立，不依赖第三方)\n\nCsvUtil是CSV工具类，主要封装了两个方法：\n\n * getReader 用于对CSV文件读取\n * getWriter 用于生成CSV文件\n\n这两个方法分别获取CsvReader对象和CsvWriter，从而独立完成CSV文件的读写。\n\n\n# 使用\n\n\n# 读取CSV文件\n\n# 读取为CsvRow\n\nCsvReader reader = CsvUtil.getReader();\n//从文件中读取CSV数据\nCsvData data = reader.read(FileUtil.file("https://doc.hutool.cn/assets/js/test.csv"));\nList<CsvRow> rows = data.getRows();\n//遍历行\nfor (CsvRow csvRow : rows) {\n\t//getRawList返回一个List列表，列表的每一项为CSV中的一个单元格（既逗号分隔部分）\n\tConsole.log(csvRow.getRawList());\n}\n\n\nCsvRow对象还记录了一些其他信息，包括原始行号等。\n\n# 读取为Bean列表\n\n首先测试的CSV：test_bean.csv:\n\n姓名,gender,focus,age\n张三,男,无,33\n李四,男,好对象,23\n王妹妹,女,特别关注,22\n\n\n 2. 定义Bean：\n\n// lombok注解\n@Data\nprivate static class TestBean{\n\t// 如果csv中标题与字段不对应，可以使用alias注解设置别名\n\t@Alias("姓名")\n\tprivate String name;\n\tprivate String gender;\n\tprivate String focus;\n\tprivate Integer age;\n}\n\n\n 3. 读取\n\nfinal CsvReader reader = CsvUtil.getReader();\n//假设csv文件在classpath目录下\nfinal List<TestBean> result = reader.read(\n\t\t\t\tResourceUtil.getUtf8Reader("https://doc.hutool.cn/assets/js/test_bean.csv"), TestBean.class);\n\n\n 4. 输出：\n\nCsvReaderTest.TestBean(name=张三, gender=男, focus=无, age=33)\nCsvReaderTest.TestBean(name=李四, gender=男, focus=好对象, age=23)\nCsvReaderTest.TestBean(name=王妹妹, gender=女, focus=特别关注, age=22)\n\n\n\n# 生成CSV文件\n\n//指定路径和编码\nCsvWriter writer = CsvUtil.getWriter("e:/testWrite.csv", CharsetUtil.CHARSET_UTF_8);\n//按行写出\nwriter.write(\n\tnew String[] {"a1", "b1", "c1"}, \n\tnew String[] {"a2", "b2", "c2"}, \n\tnew String[] {"a3", "b3", "c3"}\n);\n\n\n效果如下：\n\n\n# 乱码问题\n\nCSV文件本身为一种简单文本格式，有编码区分，你可以使用任意编码。\n\n但是当使用Excel读取CSV文件时，如果你的编码与系统编码不一致，会出现乱码的情况，解决方案如下：\n\n 1. 可以将csv文本编码设置为与系统一致，如Windows下可以设置GBK\n\n 2. 可以增加BOM头来指定编码，这样Excel可以自动识别bom头的编码完成解析。',normalizedContent:'# csv文件处理工具-csvutil\n\n\n# 介绍\n\n逗号分隔值（comma-separated values，csv，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。\n\nhutool针对此格式，参考fastcsv项目做了对csv文件读写的实现(hutool实现完全独立，不依赖第三方)\n\ncsvutil是csv工具类，主要封装了两个方法：\n\n * getreader 用于对csv文件读取\n * getwriter 用于生成csv文件\n\n这两个方法分别获取csvreader对象和csvwriter，从而独立完成csv文件的读写。\n\n\n# 使用\n\n\n# 读取csv文件\n\n# 读取为csvrow\n\ncsvreader reader = csvutil.getreader();\n//从文件中读取csv数据\ncsvdata data = reader.read(fileutil.file("https://doc.hutool.cn/assets/js/test.csv"));\nlist<csvrow> rows = data.getrows();\n//遍历行\nfor (csvrow csvrow : rows) {\n\t//getrawlist返回一个list列表，列表的每一项为csv中的一个单元格（既逗号分隔部分）\n\tconsole.log(csvrow.getrawlist());\n}\n\n\ncsvrow对象还记录了一些其他信息，包括原始行号等。\n\n# 读取为bean列表\n\n首先测试的csv：test_bean.csv:\n\n姓名,gender,focus,age\n张三,男,无,33\n李四,男,好对象,23\n王妹妹,女,特别关注,22\n\n\n 2. 定义bean：\n\n// lombok注解\n@data\nprivate static class testbean{\n\t// 如果csv中标题与字段不对应，可以使用alias注解设置别名\n\t@alias("姓名")\n\tprivate string name;\n\tprivate string gender;\n\tprivate string focus;\n\tprivate integer age;\n}\n\n\n 3. 读取\n\nfinal csvreader reader = csvutil.getreader();\n//假设csv文件在classpath目录下\nfinal list<testbean> result = reader.read(\n\t\t\t\tresourceutil.getutf8reader("https://doc.hutool.cn/assets/js/test_bean.csv"), testbean.class);\n\n\n 4. 输出：\n\ncsvreadertest.testbean(name=张三, gender=男, focus=无, age=33)\ncsvreadertest.testbean(name=李四, gender=男, focus=好对象, age=23)\ncsvreadertest.testbean(name=王妹妹, gender=女, focus=特别关注, age=22)\n\n\n\n# 生成csv文件\n\n//指定路径和编码\ncsvwriter writer = csvutil.getwriter("e:/testwrite.csv", charsetutil.charset_utf_8);\n//按行写出\nwriter.write(\n\tnew string[] {"a1", "b1", "c1"}, \n\tnew string[] {"a2", "b2", "c2"}, \n\tnew string[] {"a3", "b3", "c3"}\n);\n\n\n效果如下：\n\n\n# 乱码问题\n\ncsv文件本身为一种简单文本格式，有编码区分，你可以使用任意编码。\n\n但是当使用excel读取csv文件时，如果你的编码与系统编码不一致，会出现乱码的情况，解决方案如下：\n\n 1. 可以将csv文本编码设置为与系统一致，如windows下可以设置gbk\n\n 2. 可以增加bom头来指定编码，这样excel可以自动识别bom头的编码完成解析。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Unicode编码转换工具-UnicodeUtil",frontmatter:{title:"Unicode编码转换工具-UnicodeUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/UnicodeUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/11.%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C/02.Unicode%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7-UnicodeUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/11.文本操作/02.Unicode编码转换工具-UnicodeUtil.md",key:"v-c06956a8",path:"/pages/UnicodeUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:32},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:84},{level:3,title:"字符串转Unicode符",slug:"字符串转unicode符",normalizedTitle:"字符串转unicode符",charIndex:91},{level:3,title:"Unicode转字符串",slug:"unicode转字符串",normalizedTitle:"unicode转字符串",charIndex:219}],headersStr:"介绍 使用 字符串转Unicode符 Unicode转字符串",content:'# Unicode编码转换工具-UnicodeUtil\n\n\n# 介绍\n\n此工具主要针对类似于\\\\u4e2d\\\\u6587这类Unicode字符做一些特殊转换。\n\n\n# 使用\n\n\n# 字符串转Unicode符\n\n//第二个参数true表示跳过ASCII字符（只跳过可见字符）\nString s = UnicodeUtil.toUnicode("aaa123中文", true);\n//结果aaa123\\\\u4e2d\\\\u6587\n\n\n\n# Unicode转字符串\n\nString str = "aaa\\\\U4e2d\\\\u6587\\\\u111\\\\urtyu\\\\u0026";\nString res = UnicodeUtil.toString(str);\n//结果aaa中文\\\\u111\\\\urtyu&\n\n\n由于\\\\u111为非Unicode字符，因此原样输出。',normalizedContent:'# unicode编码转换工具-unicodeutil\n\n\n# 介绍\n\n此工具主要针对类似于\\\\u4e2d\\\\u6587这类unicode字符做一些特殊转换。\n\n\n# 使用\n\n\n# 字符串转unicode符\n\n//第二个参数true表示跳过ascii字符（只跳过可见字符）\nstring s = unicodeutil.tounicode("aaa123中文", true);\n//结果aaa123\\\\u4e2d\\\\u6587\n\n\n\n# unicode转字符串\n\nstring str = "aaa\\\\u4e2d\\\\u6587\\\\u111\\\\urtyu\\\\u0026";\nstring res = unicodeutil.tostring(str);\n//结果aaa中文\\\\u111\\\\urtyu&\n\n\n由于\\\\u111为非unicode字符，因此原样输出。',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"注解工具-AnnotationUtil",frontmatter:{title:"注解工具-AnnotationUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/AnnotationUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/12.%E6%B3%A8%E8%A7%A3/01.%E6%B3%A8%E8%A7%A3%E5%B7%A5%E5%85%B7-AnnotationUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/12.注解/01.注解工具-AnnotationUtil.md",key:"v-1842494e",path:"/pages/AnnotationUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:26},{level:3,title:"方法介绍",slug:"方法介绍",normalizedTitle:"方法介绍",charIndex:33}],headersStr:"介绍 使用 方法介绍",content:'# 介绍\n\n封装了注解获取等方法的工具类。\n\n\n# 使用\n\n\n# 方法介绍\n\n 1. 注解获取相关方法：\n\n * getAnnotations 获取指定类、方法、字段、构造等上的注解列表\n * getAnnotation 获取指定类型注解\n * getAnnotationValue 获取指定注解属性的值\n\n例子：\n\n我们定义一个注解：\n\n// Retention注解决定MyAnnotation注解的生命周期\n@Retention(RetentionPolicy.RUNTIME)\n// Target注解决定MyAnnotation注解可以加在哪些成分上，如加在类身上，或者属性身上，或者方法身上等成分\n@Target({ ElementType.METHOD, ElementType.TYPE })\npublic @interface AnnotationForTest {\n\t\n\t/**\n\t * 注解的默认属性值\n\t * \n\t * @return 属性值\n\t */\n\tString value();\n}\n\n\n给需要的类加上注解：\n\n@AnnotationForTest("测试")\npublic static class ClassWithAnnotation{\n\n}\n\n\n获取注解中的值：\n\n// value为"测试"\nObject value = AnnotationUtil.getAnnotationValue(ClassWithAnnotation.class, AnnotationForTest.class);\n\n\n 2. 注解属性获取相关方法：\n\n * getRetentionPolicy 获取注解类的保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS\n\n * getTargetType 获取注解类可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等\n\n * isDocumented 是否会保存到 Javadoc 文档中\n\n * isInherited 是否可以被继承，默认为 false\n\n更多方法见API文档：\n\nhttps://apidoc.gitee.com/loolly/hutool/cn/hutool/core/annotation/AnnotationUtil.html',normalizedContent:'# 介绍\n\n封装了注解获取等方法的工具类。\n\n\n# 使用\n\n\n# 方法介绍\n\n 1. 注解获取相关方法：\n\n * getannotations 获取指定类、方法、字段、构造等上的注解列表\n * getannotation 获取指定类型注解\n * getannotationvalue 获取指定注解属性的值\n\n例子：\n\n我们定义一个注解：\n\n// retention注解决定myannotation注解的生命周期\n@retention(retentionpolicy.runtime)\n// target注解决定myannotation注解可以加在哪些成分上，如加在类身上，或者属性身上，或者方法身上等成分\n@target({ elementtype.method, elementtype.type })\npublic @interface annotationfortest {\n\t\n\t/**\n\t * 注解的默认属性值\n\t * \n\t * @return 属性值\n\t */\n\tstring value();\n}\n\n\n给需要的类加上注解：\n\n@annotationfortest("测试")\npublic static class classwithannotation{\n\n}\n\n\n获取注解中的值：\n\n// value为"测试"\nobject value = annotationutil.getannotationvalue(classwithannotation.class, annotationfortest.class);\n\n\n 2. 注解属性获取相关方法：\n\n * getretentionpolicy 获取注解类的保留时间，可选值 source（源码时），class（编译时），runtime（运行时），默认为 class\n\n * gettargettype 获取注解类可以用来修饰哪些程序元素，如 type, method, constructor, field, parameter 等\n\n * isdocumented 是否会保存到 javadoc 文档中\n\n * isinherited 是否可以被继承，默认为 false\n\n更多方法见api文档：\n\nhttps://apidoc.gitee.com/loolly/hutool/cn/hutool/core/annotation/annotationutil.html',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"字符串切割-StrSplitter",frontmatter:{title:"字符串切割-StrSplitter",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/StrSplitter/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/11.%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C/04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%89%B2-StrSplitter.html",relativePath:"01.指南/02.核心（Hutool-core）/11.文本操作/04.字符串切割-StrSplitter.md",key:"v-1e66006d",path:"/pages/StrSplitter/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:29},{level:3,title:"基础方法",slug:"基础方法",normalizedTitle:"基础方法",charIndex:216},{level:3,title:"特殊方法",slug:"特殊方法",normalizedTitle:"特殊方法",charIndex:493}],headersStr:"由来 方法 基础方法 特殊方法",content:'# 由来\n\n在Java的String对象中提供了split方法用于通过某种字符串分隔符来把一个字符串分割为数组。但是有的时候我们对这种操作有不同的要求，默认方法无法满足，这包括：\n\n * 分割限制分割数\n * 分割后每个字符串是否需要去掉两端空格\n * 是否忽略空白项\n * 根据固定长度分割\n * 通过正则分隔\n\n因此，StrSplitter应运而生。StrSplitter中全部为静态方法，方便快捷调用。\n\n\n# 方法\n\n\n# 基础方法\n\n * split 切分字符串，众多可选参数，返回结果为List\n * splitToArray 切分字符串，返回结果为数组\n * splitByRegex 根据正则切分字符串\n * splitByLength 根据固定长度切分字符串\n\n栗子：\n\nString str1 = "a, ,efedsfs,   ddf";\n//参数：被切分字符串，分隔符逗号，0表示无限制分片数，去除两边空格，忽略空白项\nList<String> split = StrSplitter.split(str1, \',\', 0, true, true);\n\n\n\n# 特殊方法\n\n * splitPath 切分字符串，分隔符为"/"\n * splitPathToArray 切分字符串，分隔符为"/"，返回数组',normalizedContent:'# 由来\n\n在java的string对象中提供了split方法用于通过某种字符串分隔符来把一个字符串分割为数组。但是有的时候我们对这种操作有不同的要求，默认方法无法满足，这包括：\n\n * 分割限制分割数\n * 分割后每个字符串是否需要去掉两端空格\n * 是否忽略空白项\n * 根据固定长度分割\n * 通过正则分隔\n\n因此，strsplitter应运而生。strsplitter中全部为静态方法，方便快捷调用。\n\n\n# 方法\n\n\n# 基础方法\n\n * split 切分字符串，众多可选参数，返回结果为list\n * splittoarray 切分字符串，返回结果为数组\n * splitbyregex 根据正则切分字符串\n * splitbylength 根据固定长度切分字符串\n\n栗子：\n\nstring str1 = "a, ,efedsfs,   ddf";\n//参数：被切分字符串，分隔符逗号，0表示无限制分片数，去除两边空格，忽略空白项\nlist<string> split = strsplitter.split(str1, \',\', 0, true, true);\n\n\n\n# 特殊方法\n\n * splitpath 切分字符串，分隔符为"/"\n * splitpathtoarray 切分字符串，分隔符为"/"，返回数组',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Comparator/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/13.%E6%AF%94%E8%BE%83%E5%99%A8/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/02.核心（Hutool-core）/13.比较器/01.概述.md",key:"v-4798df2b",path:"/pages/Comparator/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"提供的比较器",slug:"提供的比较器",normalizedTitle:"提供的比较器",charIndex:33},{level:3,title:"其它比较器",slug:"其它比较器",normalizedTitle:"其它比较器",charIndex:44}],headersStr:"介绍 提供的比较器 其它比较器",content:"# 介绍\n\n各种比较器（Comparator）实现和封装\n\n\n# 提供的比较器\n\n\n# 其它比较器\n\n * ReverseComparator 反转比较器，排序时提供反序\n * VersionComparator 版本比较器，支持如：1.3.20.8，6.82.20160101，8.5a/8.5c等版本形式\n * PropertyComparator Bean属性比较器，通过Bean的某个属性来对Bean对象进行排序\n * IndexedComparator 按照数组的顺序正序排列，数组的元素位置决定了对象的排序先后\n * ComparatorChain 比较器链。此链包装了多个比较器，最终比较结果按照比较器顺序综合多个比较器结果。\n * PinyinComparator 按照GBK拼音顺序对给定的汉字字符串排序。",normalizedContent:"# 介绍\n\n各种比较器（comparator）实现和封装\n\n\n# 提供的比较器\n\n\n# 其它比较器\n\n * reversecomparator 反转比较器，排序时提供反序\n * versioncomparator 版本比较器，支持如：1.3.20.8，6.82.20160101，8.5a/8.5c等版本形式\n * propertycomparator bean属性比较器，通过bean的某个属性来对bean对象进行排序\n * indexedcomparator 按照数组的顺序正序排列，数组的元素位置决定了对象的排序先后\n * comparatorchain 比较器链。此链包装了多个比较器，最终比较结果按照比较器顺序综合多个比较器结果。\n * pinyincomparator 按照gbk拼音顺序对给定的汉字字符串排序。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"可复用字符串生成器-StrBuilder",frontmatter:{title:"可复用字符串生成器-StrBuilder",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/StrBuilder/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/11.%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C/03.%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%94%9F%E6%88%90%E5%99%A8-StrBuilder.html",relativePath:"01.指南/02.核心（Hutool-core）/11.文本操作/03.可复用字符串生成器-StrBuilder.md",key:"v-25beb49e",path:"/pages/StrBuilder/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:27},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:142},{level:2,title:"多次构建字符串性能测试",slug:"多次构建字符串性能测试",normalizedTitle:"多次构建字符串性能测试",charIndex:321}],headersStr:"介绍 使用 多次构建字符串性能测试",content:'# 可复用字符串生成器-StrBuilder\n\n\n# 介绍\n\n在JDK提供的StringBuilder中，拼接字符串变得更加高效和灵活，但是生成新的字符串需要重新构建StringBuilder对象，造成性能损耗和内存浪费，因此Hutool提供了可复用的StrBuilder。\n\n\n# 使用\n\nStrBuilder和StringBuilder使用方法基本一致，只是多了reset方法可以重新构建一个新的字符串而不必开辟新内存。\n\nStrBuilder builder = StrBuilder.create();\nbuilder.append("aaa").append("你好").append(\'r\');\n//结果：aaa你好r\n\n\n\n# 多次构建字符串性能测试\n\n我们模拟创建1000000次字符串对两者性能对比，采用TimeInterval计时：\n\n//StringBuilder \nTimeInterval timer = DateUtil.timer();\nStringBuilder b2 = new StringBuilder();\nfor(int i =0; i< 1000000; i++) {\n\tb2.append("test");\n\tb2 = new StringBuilder();\n}\nConsole.log(timer.interval());\n\n\n//StrBuilder\nTimeInterval timer = DateUtil.timer();\nStrBuilder builder = StrBuilder.create();\nfor(int i =0; i< 1000000; i++) {\n\tbuilder.append("test");\n\tbuilder.reset();\n}\nConsole.log(timer.interval());\n\n\n测试结果为：\n\nStringBuilder: 39ms\nStrBuilder   : 20ms\n\n\n性能几乎翻倍。也欢迎用户自行测试。',normalizedContent:'# 可复用字符串生成器-strbuilder\n\n\n# 介绍\n\n在jdk提供的stringbuilder中，拼接字符串变得更加高效和灵活，但是生成新的字符串需要重新构建stringbuilder对象，造成性能损耗和内存浪费，因此hutool提供了可复用的strbuilder。\n\n\n# 使用\n\nstrbuilder和stringbuilder使用方法基本一致，只是多了reset方法可以重新构建一个新的字符串而不必开辟新内存。\n\nstrbuilder builder = strbuilder.create();\nbuilder.append("aaa").append("你好").append(\'r\');\n//结果：aaa你好r\n\n\n\n# 多次构建字符串性能测试\n\n我们模拟创建1000000次字符串对两者性能对比，采用timeinterval计时：\n\n//stringbuilder \ntimeinterval timer = dateutil.timer();\nstringbuilder b2 = new stringbuilder();\nfor(int i =0; i< 1000000; i++) {\n\tb2.append("test");\n\tb2 = new stringbuilder();\n}\nconsole.log(timer.interval());\n\n\n//strbuilder\ntimeinterval timer = dateutil.timer();\nstrbuilder builder = strbuilder.create();\nfor(int i =0; i< 1000000; i++) {\n\tbuilder.append("test");\n\tbuilder.reset();\n}\nconsole.log(timer.interval());\n\n\n测试结果为：\n\nstringbuilder: 39ms\nstrbuilder   : 20ms\n\n\n性能几乎翻倍。也欢迎用户自行测试。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"比较工具-CompareUtil",frontmatter:{title:"比较工具-CompareUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CompareUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/13.%E6%AF%94%E8%BE%83%E5%99%A8/02.%E6%AF%94%E8%BE%83%E5%B7%A5%E5%85%B7-CompareUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/13.比较器/02.比较工具-CompareUtil.md",key:"v-7881bc68",path:"/pages/CompareUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2}],headersStr:"介绍",content:'# 介绍\n\n在JDK提供的比较器中，对于null的比较没有考虑，Hutool封装了相关比较，可选null是按照最大值还是最小值对待。\n\n// 当isNullGreater为true时，null始终最大，此处返回的compare > 0\nint compare = CompareUtil.compare(null, "a", true);\n\n\n// 当isNullGreater为false时，null始终最小，此处返回的compare < 0\nint compare = CompareUtil.compare(null, "a", false);\n',normalizedContent:'# 介绍\n\n在jdk提供的比较器中，对于null的比较没有考虑，hutool封装了相关比较，可选null是按照最大值还是最小值对待。\n\n// 当isnullgreater为true时，null始终最大，此处返回的compare > 0\nint compare = compareutil.compare(null, "a", true);\n\n\n// 当isnullgreater为false时，null始终最小，此处返回的compare < 0\nint compare = compareutil.compare(null, "a", false);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"版本比较器-VersionComparator",frontmatter:{title:"版本比较器-VersionComparator",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/VersionComparator/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/13.%E6%AF%94%E8%BE%83%E5%99%A8/03.%E7%89%88%E6%9C%AC%E6%AF%94%E8%BE%83%E5%99%A8-VersionComparator.html",relativePath:"01.指南/02.核心（Hutool-core）/13.比较器/03.版本比较器-VersionComparator.md",key:"v-6ddee54a",path:"/pages/VersionComparator/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:117}],headersStr:"介绍 使用",content:'# 介绍\n\n版本比较器用于比较版本号，支持的格式包括：\n\n * x.x.x(1.3.20)\n * x.x.yyyyMMdd(6.82.20160101)\n * 带字母的版本(8.5a/8.5c)\n * 带V的版本(V8.5)\n\n\n# 使用\n\n// -1\nint compare = VersionComparator.INSTANCE.compare("1.12.1", "https://doc.hutool.cn/assets/js/1.12.1c");\n\n\n// 1\nint compare = VersionComparator.INSTANCE.compare("V0.0.20170102", "V0.0.20170101");\n',normalizedContent:'# 介绍\n\n版本比较器用于比较版本号，支持的格式包括：\n\n * x.x.x(1.3.20)\n * x.x.yyyymmdd(6.82.20160101)\n * 带字母的版本(8.5a/8.5c)\n * 带v的版本(v8.5)\n\n\n# 使用\n\n// -1\nint compare = versioncomparator.instance.compare("1.12.1", "https://doc.hutool.cn/assets/js/1.12.1c");\n\n\n// 1\nint compare = versioncomparator.instance.compare("v0.0.20170102", "v0.0.20170101");\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"异常工具-ExceptionUtil",frontmatter:{title:"异常工具-ExceptionUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ExceptionUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/14.%E5%BC%82%E5%B8%B8/01.%E5%BC%82%E5%B8%B8%E5%B7%A5%E5%85%B7-ExceptionUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/14.异常/01.异常工具-ExceptionUtil.md",key:"v-06f6cec8",path:"/pages/ExceptionUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:40},{level:3,title:"包装异常",slug:"包装异常",normalizedTitle:"包装异常",charIndex:47},{level:3,title:"获取入口方法",slug:"获取入口方法",normalizedTitle:"获取入口方法",charIndex:187},{level:3,title:"异常转换",slug:"异常转换",normalizedTitle:"异常转换",charIndex:290},{level:3,title:"其他方法",slug:"其他方法",normalizedTitle:"其他方法",charIndex:585}],headersStr:"介绍 方法 包装异常 获取入口方法 异常转换 其他方法",content:"# 介绍\n\n针对异常封装，例如包装为RuntimeException。\n\n\n# 方法\n\n\n# 包装异常\n\n假设系统抛出一个非Runtime异常，我们需要包装为Runtime异常，那么：\n\nIORuntimeException e = ExceptionUtil.wrap(new IOException(), IORuntimeException.class);\n\n\n\n# 获取入口方法\n\nStackTraceElement ele = ExceptionUtil.getRootStackElement();\n// main\nele.getMethodName();\n\n\n\n# 异常转换\n\n如果我们想把异常转换指定异常为来自或者包含指定异常，那么：\n\nIOException ioException = new IOException();\nIllegalArgumentException argumentException = new IllegalArgumentException(ioException);\n\nIOException ioException1 = ExceptionUtil.convertFromOrSuppressedThrowable(argumentException, IOException.class, true);\n\n\n\n# 其他方法\n\n * getMessage 获得完整消息，包括异常名\n * wrapRuntime 使用运行时异常包装编译异常\n * getCausedBy 获取由指定异常类引起的异常\n * isCausedBy 判断是否由指定异常类引起\n * stacktraceToString 堆栈转为完整字符串\n\n其它方法见API文档：\n\nhttps://apidoc.gitee.com/dromara/hutool/cn/hutool/core/exceptions/ExceptionUtil.html",normalizedContent:"# 介绍\n\n针对异常封装，例如包装为runtimeexception。\n\n\n# 方法\n\n\n# 包装异常\n\n假设系统抛出一个非runtime异常，我们需要包装为runtime异常，那么：\n\nioruntimeexception e = exceptionutil.wrap(new ioexception(), ioruntimeexception.class);\n\n\n\n# 获取入口方法\n\nstacktraceelement ele = exceptionutil.getrootstackelement();\n// main\nele.getmethodname();\n\n\n\n# 异常转换\n\n如果我们想把异常转换指定异常为来自或者包含指定异常，那么：\n\nioexception ioexception = new ioexception();\nillegalargumentexception argumentexception = new illegalargumentexception(ioexception);\n\nioexception ioexception1 = exceptionutil.convertfromorsuppressedthrowable(argumentexception, ioexception.class, true);\n\n\n\n# 其他方法\n\n * getmessage 获得完整消息，包括异常名\n * wrapruntime 使用运行时异常包装编译异常\n * getcausedby 获取由指定异常类引起的异常\n * iscausedby 判断是否由指定异常类引起\n * stacktracetostring 堆栈转为完整字符串\n\n其它方法见api文档：\n\nhttps://apidoc.gitee.com/dromara/hutool/cn/hutool/core/exceptions/exceptionutil.html",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"数学相关-MathUtil",frontmatter:{title:"数学相关-MathUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/MathUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/15.%E6%95%B0%E5%AD%A6/01.%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3-MathUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/15.数学/01.数学相关-MathUtil.md",key:"v-2913be89",path:"/pages/MathUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:20},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:89}],headersStr:"介绍 方法",content:"# 数学相关-MathUtil\n\n\n# 介绍\n\n此工具是NumberUtil的一个补充，NumberUtil偏向于简单数学计算的封装，MathUtil偏向复杂数学计算。\n\n\n# 方法\n\n 1. 排列\n\n * arrangementCount 计算排列数\n * arrangementSelect 排列选择（从列表中选择n个排列）\n\n 2. 组合\n\n * combinationCount 计算组合数，即C(n, m) = n!/((n-m)! * m!)\n * combinationSelect 组合选择（从列表中选择n个组合）",normalizedContent:"# 数学相关-mathutil\n\n\n# 介绍\n\n此工具是numberutil的一个补充，numberutil偏向于简单数学计算的封装，mathutil偏向复杂数学计算。\n\n\n# 方法\n\n 1. 排列\n\n * arrangementcount 计算排列数\n * arrangementselect 排列选择（从列表中选择n个排列）\n\n 2. 组合\n\n * combinationcount 计算组合数，即c(n, m) = n!/((n-m)! * m!)\n * combinationselect 组合选择（从列表中选择n个组合）",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"其它异常封装",frontmatter:{title:"其它异常封装",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Exception/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/14.%E5%BC%82%E5%B8%B8/02.%E5%85%B6%E5%AE%83%E5%BC%82%E5%B8%B8%E5%B0%81%E8%A3%85.html",relativePath:"01.指南/02.核心（Hutool-core）/14.异常/02.其它异常封装.md",key:"v-584ec5fd",path:"/pages/Exception/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"异常类",slug:"异常类",normalizedTitle:"异常类",charIndex:26}],headersStr:"介绍 异常类",content:"# 介绍\n\n针对Hutool中常见异常封装\n\n\n# 异常类\n\n * DependencyException 依赖异常\n * StatefulException 带有状态码的异常\n * UtilException 工具类异常\n * NotInitedException 未初始化异常\n * ValidateException 验证异常",normalizedContent:"# 介绍\n\n针对hutool中常见异常封装\n\n\n# 异常类\n\n * dependencyexception 依赖异常\n * statefulexception 带有状态码的异常\n * utilexception 工具类异常\n * notinitedexception 未初始化异常\n * validateexception 验证异常",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"异步工具类-AsyncUtil",frontmatter:{title:"异步工具类-AsyncUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/AsyncUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/16.%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/02.%E5%BC%82%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-AsyncUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/16.线程和并发/02.异步工具类-AsyncUtil.md",key:"v-563b470c",path:"/pages/AsyncUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:76},{level:3,title:"AsyncUtil.waitAll",slug:"asyncutil-waitall",normalizedTitle:"asyncutil.waitall",charIndex:83},{level:3,title:"AsyncUtil.waitAny",slug:"asyncutil-waitany",normalizedTitle:"asyncutil.waitany",charIndex:117},{level:3,title:"https://doc.hutool.cn/assets/js/AsyncUtil.get",slug:"asyncutil-get",normalizedTitle:"https://doc.hutool.cn/assets/js/asyncutil.get",charIndex:153}],headersStr:"https://doc.hutool.cn/assets/js/由来 方法 AsyncUtil.waitAll AsyncUtil.waitAny AsyncUtil.get",content:"# 由来\n\n在JDK8中，提供了CompletableFuture进行异步执行\n\n使用场景如异步调用微服务、异步查询数据库、异步运算大量数据等\n\n\n# 方法\n\n\n# AsyncUtil.waitAll\n\n等待所有任务执行完毕\n\n\n# AsyncUtil.waitAny\n\n等待任意一个任务执行完毕\n\n\n# AsyncUtil.get\n\n获取异步任务结果",normalizedContent:"# 由来\n\n在jdk8中，提供了completablefuture进行异步执行\n\n使用场景如异步调用微服务、异步查询数据库、异步运算大量数据等\n\n\n# 方法\n\n\n# asyncutil.waitall\n\n等待所有任务执行完毕\n\n\n# asyncutil.waitany\n\n等待任意一个任务执行完毕\n\n\n# asyncutil.get\n\n获取异步任务结果",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"高并发测试-ConcurrencyTester",frontmatter:{title:"高并发测试-ConcurrencyTester",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ConcurrencyTester/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/16.%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/04.%E9%AB%98%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95-ConcurrencyTester.html",relativePath:"01.指南/02.核心（Hutool-core）/16.线程和并发/04.高并发测试-ConcurrencyTester.md",key:"v-10bd6e8e",path:"/pages/ConcurrencyTester/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:83}],headersStr:"由来 使用",content:'# 由来\n\n很多时候，我们需要简单模拟N个线程调用某个业务测试其并发状况，于是Hutool提供了一个简单的并发测试类——ConcurrencyTester。\n\n\n# 使用\n\nConcurrencyTester tester = ThreadUtil.concurrencyTest(100, () -> {\n\t// 测试的逻辑内容\n\tlong delay = RandomUtil.randomLong(100, 1000);\n\tThreadUtil.sleep(delay);\n\tConsole.log("{} test finished, delay: {}", Thread.currentThread().getName(), delay);\n});\n\n// 获取总的执行时间，单位毫秒\nConsole.log(tester.getInterval());\n',normalizedContent:'# 由来\n\n很多时候，我们需要简单模拟n个线程调用某个业务测试其并发状况，于是hutool提供了一个简单的并发测试类——concurrencytester。\n\n\n# 使用\n\nconcurrencytester tester = threadutil.concurrencytest(100, () -> {\n\t// 测试的逻辑内容\n\tlong delay = randomutil.randomlong(100, 1000);\n\tthreadutil.sleep(delay);\n\tconsole.log("{} test finished, delay: {}", thread.currentthread().getname(), delay);\n});\n\n// 获取总的执行时间，单位毫秒\nconsole.log(tester.getinterval());\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"线程工具-ThreadUtil",frontmatter:{title:"线程工具-ThreadUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ThreadUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/16.%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/01.%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%85%B7-ThreadUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/16.线程和并发/01.线程工具-ThreadUtil.md",key:"v-e9d6fd42",path:"/pages/ThreadUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:191},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:163},{level:3,title:"ThreadUtil.execute",slug:"threadutil-execute",normalizedTitle:"threadutil.execute",charIndex:260},{level:3,title:"ThreadUtil.newExecutor",slug:"threadutil-newexecutor",normalizedTitle:"threadutil.newexecutor",charIndex:298},{level:3,title:"ThreadUtil.execAsync",slug:"threadutil-execasync",normalizedTitle:"threadutil.execasync",charIndex:336},{level:3,title:"ThreadUtil.newCompletionService",slug:"threadutil-newcompletionservice",normalizedTitle:"threadutil.newcompletionservice",charIndex:369},{level:3,title:"ThreadUtil.newCountDownLatch",slug:"threadutil-newcountdownlatch",normalizedTitle:"threadutil.newcountdownlatch",charIndex:482},{level:3,title:"ThreadUtil.sleep",slug:"threadutil-sleep",normalizedTitle:"threadutil.sleep",charIndex:579},{level:3,title:"ThreadUtil.getStackTrace",slug:"threadutil-getstacktrace",normalizedTitle:"threadutil.getstacktrace",charIndex:787},{level:3,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:883}],headersStr:"由来 原理 方法 ThreadUtil.execute ThreadUtil.newExecutor ThreadUtil.execAsync ThreadUtil.newCompletionService ThreadUtil.newCountDownLatch ThreadUtil.sleep ThreadUtil.getStackTrace 其它",content:"# 由来\n\n并发在Java中算是一个比较难理解和容易出问题的部分，而并发的核心在线程。好在从JDK1.5开始Java提供了concurrent包可以很好的帮我们处理大部分并发、异步等问题。\n\n不过，ExecutorService和Executors等众多概念依旧让我们使用这个包变得比较麻烦，如何才能隐藏这些概念？又如何用一个方法解决问题？ThreadUtil便为此而生。\n\n\n# 原理\n\nHutool使用GlobalThreadPool持有一个全局的线程池，默认所有异步方法在这个线程池中执行。\n\n\n# 方法\n\n\n# ThreadUtil.execute\n\n直接在公共线程池中执行线程\n\n\n# ThreadUtil.newExecutor\n\n获得一个新的线程池\n\n\n# ThreadUtil.execAsync\n\n执行异步方法\n\n\n# ThreadUtil.newCompletionService\n\n创建CompletionService，调用其submit方法可以异步执行多个任务，最后调用take方法按照完成的顺序获得其结果。若未完成，则会阻塞。\n\n\n# ThreadUtil.newCountDownLatch\n\n新建一个CountDownLatch，一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。\n\n\n# ThreadUtil.sleep\n\n挂起当前线程，是Thread.sleep的封装，通过返回boolean值表示是否被打断，而不是抛出异常。\n\n> ThreadUtil.safeSleep方法是一个保证挂起足够时间的方法，当给定一个挂起时间，使用此方法可以保证挂起的时间大于或等于给定时间，解决Thread.sleep挂起时间不足问题，此方法在Hutool-cron的定时器中使用保证定时任务执行的准确性。\n\n\n# ThreadUtil.getStackTrace\n\n此部分包括两个方法：\n\n * getStackTrace 获得堆栈列表\n * getStackTraceElement 获得堆栈项\n\n\n# 其它\n\n * createThreadLocal 创建本地线程对象\n * interupt 结束线程，调用此方法后，线程将抛出InterruptedException异常\n * waitForDie 等待线程结束. 调用 Thread.join() 并忽略 InterruptedException\n * getThreads 获取JVM中与当前线程同组的所有线程\n * getMainThread 获取进程的主线程",normalizedContent:"# 由来\n\n并发在java中算是一个比较难理解和容易出问题的部分，而并发的核心在线程。好在从jdk1.5开始java提供了concurrent包可以很好的帮我们处理大部分并发、异步等问题。\n\n不过，executorservice和executors等众多概念依旧让我们使用这个包变得比较麻烦，如何才能隐藏这些概念？又如何用一个方法解决问题？threadutil便为此而生。\n\n\n# 原理\n\nhutool使用globalthreadpool持有一个全局的线程池，默认所有异步方法在这个线程池中执行。\n\n\n# 方法\n\n\n# threadutil.execute\n\n直接在公共线程池中执行线程\n\n\n# threadutil.newexecutor\n\n获得一个新的线程池\n\n\n# threadutil.execasync\n\n执行异步方法\n\n\n# threadutil.newcompletionservice\n\n创建completionservice，调用其submit方法可以异步执行多个任务，最后调用take方法按照完成的顺序获得其结果。若未完成，则会阻塞。\n\n\n# threadutil.newcountdownlatch\n\n新建一个countdownlatch，一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。\n\n\n# threadutil.sleep\n\n挂起当前线程，是thread.sleep的封装，通过返回boolean值表示是否被打断，而不是抛出异常。\n\n> threadutil.safesleep方法是一个保证挂起足够时间的方法，当给定一个挂起时间，使用此方法可以保证挂起的时间大于或等于给定时间，解决thread.sleep挂起时间不足问题，此方法在hutool-cron的定时器中使用保证定时任务执行的准确性。\n\n\n# threadutil.getstacktrace\n\n此部分包括两个方法：\n\n * getstacktrace 获得堆栈列表\n * getstacktraceelement 获得堆栈项\n\n\n# 其它\n\n * createthreadlocal 创建本地线程对象\n * interupt 结束线程，调用此方法后，线程将抛出interruptedexception异常\n * waitfordie 等待线程结束. 调用 thread.join() 并忽略 interruptedexception\n * getthreads 获取jvm中与当前线程同组的所有线程\n * getmainthread 获取进程的主线程",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"自定义线程池-ExecutorBuilder",frontmatter:{title:"自定义线程池-ExecutorBuilder",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ExecutorBuilder/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/16.%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/03.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0-ExecutorBuilder.html",relativePath:"01.指南/02.核心（Hutool-core）/16.线程和并发/03.自定义线程池-ExecutorBuilder.md",key:"v-45514f4e",path:"/pages/ExecutorBuilder/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:3,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:66},{level:3,title:"线程池对待线程的策略",slug:"线程池对待线程的策略",normalizedTitle:"线程池对待线程的策略",charIndex:292},{level:3,title:"workQueue线程池策略",slug:"workqueue线程池策略",normalizedTitle:"workqueue线程池策略",charIndex:468},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:94}],headersStr:"由来 概念 线程池对待线程的策略 workQueue线程池策略 使用",content:"# 由来\n\n在JDK中，提供了Executors用于创建自定义的线程池对象ExecutorService，但是考虑到线程池中存在众多概念，这些概念通过不同的搭配实现灵活的线程管理策略，单独使用Executors无法满足需求，所以构建了ExecutorBuilder。\n\n\n# 概念\n\n * corePoolSize 初始池大小\n * maxPoolSize 最大池大小（允许同时执行的最大线程数）\n * workQueue 队列，用于存储未执行的任务\n * handler 当线程阻塞（block）时的异常处理器，所谓线程阻塞即线程池和等待队列已满，无法处理线程时采取的策略\n\n\n# 线程池对待线程的策略\n\n 1. 如果池中任务数 < corePoolSize -> 放入立即执行\n 2. 如果池中任务数 > corePoolSize -> 放入队列等待\n 3. 队列满 -> 新建线程立即执行\n 4. 执行中的线程 > maxPoolSize -> 触发handler（RejectedExecutionHandler）异常\n\n\n# workQueue线程池策略\n\n * SynchronousQueue 它将任务直接提交给线程而不保持它们。当运行线程小于maxPoolSize时会创建新线程，否则触发异常策略\n * LinkedBlockingQueue 默认无界队列，当运行线程大于corePoolSize时始终放入此队列，此时maxPoolSize无效。当构造LinkedBlockingQueue对象时传入参数，变为有界队列，队列满时，运行线程小于maxPoolSize时会创建新线程，否则触发异常策略\n * ArrayBlockingQueue 有界队列，相对无界队列有利于控制队列大小，队列满时，运行线程小于maxPoolSize时会创建新线程，否则触发异常策略\n\n\n# 使用\n\n 1. 默认线程池\n\n策略如下：\n\n * 初始线程数为corePoolSize指定的大小\n * 没有最大线程数限制\n * 默认使用LinkedBlockingQueue，默认队列大小为1024（最大等待数1024）\n * 当运行线程大于corePoolSize放入队列，队列满后抛出异常\n\nExecutorService executor = ExecutorBuilder builder = ExecutorBuilder.create()..build();\n\n\n 2. 单线程线程池\n\n * 初始线程数为 1\n * 最大线程数为 1\n * 默认使用LinkedBlockingQueue，默认队列大小为1024\n * 同时只允许一个线程工作，剩余放入队列等待，等待数超过1024报错\n\nExecutorService executor = ExecutorBuilder.create()//\n\t.setCorePoolSize(1)//\n\t.setMaxPoolSize(1)//\n\t.setKeepAliveTime(0)//\n\t.build();\n\n\n 3. 更多选项的线程池\n\n * 初始5个线程\n * 最大10个线程\n * 有界等待队列，最大等待数是100\n\nExecutorService executor = ExecutorBuilder.create()\n\t.setCorePoolSize(5)\n\t.setMaxPoolSize(10)\n\t.setWorkQueue(new LinkedBlockingQueue<>(100))\n\t.build();\n\n\n 3. 特殊策略的线程池\n\n * 初始5个线程\n * 最大10个线程\n * 它将任务直接提交给线程而不保持它们。当运行线程小于maxPoolSize时会创建新线程，否则触发异常策略\n\nExecutorService executor = ExecutorBuilder.create()\n\t.setCorePoolSize(5)\n\t.setMaxPoolSize(10)\n\t.useSynchronousQueue()\n\t.build();\n",normalizedContent:"# 由来\n\n在jdk中，提供了executors用于创建自定义的线程池对象executorservice，但是考虑到线程池中存在众多概念，这些概念通过不同的搭配实现灵活的线程管理策略，单独使用executors无法满足需求，所以构建了executorbuilder。\n\n\n# 概念\n\n * corepoolsize 初始池大小\n * maxpoolsize 最大池大小（允许同时执行的最大线程数）\n * workqueue 队列，用于存储未执行的任务\n * handler 当线程阻塞（block）时的异常处理器，所谓线程阻塞即线程池和等待队列已满，无法处理线程时采取的策略\n\n\n# 线程池对待线程的策略\n\n 1. 如果池中任务数 < corepoolsize -> 放入立即执行\n 2. 如果池中任务数 > corepoolsize -> 放入队列等待\n 3. 队列满 -> 新建线程立即执行\n 4. 执行中的线程 > maxpoolsize -> 触发handler（rejectedexecutionhandler）异常\n\n\n# workqueue线程池策略\n\n * synchronousqueue 它将任务直接提交给线程而不保持它们。当运行线程小于maxpoolsize时会创建新线程，否则触发异常策略\n * linkedblockingqueue 默认无界队列，当运行线程大于corepoolsize时始终放入此队列，此时maxpoolsize无效。当构造linkedblockingqueue对象时传入参数，变为有界队列，队列满时，运行线程小于maxpoolsize时会创建新线程，否则触发异常策略\n * arrayblockingqueue 有界队列，相对无界队列有利于控制队列大小，队列满时，运行线程小于maxpoolsize时会创建新线程，否则触发异常策略\n\n\n# 使用\n\n 1. 默认线程池\n\n策略如下：\n\n * 初始线程数为corepoolsize指定的大小\n * 没有最大线程数限制\n * 默认使用linkedblockingqueue，默认队列大小为1024（最大等待数1024）\n * 当运行线程大于corepoolsize放入队列，队列满后抛出异常\n\nexecutorservice executor = executorbuilder builder = executorbuilder.create()..build();\n\n\n 2. 单线程线程池\n\n * 初始线程数为 1\n * 最大线程数为 1\n * 默认使用linkedblockingqueue，默认队列大小为1024\n * 同时只允许一个线程工作，剩余放入队列等待，等待数超过1024报错\n\nexecutorservice executor = executorbuilder.create()//\n\t.setcorepoolsize(1)//\n\t.setmaxpoolsize(1)//\n\t.setkeepalivetime(0)//\n\t.build();\n\n\n 3. 更多选项的线程池\n\n * 初始5个线程\n * 最大10个线程\n * 有界等待队列，最大等待数是100\n\nexecutorservice executor = executorbuilder.create()\n\t.setcorepoolsize(5)\n\t.setmaxpoolsize(10)\n\t.setworkqueue(new linkedblockingqueue<>(100))\n\t.build();\n\n\n 3. 特殊策略的线程池\n\n * 初始5个线程\n * 最大10个线程\n * 它将任务直接提交给线程而不保持它们。当运行线程小于maxpoolsize时会创建新线程，否则触发异常策略\n\nexecutorservice executor = executorbuilder.create()\n\t.setcorepoolsize(5)\n\t.setmaxpoolsize(10)\n\t.usesynchronousqueue()\n\t.build();\n",charsets:{cjk:!0},lastUpdated:"2023/10/23, 14:33:13",lastUpdatedTimestamp:1698042793e3},{title:"图片编辑器-Img",frontmatter:{title:"图片编辑器-Img",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Img/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/17.%E5%9B%BE%E7%89%87/02.%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91%E5%99%A8-Img.html",relativePath:"01.指南/02.核心（Hutool-core）/17.图片/02.图片编辑器-Img.md",key:"v-51b8eafc",path:"/pages/Img/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法介绍",slug:"方法介绍",normalizedTitle:"方法介绍",charIndex:51},{level:3,title:"图像切割",slug:"图像切割",normalizedTitle:"图像切割",charIndex:60},{level:3,title:"图片压缩",slug:"图片压缩",normalizedTitle:"图片压缩",charIndex:223}],headersStr:"介绍 方法介绍 图像切割 图片压缩",content:'# 介绍\n\n针对awt中图片处理进行封装，这些封装包括：缩放、裁剪、转为黑白、加水印等操作。\n\n\n# 方法介绍\n\n\n# 图像切割\n\n// 将face.jpg切割为原型保存为face_radis.png\nImg.from(FileUtil.file("e:/pic/face.jpg"))\n    .cut(0, 0, 200)//\n    .write(FileUtil.file("e:/pic/face_radis.png"));\n\n\n\n# 图片压缩\n\n图片压缩只支持Jpg文件。\n\nImg.from(FileUtil.file("e:/pic/1111.png"))\n    .setQuality(0.8)//压缩比率\n    .write(FileUtil.file("e:/pic/1111_target.jpg"));\n',normalizedContent:'# 介绍\n\n针对awt中图片处理进行封装，这些封装包括：缩放、裁剪、转为黑白、加水印等操作。\n\n\n# 方法介绍\n\n\n# 图像切割\n\n// 将face.jpg切割为原型保存为face_radis.png\nimg.from(fileutil.file("e:/pic/face.jpg"))\n    .cut(0, 0, 200)//\n    .write(fileutil.file("e:/pic/face_radis.png"));\n\n\n\n# 图片压缩\n\n图片压缩只支持jpg文件。\n\nimg.from(fileutil.file("e:/pic/1111.png"))\n    .setquality(0.8)//压缩比率\n    .write(fileutil.file("e:/pic/1111_target.jpg"));\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"网络工具-NetUtil",frontmatter:{title:"网络工具-NetUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/NetUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/18.%E7%BD%91%E7%BB%9C/01.%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7-NetUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/18.网络/01.网络工具-NetUtil.md",key:"v-90d3aa78",path:"/pages/NetUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:63},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:444}],headersStr:"由来 介绍 使用",content:'# 由来\n\n在日常开发中，网络连接这块儿必不可少。日常用到的一些功能,隐藏掉部分IP地址、绝对和相对路径的转换等等。\n\n\n# 介绍\n\nNetUtil 工具中主要的方法包括：\n\n 1.  longToIpv4 根据long值获取ipv4地址\n 2.  ipv4ToLong 根据ip地址计算出long型的数据\n 3.  isUsableLocalPort 检测本地端口可用性\n 4.  isValidPort 是否为有效的端口\n 5.  isInnerIP 判定是否为内网IP\n 6.  localIpv4s 获得本机的IP地址列表\n 7.  toAbsoluteUrl 相对URL转换为绝对URL\n 8.  hideIpPart 隐藏掉IP地址的最后一部分为 * 代替\n 9.  buildInetSocketAddress 构建InetSocketAddress\n 10. getIpByHost 通过域名得到IP\n 11. isInner 指定IP的long是否在指定范围内\n\n\n# 使用\n\nString ip= "127.0.0.1";\nlong iplong = 2130706433L;\n\n//根据long值获取ip v4地址\nString ip= NetUtil.longToIpv4(iplong);\n\n\n//根据ip地址计算出long型的数据\nlong ip= NetUtil.ipv4ToLong(ip);\n\n//检测本地端口可用性\nboolean result= NetUtil.isUsableLocalPort(6379);\n\n//是否为有效的端口\nboolean result= NetUtil.isValidPort(6379);\n\n//隐藏掉IP地址\n String result =NetUtil.hideIpPart(ip);\n\n\n更多方法请见：\n\nAPI文档-NetUtil',normalizedContent:'# 由来\n\n在日常开发中，网络连接这块儿必不可少。日常用到的一些功能,隐藏掉部分ip地址、绝对和相对路径的转换等等。\n\n\n# 介绍\n\nnetutil 工具中主要的方法包括：\n\n 1.  longtoipv4 根据long值获取ipv4地址\n 2.  ipv4tolong 根据ip地址计算出long型的数据\n 3.  isusablelocalport 检测本地端口可用性\n 4.  isvalidport 是否为有效的端口\n 5.  isinnerip 判定是否为内网ip\n 6.  localipv4s 获得本机的ip地址列表\n 7.  toabsoluteurl 相对url转换为绝对url\n 8.  hideippart 隐藏掉ip地址的最后一部分为 * 代替\n 9.  buildinetsocketaddress 构建inetsocketaddress\n 10. getipbyhost 通过域名得到ip\n 11. isinner 指定ip的long是否在指定范围内\n\n\n# 使用\n\nstring ip= "127.0.0.1";\nlong iplong = 2130706433l;\n\n//根据long值获取ip v4地址\nstring ip= netutil.longtoipv4(iplong);\n\n\n//根据ip地址计算出long型的数据\nlong ip= netutil.ipv4tolong(ip);\n\n//检测本地端口可用性\nboolean result= netutil.isusablelocalport(6379);\n\n//是否为有效的端口\nboolean result= netutil.isvalidport(6379);\n\n//隐藏掉ip地址\n string result =netutil.hideippart(ip);\n\n\n更多方法请见：\n\napi文档-netutil',charsets:{cjk:!0},lastUpdated:"2023/10/23, 14:33:13",lastUpdatedTimestamp:1698042793e3},{title:"URL生成器-UrlBuilder",frontmatter:{title:"URL生成器-UrlBuilder",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/UrlBuilder/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/18.%E7%BD%91%E7%BB%9C/02.URL%E7%94%9F%E6%88%90%E5%99%A8-UrlBuilder.html",relativePath:"01.指南/02.核心（Hutool-core）/18.网络/02.URL生成器-UrlBuilder.md",key:"v-7d37ac67",path:"/pages/UrlBuilder/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:455},{level:3,title:"完整构建",slug:"完整构建",normalizedTitle:"完整构建",charIndex:732},{level:3,title:"中文编码",slug:"中文编码",normalizedTitle:"中文编码",charIndex:974},{level:3,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:47},{level:3,title:"特殊URL解析",slug:"特殊url解析",normalizedTitle:"特殊url解析",charIndex:1645}],headersStr:"由来 使用 完整构建 中文编码 解析 特殊URL解析",content:'# 由来\n\n在JDK中，我们可以借助URL对象完成URL的格式化，但是无法完成一些特殊URL的解析和处理，例如编码过的URL、不标准的路径和参数。在旧版本的hutool中，URL的规范完全靠字符串的替换来完成，不但效率低，而且处理过程及其复杂。于是在5.3.1之后，加入了UrlBuilder类，拆分URL的各个部分，分别处理和格式化，完成URL的规范化。\n\n按照Uniform Resource Identifier的标准定义，URL的结构如下：\n\n * [scheme:]scheme-specific-part[#fragment]\n\n * [scheme:][//authority][path][?query][#fragment]\n\n * [scheme:][//host:port][path][?query][#fragment]\n\n按照这个格式，UrlBuilder将URL分成scheme、host、port、path、query、fragment部分，其中path和query较为复杂，又使用UrlPath和UrlQuery分别封装。\n\n\n# 使用\n\n相比URL对象，UrlBuilder更加人性化，例如：\n\nURL url = new URL("https://doc.hutool.cn/assets/js/www.hutool.cn")\n\n\n此时会报java.net.MalformedURLException: no protocol的错误，而使用UrlBuilder则会有默认协议：\n\n// 输出 http://www.hutool.cn/\nString buildUrl = UrlBuilder.create().setHost("https://doc.hutool.cn/assets/js/www.hutool.cn").build();\n\n\n\n# 完整构建\n\n// https://www.hutool.cn/aaa/bbb?ie=UTF-8&wd=test\nString buildUrl = UrlBuilder.create()\n\t.setScheme("https")\n\t.setHost("https://doc.hutool.cn/assets/js/www.hutool.cn")\n\t.addPath("/aaa").addPath("bbb")\n\t.addQuery("ie", "UTF-8")\n\t.addQuery("wd", "test")\n\t.build();\n\n\n\n# 中文编码\n\n当参数中有中文时，自动编码中文，默认UTF-8编码，也可以调用setCharset方法自定义编码。\n\n// https://www.hutool.cn/s?ie=UTF-8&ie=GBK&wd=%E6%B5%8B%E8%AF%95\nString buildUrl = UrlBuilder.create()\n\t.setScheme("https")\n\t.setHost("https://doc.hutool.cn/assets/js/www.hutool.cn")\n\t.addPath("/s")\n\t.addQuery("ie", "UTF-8")\n\t.addQuery("ie", "GBK")\n\t.addQuery("wd", "测试")\n\t.build();\n\n\n\n# 解析\n\n当有一个URL字符串时，可以使用of方法解析：\n\nUrlBuilder builder = UrlBuilder.ofHttp("www.hutool.cn/aaa/bbb/?a=张三&b=%e6%9d%8e%e5%9b%9b#frag1", CharsetUtil.CHARSET_UTF_8);\n\n// 输出张三\nConsole.log(builder.getQuery().get("a"));\n// 输出李四\nConsole.log(builder.getQuery().get("b"));\n\n\n我们发现这个例子中，原URL中的参数a是没有编码的，b是编码过的，当用户提供此类混合URL时，Hutool可以很好的识别并全部decode，当然，调用build()之后，会全部再encode。\n\n\n# 特殊URL解析\n\n有时候URL中会存在&amp;这种分隔符，谷歌浏览器会将此字符串转换为&使用，Hutool中也同样如此：\n\nString urlStr = "https://mp.weixin.qq.com/s?__biz=MzI5NjkyNTIxMg==&amp;mid=100000465&amp;idx=1";\nUrlBuilder builder = UrlBuilder.ofHttp(urlStr, CharsetUtil.CHARSET_UTF_8);\n\n// https://mp.weixin.qq.com/s?__biz=MzI5NjkyNTIxMg==&mid=100000465&idx=1\nConsole.log(builder.build());\n\n\n> UrlBuilder主要应用于http模块，在构建HttpRequest时，用户传入的URL五花八门，为了做到最好的适应性，减少用户对URL的处理，使用UrlBuilder完成URL的规范化。',normalizedContent:'# 由来\n\n在jdk中，我们可以借助url对象完成url的格式化，但是无法完成一些特殊url的解析和处理，例如编码过的url、不标准的路径和参数。在旧版本的hutool中，url的规范完全靠字符串的替换来完成，不但效率低，而且处理过程及其复杂。于是在5.3.1之后，加入了urlbuilder类，拆分url的各个部分，分别处理和格式化，完成url的规范化。\n\n按照uniform resource identifier的标准定义，url的结构如下：\n\n * [scheme:]scheme-specific-part[#fragment]\n\n * [scheme:][//authority][path][?query][#fragment]\n\n * [scheme:][//host:port][path][?query][#fragment]\n\n按照这个格式，urlbuilder将url分成scheme、host、port、path、query、fragment部分，其中path和query较为复杂，又使用urlpath和urlquery分别封装。\n\n\n# 使用\n\n相比url对象，urlbuilder更加人性化，例如：\n\nurl url = new url("https://doc.hutool.cn/assets/js/www.hutool.cn")\n\n\n此时会报java.net.malformedurlexception: no protocol的错误，而使用urlbuilder则会有默认协议：\n\n// 输出 http://www.hutool.cn/\nstring buildurl = urlbuilder.create().sethost("https://doc.hutool.cn/assets/js/www.hutool.cn").build();\n\n\n\n# 完整构建\n\n// https://www.hutool.cn/aaa/bbb?ie=utf-8&wd=test\nstring buildurl = urlbuilder.create()\n\t.setscheme("https")\n\t.sethost("https://doc.hutool.cn/assets/js/www.hutool.cn")\n\t.addpath("/aaa").addpath("bbb")\n\t.addquery("ie", "utf-8")\n\t.addquery("wd", "test")\n\t.build();\n\n\n\n# 中文编码\n\n当参数中有中文时，自动编码中文，默认utf-8编码，也可以调用setcharset方法自定义编码。\n\n// https://www.hutool.cn/s?ie=utf-8&ie=gbk&wd=%e6%b5%8b%e8%af%95\nstring buildurl = urlbuilder.create()\n\t.setscheme("https")\n\t.sethost("https://doc.hutool.cn/assets/js/www.hutool.cn")\n\t.addpath("/s")\n\t.addquery("ie", "utf-8")\n\t.addquery("ie", "gbk")\n\t.addquery("wd", "测试")\n\t.build();\n\n\n\n# 解析\n\n当有一个url字符串时，可以使用of方法解析：\n\nurlbuilder builder = urlbuilder.ofhttp("www.hutool.cn/aaa/bbb/?a=张三&b=%e6%9d%8e%e5%9b%9b#frag1", charsetutil.charset_utf_8);\n\n// 输出张三\nconsole.log(builder.getquery().get("a"));\n// 输出李四\nconsole.log(builder.getquery().get("b"));\n\n\n我们发现这个例子中，原url中的参数a是没有编码的，b是编码过的，当用户提供此类混合url时，hutool可以很好的识别并全部decode，当然，调用build()之后，会全部再encode。\n\n\n# 特殊url解析\n\n有时候url中会存在&amp;这种分隔符，谷歌浏览器会将此字符串转换为&使用，hutool中也同样如此：\n\nstring urlstr = "https://mp.weixin.qq.com/s?__biz=mzi5njkyntixmg==&amp;mid=100000465&amp;idx=1";\nurlbuilder builder = urlbuilder.ofhttp(urlstr, charsetutil.charset_utf_8);\n\n// https://mp.weixin.qq.com/s?__biz=mzi5njkyntixmg==&mid=100000465&idx=1\nconsole.log(builder.build());\n\n\n> urlbuilder主要应用于http模块，在构建httprequest时，用户传入的url五花八门，为了做到最好的适应性，减少用户对url的处理，使用urlbuilder完成url的规范化。',charsets:{cjk:!0},lastUpdated:"2023/10/23, 14:33:13",lastUpdatedTimestamp:1698042793e3},{title:"源码编译工具-CompilerUtil",frontmatter:{title:"源码编译工具-CompilerUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CompilerUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/19.%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/01.%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7-CompilerUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/19.源码编译/01.源码编译工具-CompilerUtil.md",key:"v-5f2251f2",path:"/pages/CompilerUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:94}],headersStr:"介绍 使用",content:'# 介绍\n\nJDK提供了JavaCompiler用于动态编译java源码文件，然后通过类加载器加载，这种动态编译可以让Java有动态脚本的特性，Hutool针对此封装了对应工具。\n\n\n# 使用\n\n首先我们将编译需要依赖的class文件和jar文件打成一个包：\n\n// 依赖A，编译B和C\nfinal File libFile = ZipUtil.zip(FileUtil.file("https://doc.hutool.cn/assets/js/lib.jar"),\n\t\tnew String[]{"a/A.class", "a/A$1.class", "a/A$InnerClass.class"},\n\t\tnew InputStream[]{\n\t\t\t\tFileUtil.getInputStream("test-compile/a/A.class"),\n\t\t\t\tFileUtil.getInputStream("test-compile/a/A$1.class"),\n\t\t\t\tFileUtil.getInputStream("test-compile/a/A$InnerClass.class")\n\t\t});\n\n\n开始编译：\n\nfinal ClassLoader classLoader = CompilerUtil.getCompiler(null)\n\t// 被编译的源码文件\n\t.addSource(FileUtil.file("https://doc.hutool.cn/assets/js/test-compile/b/B.java"))\n\t// 被编译的源码字符串\n\t.addSource("c.C", FileUtil.readUtf8String("https://doc.hutool.cn/assets/js/test-compile/c/C.java"))\n\t// 编译依赖的库\n\t.addLibrary(libFile)\n\t.compile();\n\n\n加载编译好的类：\n\nfinal Class<?> clazz = classLoader.loadClass("c.C");\n// 实例化对象c\nObject obj = ReflectUtil.newInstance(clazz);\n',normalizedContent:'# 介绍\n\njdk提供了javacompiler用于动态编译java源码文件，然后通过类加载器加载，这种动态编译可以让java有动态脚本的特性，hutool针对此封装了对应工具。\n\n\n# 使用\n\n首先我们将编译需要依赖的class文件和jar文件打成一个包：\n\n// 依赖a，编译b和c\nfinal file libfile = ziputil.zip(fileutil.file("https://doc.hutool.cn/assets/js/lib.jar"),\n\t\tnew string[]{"a/a.class", "a/a$1.class", "a/a$innerclass.class"},\n\t\tnew inputstream[]{\n\t\t\t\tfileutil.getinputstream("test-compile/a/a.class"),\n\t\t\t\tfileutil.getinputstream("test-compile/a/a$1.class"),\n\t\t\t\tfileutil.getinputstream("test-compile/a/a$innerclass.class")\n\t\t});\n\n\n开始编译：\n\nfinal classloader classloader = compilerutil.getcompiler(null)\n\t// 被编译的源码文件\n\t.addsource(fileutil.file("https://doc.hutool.cn/assets/js/test-compile/b/b.java"))\n\t// 被编译的源码字符串\n\t.addsource("c.c", fileutil.readutf8string("https://doc.hutool.cn/assets/js/test-compile/c/c.java"))\n\t// 编译依赖的库\n\t.addlibrary(libfile)\n\t.compile();\n\n\n加载编译好的类：\n\nfinal class<?> clazz = classloader.loadclass("c.c");\n// 实例化对象c\nobject obj = reflectutil.newinstance(clazz);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/setting/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/03.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6(Hutool-setting%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/03.配置文件(Hutool-setting）/01.概述.md",key:"v-01a9c769",path:"/pages/setting/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:3,title:"Setting",slug:"setting",normalizedTitle:"setting",charIndex:9},{level:3,title:"Props",slug:"props",normalizedTitle:"props",charIndex:254}],headersStr:"由来 Setting Props",content:'# 由来\n\n\n# Setting\n\n众所周知，Java中广泛应用的配置文件Properties存在一个特别大的诟病：不支持中文。每次使用时，如果想存放中文字符，必须借助IDE相关插件才能转为Unicode符号，而这种反人类的符号在命令行下根本没法看（想想部署在服务器上后修改配置文件是一件多么痛苦的事情）\n\n于是，在很多框架中开始渐渐抛弃Properties文件而转向XML配置文件（例如Hibernate和Spring早期版本）。但是XML罗嗦的配置方式实在无法忍受。于是，Setting诞生了。\n\n\n# Props\n\nProperties的第二个问题是读取非常不方便，需要我们自己写长长的代码进行load操作：\n\nproperties = new Properties();\ntry {\n\tClass clazz = Demo1.class;\n\tInputStream inputestream = clazz.getResourceAsStream("db.properties");\n\tproperties.load( inputestream);\n}catch (IOException e) {\n\t//ignore\n}\n\n\n而Props则大大简化为：\n\nProps props = new Props("db.properties");\n\n\n考虑到Properties使用依旧广泛，因此封装了Props类以应对兼容性。',normalizedContent:'# 由来\n\n\n# setting\n\n众所周知，java中广泛应用的配置文件properties存在一个特别大的诟病：不支持中文。每次使用时，如果想存放中文字符，必须借助ide相关插件才能转为unicode符号，而这种反人类的符号在命令行下根本没法看（想想部署在服务器上后修改配置文件是一件多么痛苦的事情）\n\n于是，在很多框架中开始渐渐抛弃properties文件而转向xml配置文件（例如hibernate和spring早期版本）。但是xml罗嗦的配置方式实在无法忍受。于是，setting诞生了。\n\n\n# props\n\nproperties的第二个问题是读取非常不方便，需要我们自己写长长的代码进行load操作：\n\nproperties = new properties();\ntry {\n\tclass clazz = demo1.class;\n\tinputstream inputestream = clazz.getresourceasstream("db.properties");\n\tproperties.load( inputestream);\n}catch (ioexception e) {\n\t//ignore\n}\n\n\n而props则大大简化为：\n\nprops props = new props("db.properties");\n\n\n考虑到properties使用依旧广泛，因此封装了props类以应对兼容性。',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"Properties扩展-Props",frontmatter:{title:"Properties扩展-Props",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Props/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/03.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6(Hutool-setting%EF%BC%89/02.Properties%E6%89%A9%E5%B1%95-Props.html",relativePath:"01.指南/03.配置文件(Hutool-setting）/02.Properties扩展-Props.md",key:"v-2e6b19f9",path:"/pages/Props/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:21}],headersStr:"介绍 使用",content:'# 介绍\n\n对于Properties的广泛使用使我也无能为力，有时候遇到Properties文件又想方便的读写也不容易，于是对Properties做了简单的封装，提供了方便的构造方法（与Setting一致），并提供了与Setting一致的getXXX方法来扩展Properties类，Props类继承自Properties，所以可以兼容Properties类。\n\n\n# 使用\n\nProps的使用方法和Properties以及Setting一致（同时支持）：\n\nProps props = new Props("test.properties");\nString user = props.getProperty("user");\nString driver = props.getStr("driver");\n',normalizedContent:'# 介绍\n\n对于properties的广泛使用使我也无能为力，有时候遇到properties文件又想方便的读写也不容易，于是对properties做了简单的封装，提供了方便的构造方法（与setting一致），并提供了与setting一致的getxxx方法来扩展properties类，props类继承自properties，所以可以兼容properties类。\n\n\n# 使用\n\nprops的使用方法和properties以及setting一致（同时支持）：\n\nprops props = new props("test.properties");\nstring user = props.getproperty("user");\nstring driver = props.getstr("driver");\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/log/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/04.%E6%97%A5%E5%BF%97%EF%BC%88Hutool-log%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/04.日志（Hutool-log）/01.概述.md",key:"v-2bc4bcf4",path:"/pages/log/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"已有门面存在问题",slug:"已有门面存在问题",normalizedTitle:"已有门面存在问题",charIndex:99},{level:2,title:"特点",slug:"特点",normalizedTitle:"特点",charIndex:406},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:579},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:370},{level:3,title:"常规使用",slug:"常规使用",normalizedTitle:"常规使用",charIndex:967},{level:3,title:"自定义日志实现",slug:"自定义日志实现",normalizedTitle:"自定义日志实现",charIndex:1356}],headersStr:"由来 已有门面存在问题 特点 原理 使用 常规使用 自定义日志实现",content:'# 由来\n\n准确的说，Hutool-log只是一个日志的通用门面，功能类似于Slf4j。既然像Slf4j这种门面框架已经非常完善，为何还要自己做一个门面呢？下面我列举实践中遇到的一些问题：\n\n\n# 已有门面存在问题\n\n 1. log对象创建比较复杂\n\n很多时候我们为了在类中加日志不得不写一行，而且还要去手动改XXX这个类名\n\nprivate static final Logger log = LoggerFactory.getLogger(XXX.class);\n\n\n 2. 对于附带Exception参数的方法，并不支持变量。\n\nSlf4j中我最喜欢的形式，这样既省去了麻烦的isInfoEnabled()的判断，还避免了拼接字符串：\n\nlog.info("我在XXX 改了 {} 变量", "name");\n\n\n但是这种情况下就无法使用变量模式：\n\nlog.error("错误消息", e);\n\n\n\n# 特点\n\n 1. Logfactory.get方法不再需要（或者不是必须）传入当前类名，会自动解析当前类名\n 2. log.xxx方法在传入Exception时同时支持模板语法。\n 3. 不需要桥接包而自动适配引入的日志框架，在无日志框架下依旧可以完美适配JDK Logging。\n 4. 引入多个日志框架情况下，可以自定义日志框架输出。\n\n\n# 原理\n\nHutool-log采用动态自动适配模式，它会自动检测引入的日志框架包从而将日志输出到此框架。 比如我们在项目中引入Log4j的包，Hutool-log会自动检测到此包的存在，并将日志输出到log4j。如果没有引入任何日志框架，会将日志输出到JDK Logging中。\n\n因此，Hutool-log并没有统一的配置文件，如果你引入任何一种日志框架，使用此框架的配置文件即可。\n\nHutool-log对于日志框架的监测顺序是： Slf4j(Logback) > Log4j > Log4j2 > Apache Commons Logging > JDK Logging > Console\n\n当然，如果只是引入Slf4j-API，而没有引入任何实现，Slf4j将被跳过。\n\n> 关于日志框架监测的核心代码请参阅：LogFactory.create\n\n\n# 使用\n\n\n# 常规使用\n\nHutool-log的使用与一般日志框架并无区别，调用LogFactory.get()即可简单获取Log实现对象。\n\nLog log = LogFactory.get();\n\nlog.debug("This is {} log", Level.DEBUG);\nlog.info("This is {} log", Level.INFO);\nlog.warn("This is {} log", Level.WARN);\n\nException e = new Exception("test Exception");\nlog.error(e, "This is {} log", Level.ERROR);\n\n\n> 通常我们需要在类中定义日志为private static final Log log = LogFactory.get();以获得更好的性能。\n\n\n# 自定义日志实现\n\n有的时候，我们需要自定义日志框架输出，这是我们就需要调用LogFactory.setCurrentLogFactory方法来定义全局的日志实现。\n\n// 自动选择日志实现\nLog log = LogFactory.get();\nlog.debug("This is {} log", "default");\nConsole.log("----------------------------------------------------------------------");\n\n//自定义日志实现为Apache Commons Logging\nLogFactory.setCurrentLogFactory(new ApacheCommonsLogFactory());\nlog.debug("This is {} log", "custom apache commons logging");\nConsole.log("----------------------------------------------------------------------");\n\n//自定义日志实现为JDK Logging\nLogFactory.setCurrentLogFactory(new JdkLogFactory());\nlog.info("This is {} log", "custom jdk logging");\nConsole.log("----------------------------------------------------------------------");\n\n//自定义日志实现为Console Logging\nLogFactory.setCurrentLogFactory(new ConsoleLogFactory());\nlog.info("This is {} log", "custom Console");\nConsole.log("----------------------------------------------------------------------");\n\n\n> 默认的，在未发现任何第三方日志的情况下，检查logging.properties文件是否在classpath中存在（鉴定用户是否想用JDK Logging），如果没有这个配置文件，默认是按照Hutool预定义规则打印到控制台。',normalizedContent:'# 由来\n\n准确的说，hutool-log只是一个日志的通用门面，功能类似于slf4j。既然像slf4j这种门面框架已经非常完善，为何还要自己做一个门面呢？下面我列举实践中遇到的一些问题：\n\n\n# 已有门面存在问题\n\n 1. log对象创建比较复杂\n\n很多时候我们为了在类中加日志不得不写一行，而且还要去手动改xxx这个类名\n\nprivate static final logger log = loggerfactory.getlogger(xxx.class);\n\n\n 2. 对于附带exception参数的方法，并不支持变量。\n\nslf4j中我最喜欢的形式，这样既省去了麻烦的isinfoenabled()的判断，还避免了拼接字符串：\n\nlog.info("我在xxx 改了 {} 变量", "name");\n\n\n但是这种情况下就无法使用变量模式：\n\nlog.error("错误消息", e);\n\n\n\n# 特点\n\n 1. logfactory.get方法不再需要（或者不是必须）传入当前类名，会自动解析当前类名\n 2. log.xxx方法在传入exception时同时支持模板语法。\n 3. 不需要桥接包而自动适配引入的日志框架，在无日志框架下依旧可以完美适配jdk logging。\n 4. 引入多个日志框架情况下，可以自定义日志框架输出。\n\n\n# 原理\n\nhutool-log采用动态自动适配模式，它会自动检测引入的日志框架包从而将日志输出到此框架。 比如我们在项目中引入log4j的包，hutool-log会自动检测到此包的存在，并将日志输出到log4j。如果没有引入任何日志框架，会将日志输出到jdk logging中。\n\n因此，hutool-log并没有统一的配置文件，如果你引入任何一种日志框架，使用此框架的配置文件即可。\n\nhutool-log对于日志框架的监测顺序是： slf4j(logback) > log4j > log4j2 > apache commons logging > jdk logging > console\n\n当然，如果只是引入slf4j-api，而没有引入任何实现，slf4j将被跳过。\n\n> 关于日志框架监测的核心代码请参阅：logfactory.create\n\n\n# 使用\n\n\n# 常规使用\n\nhutool-log的使用与一般日志框架并无区别，调用logfactory.get()即可简单获取log实现对象。\n\nlog log = logfactory.get();\n\nlog.debug("this is {} log", level.debug);\nlog.info("this is {} log", level.info);\nlog.warn("this is {} log", level.warn);\n\nexception e = new exception("test exception");\nlog.error(e, "this is {} log", level.error);\n\n\n> 通常我们需要在类中定义日志为private static final log log = logfactory.get();以获得更好的性能。\n\n\n# 自定义日志实现\n\n有的时候，我们需要自定义日志框架输出，这是我们就需要调用logfactory.setcurrentlogfactory方法来定义全局的日志实现。\n\n// 自动选择日志实现\nlog log = logfactory.get();\nlog.debug("this is {} log", "default");\nconsole.log("----------------------------------------------------------------------");\n\n//自定义日志实现为apache commons logging\nlogfactory.setcurrentlogfactory(new apachecommonslogfactory());\nlog.debug("this is {} log", "custom apache commons logging");\nconsole.log("----------------------------------------------------------------------");\n\n//自定义日志实现为jdk logging\nlogfactory.setcurrentlogfactory(new jdklogfactory());\nlog.info("this is {} log", "custom jdk logging");\nconsole.log("----------------------------------------------------------------------");\n\n//自定义日志实现为console logging\nlogfactory.setcurrentlogfactory(new consolelogfactory());\nlog.info("this is {} log", "custom console");\nconsole.log("----------------------------------------------------------------------");\n\n\n> 默认的，在未发现任何第三方日志的情况下，检查logging.properties文件是否在classpath中存在（鉴定用户是否想用jdk logging），如果没有这个配置文件，默认是按照hutool预定义规则打印到控制台。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"设置文件-Setting",frontmatter:{title:"设置文件-Setting",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/setting/example/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/03.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6(Hutool-setting%EF%BC%89/03.%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6-Setting.html",relativePath:"01.指南/03.配置文件(Hutool-setting）/03.设置文件-Setting.md",key:"v-05ca86ef",path:"/pages/setting/example/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"配置文件格式example.setting",slug:"配置文件格式example-setting",normalizedTitle:"配置文件格式example.setting",charIndex:428},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:1291}],headersStr:"简介 配置文件格式example.setting 代码",content:'# 简介\n\nSetting除了兼容Properties文件格式外，还提供了一些特有功能，这些功能包括：\n\n * 各种编码方式支持\n * 变量支持\n * 分组支持\n\n首先说编码支持，在Properties中，只支持ISO8859-1，导致在Properties文件中注释和value没法使用中文，（用日本的那个插件在Eclipse里可以读写，放到服务器上读就费劲了），因此Setting中引入自定义编码，可以很好的支持各种编码的配置文件。\n\n再就是变量支持，在Setting中，支持${key}变量，可以将之前定义的键对应的值做为本条值的一部分，这个特性可以减少大量的配置文件冗余。\n\n最后是分组支持。分组的概念我第一次在Linux的rsync的/etc/rsyncd.conf配置文件中有所了解，发现特别实用，具体大家可以自行百度之。当然，在Windows的ini文件中也有分组的概念，Setting将这一概念引入，从而大大增加配置文件的可读性。\n\n\n# 配置文件格式example.setting\n\n#中括表示一个分组，其下面的所有属性归属于这个分组，在此分组名为demo，也可以没有分组\n[demo]\n#自定义数据源设置文件，这个文件会针对当前分组生效，用于给当前分组配置单独的数据库连接池参数，没有则使用全局的配置\nds.setting.path = config/other.setting\n#数据库驱动名，如果不指定，则会根据url自动判定\ndriver = com.mysql.jdbc.Driver\n#JDBC url，必须\nurl = jdbc:mysql://fedora.vmware:3306/extractor\n#用户名，必须\nuser = root${demo.driver}\n#密码，必须，如果密码为空，请填写 pass = \npass = 123456\n\n\n配置文件可以放在任意位置，在构造方法中提供了多种读取方式，具体Setting类如何寻找，稍后介绍。现在说下配置文件的具体格式。\n\nSetting配置文件类似于Properties文件，规则如下：\n\n 1. 注释用#开头表示，只支持单行注释，空行和无法正常被识别的键值对也会被忽略，可作为注释，但是建议显式指定注释。同时在value之后不允许有注释，会被当作value的一部分。\n 2. 键值对使用key = value 表示，key和value在读取时会trim掉空格，所以不用担心空格。\n 3. 分组为中括号括起来的内容（例如配置文件中的[demo]），中括号以下的行都为此分组的内容，无分组相当于空字符分组，即[]。若某个key是name，分组是group，加上分组后的key相当于group.name。\n 4. 支持变量，默认变量命名为 ${变量名}，变量只能识别读入行的变量，例如第6行的变量在第三行无法读取，例如配置文件中的${driver}会被替换为com.mysql.jdbc.Driver，为了性能，Setting创建的时候构造方法会指定是否开启变量替换，默认不开启。\n\n\n# 代码\n\n代码具体请见cn.hutool.setting.test.SettingTest\n\n 1. Setting初始化\n\n//读取classpath下的XXX.setting，不使用变量\nSetting setting = new Setting("XXX.setting");\n\n//读取classpath下的config目录下的XXX.setting，不使用变量\nsetting = new Setting("config/XXX.setting");\n\n//读取绝对路径文件/home/looly/XXX.setting（没有就创建，关于touch请查阅FileUtil）\n//第二个参数为自定义的编码，请保持与Setting文件的编码一致\n//第三个参数为是否使用变量，如果为true，则配置文件中的每个key都可以被之后的条目中的value引用，形式为 ${key}\nsetting = new Setting(FileUtil.touch("/home/looly/XXX.setting"), CharsetUtil.CHARSET_UTF_8, true);\n\n//读取与SettingDemo.class文件同包下的XXX.setting\nsetting = new Setting("XXX.setting", SettingDemo.class,CharsetUtil.CHARSET_UTF_8, true);\n\n\n 2. Setting读取配置参数\n\n//获取key为name的值\nsetting.getStr("name");\n//获取分组为group下key为name的值\nsetting.getByGroup("name", "group1");\n//当获取的值为空（null或者空白字符时，包括多个空格），返回默认值\nsetting.getStr("name", "默认值");\n//完整的带有key、分组和默认值的获得值得方法\nsetting.getStr("name", "group1", "默认值");\n\n//如果想获得其它类型的值，可以调用相应的getXXX方法，参数相似\n\n//有时候需要在key对应value不存在的时候（没有这项设置的时候）告知户，故有此方法打印一个debug日志\nsetting.getWithLog("name");\nsetting.getByGroupWithLog("name", "group1");\n\n//获取分组下所有配置键值对，组成新的Setting\nsetting.getSetting("group1")\n\n\n 3. 重新加载配置和保存配置\n\n//重新读取配置文件\nsetting.reload();\n\n//在配置文件变更时自动加载\nsetting.autoLoad(true);\n\n//当通过代码加入新的键值对的时候，调用store会保存到文件，但是会覆盖原来的文件，并丢失注释\nsetting.set("name1", "value");\nsetting.store("/home/looly/XXX.setting");\n//获得所有分组名\nsetting.getGroups();\n\n//将key-value映射为对象，原理是调用对象对应的setXX方法\nUserVO userVo = new UserVo();\nsetting.toBean(userVo);\n\n//设定变量名的正则表达式。\n//Setting的变量替换是通过正则查找替换的，如果Setting中的变量名格式与其他冲突，可以改变变量名的定义方式\n//整个正则匹配变量名，分组1匹配key的名字，变量名格式变为`$${key}`\nsetting.setVarRegex("\\$\\\\$\\\\{(.*?)\\\\}");\n',normalizedContent:'# 简介\n\nsetting除了兼容properties文件格式外，还提供了一些特有功能，这些功能包括：\n\n * 各种编码方式支持\n * 变量支持\n * 分组支持\n\n首先说编码支持，在properties中，只支持iso8859-1，导致在properties文件中注释和value没法使用中文，（用日本的那个插件在eclipse里可以读写，放到服务器上读就费劲了），因此setting中引入自定义编码，可以很好的支持各种编码的配置文件。\n\n再就是变量支持，在setting中，支持${key}变量，可以将之前定义的键对应的值做为本条值的一部分，这个特性可以减少大量的配置文件冗余。\n\n最后是分组支持。分组的概念我第一次在linux的rsync的/etc/rsyncd.conf配置文件中有所了解，发现特别实用，具体大家可以自行百度之。当然，在windows的ini文件中也有分组的概念，setting将这一概念引入，从而大大增加配置文件的可读性。\n\n\n# 配置文件格式example.setting\n\n#中括表示一个分组，其下面的所有属性归属于这个分组，在此分组名为demo，也可以没有分组\n[demo]\n#自定义数据源设置文件，这个文件会针对当前分组生效，用于给当前分组配置单独的数据库连接池参数，没有则使用全局的配置\nds.setting.path = config/other.setting\n#数据库驱动名，如果不指定，则会根据url自动判定\ndriver = com.mysql.jdbc.driver\n#jdbc url，必须\nurl = jdbc:mysql://fedora.vmware:3306/extractor\n#用户名，必须\nuser = root${demo.driver}\n#密码，必须，如果密码为空，请填写 pass = \npass = 123456\n\n\n配置文件可以放在任意位置，在构造方法中提供了多种读取方式，具体setting类如何寻找，稍后介绍。现在说下配置文件的具体格式。\n\nsetting配置文件类似于properties文件，规则如下：\n\n 1. 注释用#开头表示，只支持单行注释，空行和无法正常被识别的键值对也会被忽略，可作为注释，但是建议显式指定注释。同时在value之后不允许有注释，会被当作value的一部分。\n 2. 键值对使用key = value 表示，key和value在读取时会trim掉空格，所以不用担心空格。\n 3. 分组为中括号括起来的内容（例如配置文件中的[demo]），中括号以下的行都为此分组的内容，无分组相当于空字符分组，即[]。若某个key是name，分组是group，加上分组后的key相当于group.name。\n 4. 支持变量，默认变量命名为 ${变量名}，变量只能识别读入行的变量，例如第6行的变量在第三行无法读取，例如配置文件中的${driver}会被替换为com.mysql.jdbc.driver，为了性能，setting创建的时候构造方法会指定是否开启变量替换，默认不开启。\n\n\n# 代码\n\n代码具体请见cn.hutool.setting.test.settingtest\n\n 1. setting初始化\n\n//读取classpath下的xxx.setting，不使用变量\nsetting setting = new setting("xxx.setting");\n\n//读取classpath下的config目录下的xxx.setting，不使用变量\nsetting = new setting("config/xxx.setting");\n\n//读取绝对路径文件/home/looly/xxx.setting（没有就创建，关于touch请查阅fileutil）\n//第二个参数为自定义的编码，请保持与setting文件的编码一致\n//第三个参数为是否使用变量，如果为true，则配置文件中的每个key都可以被之后的条目中的value引用，形式为 ${key}\nsetting = new setting(fileutil.touch("/home/looly/xxx.setting"), charsetutil.charset_utf_8, true);\n\n//读取与settingdemo.class文件同包下的xxx.setting\nsetting = new setting("xxx.setting", settingdemo.class,charsetutil.charset_utf_8, true);\n\n\n 2. setting读取配置参数\n\n//获取key为name的值\nsetting.getstr("name");\n//获取分组为group下key为name的值\nsetting.getbygroup("name", "group1");\n//当获取的值为空（null或者空白字符时，包括多个空格），返回默认值\nsetting.getstr("name", "默认值");\n//完整的带有key、分组和默认值的获得值得方法\nsetting.getstr("name", "group1", "默认值");\n\n//如果想获得其它类型的值，可以调用相应的getxxx方法，参数相似\n\n//有时候需要在key对应value不存在的时候（没有这项设置的时候）告知户，故有此方法打印一个debug日志\nsetting.getwithlog("name");\nsetting.getbygroupwithlog("name", "group1");\n\n//获取分组下所有配置键值对，组成新的setting\nsetting.getsetting("group1")\n\n\n 3. 重新加载配置和保存配置\n\n//重新读取配置文件\nsetting.reload();\n\n//在配置文件变更时自动加载\nsetting.autoload(true);\n\n//当通过代码加入新的键值对的时候，调用store会保存到文件，但是会覆盖原来的文件，并丢失注释\nsetting.set("name1", "value");\nsetting.store("/home/looly/xxx.setting");\n//获得所有分组名\nsetting.getgroups();\n\n//将key-value映射为对象，原理是调用对象对应的setxx方法\nuservo uservo = new uservo();\nsetting.tobean(uservo);\n\n//设定变量名的正则表达式。\n//setting的变量替换是通过正则查找替换的，如果setting中的变量名格式与其他冲突，可以改变变量名的定义方式\n//整个正则匹配变量名，分组1匹配key的名字，变量名格式变为`$${key}`\nsetting.setvarregex("\\$\\\\$\\\\{(.*?)\\\\}");\n',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"疑惑解答",frontmatter:{title:"疑惑解答",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/log/faq/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/04.%E6%97%A5%E5%BF%97%EF%BC%88Hutool-log%EF%BC%89/03.%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94.html",relativePath:"01.指南/04.日志（Hutool-log）/03.疑惑解答.md",key:"v-59d3a274",path:"/pages/log/faq/",headers:[{level:3,title:"问：",slug:"问",normalizedTitle:"问：",charIndex:11},{level:3,title:"答：",slug:"答",normalizedTitle:"答：",charIndex:134}],headersStr:"问： 答：",content:"# 疑惑解答\n\n\n# 问：\n\n程序中出现[WARN] Can not find [logging.properties], use [%JRE_HOME%/lib/logging.properties] as default!这行警告，请问这个问题如何解决？\n\n\n# 答：\n\n这是因为你没有引入任何第三方日志框架。Hutool默认会使用JDK Logging做为其日志实现。出现这句话的意思是你没有在你的ClassPath下放logging.properties（JDK Logging的配置文件），系统默认读取JDK目录下的默认配置文件。你可以考虑在ClassPath下放一个logging.properties（就是src/main/resources）下。\n\n配置文件模板见：https://gitee.com/dromara/hutool/blob/v5-master/hutool-log/src/test/resources/logging.properties\n\n其它日志框架的配置文件模板见：https://gitee.com/dromara/hutool/tree/v5-master/hutool-log/src/test/resources\n\n> 注意 在新版的Hutool中会自动检测logging.properties存在与否，如果不存在这个配置文件，将跳过JDK-Logging从而使用Console-log（命令行打印日志）\n\n----------------------------------------",normalizedContent:"# 疑惑解答\n\n\n# 问：\n\n程序中出现[warn] can not find [logging.properties], use [%jre_home%/lib/logging.properties] as default!这行警告，请问这个问题如何解决？\n\n\n# 答：\n\n这是因为你没有引入任何第三方日志框架。hutool默认会使用jdk logging做为其日志实现。出现这句话的意思是你没有在你的classpath下放logging.properties（jdk logging的配置文件），系统默认读取jdk目录下的默认配置文件。你可以考虑在classpath下放一个logging.properties（就是src/main/resources）下。\n\n配置文件模板见：https://gitee.com/dromara/hutool/blob/v5-master/hutool-log/src/test/resources/logging.properties\n\n其它日志框架的配置文件模板见：https://gitee.com/dromara/hutool/tree/v5-master/hutool-log/src/test/resources\n\n> 注意 在新版的hutool中会自动检测logging.properties存在与否，如果不存在这个配置文件，将跳过jdk-logging从而使用console-log（命令行打印日志）\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"图片工具-ImgUtil",frontmatter:{title:"图片工具-ImgUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ImgUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89/17.%E5%9B%BE%E7%89%87/01.%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil.html",relativePath:"01.指南/02.核心（Hutool-core）/17.图片/01.图片工具-ImgUtil.md",key:"v-9e552d54",path:"/pages/ImgUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法介绍",slug:"方法介绍",normalizedTitle:"方法介绍",charIndex:51},{level:3,title:"scale 缩放图片",slug:"scale-缩放图片",normalizedTitle:"scale 缩放图片",charIndex:60},{level:3,title:"cut 剪裁图片",slug:"cut-剪裁图片",normalizedTitle:"cut 剪裁图片",charIndex:221},{level:3,title:"slice 按照行列剪裁切片（将图片分为10行和10列）",slug:"slice-按照行列剪裁切片-将图片分为10行和10列",normalizedTitle:"slice 按照行列剪裁切片（将图片分为10行和10列）",charIndex:376},{level:3,title:"convert 图片类型转换，支持GIF->JPG、GIF->PNG、PNG->JPG、PNG->GIF(X)、BMP->PNG等",slug:"convert-图片类型转换-支持gif-jpg、gif-png、png-jpg、png-gif-x-、bmp-png等",normalizedTitle:"convert 图片类型转换，支持gif-&gt;jpg、gif-&gt;png、png-&gt;jpg、png-&gt;gif(x)、bmp-&gt;png等",charIndex:null},{level:3,title:"gray 彩色转为黑白",slug:"gray-彩色转为黑白",normalizedTitle:"gray 彩色转为黑白",charIndex:650},{level:3,title:"pressText 添加文字水印",slug:"presstext-添加文字水印",normalizedTitle:"presstext 添加文字水印",charIndex:744},{level:3,title:"pressImage 添加图片水印",slug:"pressimage-添加图片水印",normalizedTitle:"pressimage 添加图片水印",charIndex:1074},{level:3,title:"rotate 旋转图片",slug:"rotate-旋转图片",normalizedTitle:"rotate 旋转图片",charIndex:1347},{level:3,title:"flip 水平翻转图片",slug:"flip-水平翻转图片",normalizedTitle:"flip 水平翻转图片",charIndex:1526}],headersStr:"介绍 方法介绍 scale 缩放图片 cut 剪裁图片 slice 按照行列剪裁切片（将图片分为10行和10列） convert 图片类型转换，支持GIF->JPG、GIF->PNG、PNG->JPG、PNG->GIF(X)、BMP->PNG等 gray 彩色转为黑白 pressText 添加文字水印 pressImage 添加图片水印 rotate 旋转图片 flip 水平翻转图片",content:'# 介绍\n\n针对awt中图片处理进行封装，这些封装包括：缩放、裁剪、转为黑白、加水印等操作。\n\n\n# 方法介绍\n\n\n# scale 缩放图片\n\n提供两种重载方法：其中一个是按照长宽缩放，另一种是按照比例缩放。\n\nImgUtil.scale(\n    FileUtil.file("d:/face.jpg"), \n    FileUtil.file("d:/face_result.jpg"), \n    0.5f//缩放比例\n);\n\n\n\n# cut 剪裁图片\n\nImgUtil.cut(\n    FileUtil.file("d:/face.jpg"), \n    FileUtil.file("d:/face_result.jpg"), \n    new Rectangle(200, 200, 100, 100)//裁剪的矩形区域\n);\n\n\n\n# slice 按照行列剪裁切片（将图片分为10行和10列）\n\nImgUtil.slice(FileUtil.file("e:/test2.png"), FileUtil.file("e:/dest/"), 10, 10);\n\n\n\n# convert 图片类型转换，支持GIF->JPG、GIF->PNG、PNG->JPG、PNG->GIF(X)、BMP->PNG等\n\nImgUtil.convert(FileUtil.file("e:/test2.png"), FileUtil.file("e:/test2Convert.jpg"));\n\n\n\n# gray 彩色转为黑白\n\nImgUtil.gray(FileUtil.file("d:/logo.png"), FileUtil.file("d:/result.png"));\n\n\n\n# pressText 添加文字水印\n\nImgUtil.pressText(//\n    FileUtil.file("e:/pic/face.jpg"), //\n    FileUtil.file("e:/pic/test2_result.png"), //\n    "版权所有", Color.WHITE, //文字\n    new Font("黑体", Font.BOLD, 100), //字体\n    0, //x坐标修正值。 默认在中间，偏移量相对于中间偏移\n    0, //y坐标修正值。 默认在中间，偏移量相对于中间偏移\n    0.8f//透明度：alpha 必须是范围 [0.0, 1.0] 之内（包含边界值）的一个浮点数字\n);\n\n\n\n# pressImage 添加图片水印\n\nImgUtil.pressImage(\n    FileUtil.file("d:/picTest/1.jpg"), \n    FileUtil.file("d:/picTest/dest.jpg"), \n    ImgUtil.read(FileUtil.file("d:/picTest/1432613.jpg")), //水印图片\n    0, //x坐标修正值。 默认在中间，偏移量相对于中间偏移\n    0, //y坐标修正值。 默认在中间，偏移量相对于中间偏移\n    0.1f\n);\n\n\n\n# rotate 旋转图片\n\n// 旋转180度\nBufferedImage image = ImgUtil.rotate(ImageIO.read(FileUtil.file("e:/pic/366466.jpg")), 180);\nImgUtil.write(image, FileUtil.file("e:/pic/result.png"));\n\n\n\n# flip 水平翻转图片\n\nImgUtil.flip(FileUtil.file("d:/logo.png"), FileUtil.file("d:/result.png"));\n',normalizedContent:'# 介绍\n\n针对awt中图片处理进行封装，这些封装包括：缩放、裁剪、转为黑白、加水印等操作。\n\n\n# 方法介绍\n\n\n# scale 缩放图片\n\n提供两种重载方法：其中一个是按照长宽缩放，另一种是按照比例缩放。\n\nimgutil.scale(\n    fileutil.file("d:/face.jpg"), \n    fileutil.file("d:/face_result.jpg"), \n    0.5f//缩放比例\n);\n\n\n\n# cut 剪裁图片\n\nimgutil.cut(\n    fileutil.file("d:/face.jpg"), \n    fileutil.file("d:/face_result.jpg"), \n    new rectangle(200, 200, 100, 100)//裁剪的矩形区域\n);\n\n\n\n# slice 按照行列剪裁切片（将图片分为10行和10列）\n\nimgutil.slice(fileutil.file("e:/test2.png"), fileutil.file("e:/dest/"), 10, 10);\n\n\n\n# convert 图片类型转换，支持gif->jpg、gif->png、png->jpg、png->gif(x)、bmp->png等\n\nimgutil.convert(fileutil.file("e:/test2.png"), fileutil.file("e:/test2convert.jpg"));\n\n\n\n# gray 彩色转为黑白\n\nimgutil.gray(fileutil.file("d:/logo.png"), fileutil.file("d:/result.png"));\n\n\n\n# presstext 添加文字水印\n\nimgutil.presstext(//\n    fileutil.file("e:/pic/face.jpg"), //\n    fileutil.file("e:/pic/test2_result.png"), //\n    "版权所有", color.white, //文字\n    new font("黑体", font.bold, 100), //字体\n    0, //x坐标修正值。 默认在中间，偏移量相对于中间偏移\n    0, //y坐标修正值。 默认在中间，偏移量相对于中间偏移\n    0.8f//透明度：alpha 必须是范围 [0.0, 1.0] 之内（包含边界值）的一个浮点数字\n);\n\n\n\n# pressimage 添加图片水印\n\nimgutil.pressimage(\n    fileutil.file("d:/pictest/1.jpg"), \n    fileutil.file("d:/pictest/dest.jpg"), \n    imgutil.read(fileutil.file("d:/pictest/1432613.jpg")), //水印图片\n    0, //x坐标修正值。 默认在中间，偏移量相对于中间偏移\n    0, //y坐标修正值。 默认在中间，偏移量相对于中间偏移\n    0.1f\n);\n\n\n\n# rotate 旋转图片\n\n// 旋转180度\nbufferedimage image = imgutil.rotate(imageio.read(fileutil.file("e:/pic/366466.jpg")), 180);\nimgutil.write(image, fileutil.file("e:/pic/result.png"));\n\n\n\n# flip 水平翻转图片\n\nimgutil.flip(fileutil.file("d:/logo.png"), fileutil.file("d:/result.png"));\n',charsets:{cjk:!0},lastUpdated:"2023/10/23, 14:33:13",lastUpdatedTimestamp:1698042793e3},{title:"静态调用日志-StaticLog",frontmatter:{title:"静态调用日志-StaticLog",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/StaticLog/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/04.%E6%97%A5%E5%BF%97%EF%BC%88Hutool-log%EF%BC%89/04.%E9%9D%99%E6%80%81%E8%B0%83%E7%94%A8%E6%97%A5%E5%BF%97-StaticLog.html",relativePath:"01.指南/04.日志（Hutool-log）/04.静态调用日志-StaticLog.md",key:"v-359610e4",path:"/pages/StaticLog/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:23},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:40},{level:2,title:"与LogFactory同名方法",slug:"与logfactory同名方法",normalizedTitle:"与logfactory同名方法",charIndex:283}],headersStr:"由来 使用 与LogFactory同名方法",content:'# 静态调用日志-StaticLog\n\n\n# 由来\n\n很多时候，我们只是想简单的使用日志，最好一个方法搞定，我也不想创建Log对象，那么StaticLog或许是你需要的。\n\n\n# 使用\n\nStaticLog.info("This is static {} log.", "INFO");\n\n\n同样StaticLog提供了trace、debug、info、warn、error方法，提供变量占位符支持，使项目中日志的使用简单到没朋友。\n\nStaticLog类中同样提供log方法，可能在极致简洁的状况下，提供非常棒的灵活性（打印日志等级由level参数决定）\n\n\n# 与LogFactory同名方法\n\n假如你只知道StaticLog，不知道LogFactory怎么办？Hutool非常贴心的提供了get方法，此方法与Logfactory中的get方法一样，同样可以获得Log对象。',normalizedContent:'# 静态调用日志-staticlog\n\n\n# 由来\n\n很多时候，我们只是想简单的使用日志，最好一个方法搞定，我也不想创建log对象，那么staticlog或许是你需要的。\n\n\n# 使用\n\nstaticlog.info("this is static {} log.", "info");\n\n\n同样staticlog提供了trace、debug、info、warn、error方法，提供变量占位符支持，使项目中日志的使用简单到没朋友。\n\nstaticlog类中同样提供log方法，可能在极致简洁的状况下，提供非常棒的灵活性（打印日志等级由level参数决定）\n\n\n# 与logfactory同名方法\n\n假如你只知道staticlog，不知道logfactory怎么办？hutool非常贴心的提供了get方法，此方法与logfactory中的get方法一样，同样可以获得log对象。',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/cache/index/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/05.%E7%BC%93%E5%AD%98%EF%BC%88Hutool-cache%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/05.缓存（Hutool-cache）/01.概述.md",key:"v-014f3d3b",path:"/pages/cache/index/",headers:[{level:2,title:"来源",slug:"来源",normalizedTitle:"来源",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:100},{level:3,title:"FIFOCache",slug:"fifocache",normalizedTitle:"fifocache",charIndex:134},{level:3,title:"LFUCache",slug:"lfucache",normalizedTitle:"lfucache",charIndex:269},{level:3,title:"LRUCache",slug:"lrucache",normalizedTitle:"lrucache",charIndex:426},{level:3,title:"TimedCache",slug:"timedcache",normalizedTitle:"timedcache",charIndex:638},{level:3,title:"WeakCache",slug:"weakcache",normalizedTitle:"weakcache",charIndex:713},{level:3,title:"FileCach",slug:"filecach",normalizedTitle:"filecach",charIndex:889}],headersStr:"来源 介绍 FIFOCache LFUCache LRUCache TimedCache WeakCache FileCach",content:"# 来源\n\nHutool-cache模块最早受到jodd-cache的启发（如今大部分逻辑依旧与jodd保持一致），此模块提供一种缓存的简单实现方案，在小型项目中对于简单的缓存需求非常好用。\n\n\n# 介绍\n\nHutoo-cache模块提供了几种缓存策略实现：\n\n\n# FIFOCache\n\nFIFO(first in first out) 先进先出策略。元素不停的加入缓存直到缓存满为止，当缓存满时，清理过期缓存对象，清理后依旧满则删除先入的缓存（链表首部对象）。\n\n优点：简单快速\n缺点：不灵活，不能保证最常用的对象总是被保留\n\n\n# LFUCache\n\nLFU(least frequently used) 最少使用率策略。根据使用次数来判定对象是否被持续缓存（使用率是通过访问次数计算），当缓存满时清理过期对象，清理后依旧满的情况下清除最少访问（访问计数最小）的对象并将其他对象的访问数减去这个最小访问数，以便新对象进入后可以公平计数。\n\n\n# LRUCache\n\nLRU (least recently used)最近最久未使用缓存。根据使用时间来判定对象是否被持续缓存，当对象被访问时放入缓存，当缓存满了，最久未被使用的对象将被移除。此缓存基于LinkedHashMap，因此当被缓存的对象每被访问一次，这个对象的key就到链表头部。这个算法简单并且非常快，他比FIFO有一个显著优势是经常使用的对象不太可能被移除缓存。缺点是当缓存满时，不能被很快的访问。\n\n\n# TimedCache\n\n定时缓存，对被缓存的对象定义一个过期时间，当对象超过过期时间会被清理。此缓存没有容量限制，对象只有在过期后才会被移除\n\n\n# WeakCache\n\n弱引用缓存。对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除。该类使用了WeakHashMap做为其实现，缓存的清理依赖于JVM的垃圾回收。\n\n----------------------------------------\n\n\n# FileCach\n\nFileCach是一个独立的缓存，主要是将小文件以byte[]的形式缓存到内容中，减少文件的访问，以解决频繁读取文件引起的性能问题。\n\n主要实现有：\n\n * LFUFileCache\n * LRUFileCache",normalizedContent:"# 来源\n\nhutool-cache模块最早受到jodd-cache的启发（如今大部分逻辑依旧与jodd保持一致），此模块提供一种缓存的简单实现方案，在小型项目中对于简单的缓存需求非常好用。\n\n\n# 介绍\n\nhutoo-cache模块提供了几种缓存策略实现：\n\n\n# fifocache\n\nfifo(first in first out) 先进先出策略。元素不停的加入缓存直到缓存满为止，当缓存满时，清理过期缓存对象，清理后依旧满则删除先入的缓存（链表首部对象）。\n\n优点：简单快速\n缺点：不灵活，不能保证最常用的对象总是被保留\n\n\n# lfucache\n\nlfu(least frequently used) 最少使用率策略。根据使用次数来判定对象是否被持续缓存（使用率是通过访问次数计算），当缓存满时清理过期对象，清理后依旧满的情况下清除最少访问（访问计数最小）的对象并将其他对象的访问数减去这个最小访问数，以便新对象进入后可以公平计数。\n\n\n# lrucache\n\nlru (least recently used)最近最久未使用缓存。根据使用时间来判定对象是否被持续缓存，当对象被访问时放入缓存，当缓存满了，最久未被使用的对象将被移除。此缓存基于linkedhashmap，因此当被缓存的对象每被访问一次，这个对象的key就到链表头部。这个算法简单并且非常快，他比fifo有一个显著优势是经常使用的对象不太可能被移除缓存。缺点是当缓存满时，不能被很快的访问。\n\n\n# timedcache\n\n定时缓存，对被缓存的对象定义一个过期时间，当对象超过过期时间会被清理。此缓存没有容量限制，对象只有在过期后才会被移除\n\n\n# weakcache\n\n弱引用缓存。对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除。该类使用了weakhashmap做为其实现，缓存的清理依赖于jvm的垃圾回收。\n\n----------------------------------------\n\n\n# filecach\n\nfilecach是一个独立的缓存，主要是将小文件以byte[]的形式缓存到内容中，减少文件的访问，以解决频繁读取文件引起的性能问题。\n\n主要实现有：\n\n * lfufilecache\n * lrufilecache",charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"缓存工具-CacheUtil",frontmatter:{title:"缓存工具-CacheUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CacheUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/05.%E7%BC%93%E5%AD%98%EF%BC%88Hutool-cache%EF%BC%89/02.%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7-CacheUtil.html",relativePath:"01.指南/05.缓存（Hutool-cache）/02.缓存工具-CacheUtil.md",key:"v-7ad66091",path:"/pages/CacheUtil/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:46}],headersStr:"概述 使用",content:"# 概述\n\nCacheUtil是缓存创建的快捷工具类。用于快速创建不同的缓存对象。\n\n\n# 使用\n\n//新建FIFOCache\nCache<String,String> fifoCache = CacheUtil.newFIFOCache(3);\n\n\n同样其它类型的Cache也可以调用newXXX的方法创建。",normalizedContent:"# 概述\n\ncacheutil是缓存创建的快捷工具类。用于快速创建不同的缓存对象。\n\n\n# 使用\n\n//新建fifocache\ncache<string,string> fifocache = cacheutil.newfifocache(3);\n\n\n同样其它类型的cache也可以调用newxxx的方法创建。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"先入先出-FIFOCache",frontmatter:{title:"先入先出-FIFOCache",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/FIFOCache/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/05.%E7%BC%93%E5%AD%98%EF%BC%88Hutool-cache%EF%BC%89/03.%E5%85%88%E5%85%A5%E5%85%88%E5%87%BA-FIFOCache.html",relativePath:"01.指南/05.缓存（Hutool-cache）/03.先入先出-FIFOCache.md",key:"v-9eabf29c",path:"/pages/FIFOCache/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:130}],headersStr:"介绍 使用",content:'# 介绍\n\nFIFO(first in first out) 先进先出策略。元素不停的加入缓存直到缓存满为止，当缓存满时，清理过期缓存对象，清理后依旧满则删除先入的缓存（链表首部对象）。\n\n优点：简单快速\n缺点：不灵活，不能保证最常用的对象总是被保留\n\n\n# 使用\n\nCache<String,String> fifoCache = CacheUtil.newFIFOCache(3);\n\n//加入元素，每个元素可以设置其过期时长，DateUnit.SECOND.getMillis()代表每秒对应的毫秒数，在此为3秒\nfifoCache.put("key1", "value1", DateUnit.SECOND.getMillis() * 3);\nfifoCache.put("key2", "value2", DateUnit.SECOND.getMillis() * 3);\nfifoCache.put("key3", "value3", DateUnit.SECOND.getMillis() * 3);\n\n//由于缓存容量只有3，当加入第四个元素的时候，根据FIFO规则，最先放入的对象将被移除\nfifoCache.put("key4", "value4", DateUnit.SECOND.getMillis() * 3);\n\n//value1为null\nString value1 = fifoCache.get("key1");\n',normalizedContent:'# 介绍\n\nfifo(first in first out) 先进先出策略。元素不停的加入缓存直到缓存满为止，当缓存满时，清理过期缓存对象，清理后依旧满则删除先入的缓存（链表首部对象）。\n\n优点：简单快速\n缺点：不灵活，不能保证最常用的对象总是被保留\n\n\n# 使用\n\ncache<string,string> fifocache = cacheutil.newfifocache(3);\n\n//加入元素，每个元素可以设置其过期时长，dateunit.second.getmillis()代表每秒对应的毫秒数，在此为3秒\nfifocache.put("key1", "value1", dateunit.second.getmillis() * 3);\nfifocache.put("key2", "value2", dateunit.second.getmillis() * 3);\nfifocache.put("key3", "value3", dateunit.second.getmillis() * 3);\n\n//由于缓存容量只有3，当加入第四个元素的时候，根据fifo规则，最先放入的对象将被移除\nfifocache.put("key4", "value4", dateunit.second.getmillis() * 3);\n\n//value1为null\nstring value1 = fifocache.get("key1");\n',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"最少使用-LFUCache",frontmatter:{title:"最少使用-LFUCache",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/LFUCache/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/05.%E7%BC%93%E5%AD%98%EF%BC%88Hutool-cache%EF%BC%89/05.%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8-LFUCache.html",relativePath:"01.指南/05.缓存（Hutool-cache）/05.最少使用-LFUCache.md",key:"v-7e7a2096",path:"/pages/LFUCache/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:35}],headersStr:"介绍 使用",content:'# 介绍\n\nLFU(least frequently used) 最少使用率策略。根据使用次数来判定对象是否被持续缓存（使用率是通过访问次数计算），当缓存满时清理过期对象，清理后依旧满的情况下清除最少访问（访问计数最小）的对象并将其他对象的访问数减去这个最小访问数，以便新对象进入后可以公平计数。\n\n\n# 使用\n\nCache<String, String> lfuCache = CacheUtil.newLFUCache(3);\n//通过实例化对象创建\n//LFUCache<String, String> lfuCache = new LFUCache<String, String>(3);\n\nlfuCache.put("key1", "value1", DateUnit.SECOND.getMillis() * 3);\nlfuCache.get("key1");//使用次数+1\nlfuCache.put("key2", "value2", DateUnit.SECOND.getMillis() * 3);\nlfuCache.put("key3", "value3", DateUnit.SECOND.getMillis() * 3);\nlfuCache.put("key4", "value4", DateUnit.SECOND.getMillis() * 3);\n\n//由于缓存容量只有3，当加入第四个元素的时候，根据LRU规则，最少使用的将被移除（2,3被移除）\nString value2 = lfuCache.get("key2");//null\nString value3 = lfuCache.get("key3");//null\n',normalizedContent:'# 介绍\n\nlfu(least frequently used) 最少使用率策略。根据使用次数来判定对象是否被持续缓存（使用率是通过访问次数计算），当缓存满时清理过期对象，清理后依旧满的情况下清除最少访问（访问计数最小）的对象并将其他对象的访问数减去这个最小访问数，以便新对象进入后可以公平计数。\n\n\n# 使用\n\ncache<string, string> lfucache = cacheutil.newlfucache(3);\n//通过实例化对象创建\n//lfucache<string, string> lfucache = new lfucache<string, string>(3);\n\nlfucache.put("key1", "value1", dateunit.second.getmillis() * 3);\nlfucache.get("key1");//使用次数+1\nlfucache.put("key2", "value2", dateunit.second.getmillis() * 3);\nlfucache.put("key3", "value3", dateunit.second.getmillis() * 3);\nlfucache.put("key4", "value4", dateunit.second.getmillis() * 3);\n\n//由于缓存容量只有3，当加入第四个元素的时候，根据lru规则，最少使用的将被移除（2,3被移除）\nstring value2 = lfucache.get("key2");//null\nstring value3 = lfucache.get("key3");//null\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"最近最久未使用-LRUCache",frontmatter:{title:"最近最久未使用-LRUCache",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/LRUCache/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/05.%E7%BC%93%E5%AD%98%EF%BC%88Hutool-cache%EF%BC%89/06.%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8-LRUCache.html",relativePath:"01.指南/05.缓存（Hutool-cache）/06.最近最久未使用-LRUCache.md",key:"v-3c7bf13c",path:"/pages/LRUCache/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:36}],headersStr:"介绍 使用",content:'# 介绍\n\nLRU (least recently used)最近最久未使用缓存。根据使用时间来判定对象是否被持续缓存，当对象被访问时放入缓存，当缓存满了，最久未被使用的对象将被移除。此缓存基于LinkedHashMap，因此当被缓存的对象每被访问一次，这个对象的key就到链表头部。这个算法简单并且非常快，他比FIFO有一个显著优势是经常使用的对象不太可能被移除缓存。缺点是当缓存满时，不能被很快的访问。\n\n\n# 使用\n\nCache<String, String> lruCache = CacheUtil.newLRUCache(3);\n//通过实例化对象创建\n//LRUCache<String, String> lruCache = new LRUCache<String, String>(3);\nlruCache.put("key1", "value1", DateUnit.SECOND.getMillis() * 3);\nlruCache.put("key2", "value2", DateUnit.SECOND.getMillis() * 3);\nlruCache.put("key3", "value3", DateUnit.SECOND.getMillis() * 3);\nlruCache.get("key1");//使用时间推近\nlruCache.put("key4", "value4", DateUnit.SECOND.getMillis() * 3);\n\n//由于缓存容量只有3，当加入第四个元素的时候，根据LRU规则，最少使用的将被移除（2被移除）\nString value2 = lruCache.get("key");//null\n',normalizedContent:'# 介绍\n\nlru (least recently used)最近最久未使用缓存。根据使用时间来判定对象是否被持续缓存，当对象被访问时放入缓存，当缓存满了，最久未被使用的对象将被移除。此缓存基于linkedhashmap，因此当被缓存的对象每被访问一次，这个对象的key就到链表头部。这个算法简单并且非常快，他比fifo有一个显著优势是经常使用的对象不太可能被移除缓存。缺点是当缓存满时，不能被很快的访问。\n\n\n# 使用\n\ncache<string, string> lrucache = cacheutil.newlrucache(3);\n//通过实例化对象创建\n//lrucache<string, string> lrucache = new lrucache<string, string>(3);\nlrucache.put("key1", "value1", dateunit.second.getmillis() * 3);\nlrucache.put("key2", "value2", dateunit.second.getmillis() * 3);\nlrucache.put("key3", "value3", dateunit.second.getmillis() * 3);\nlrucache.get("key1");//使用时间推近\nlrucache.put("key4", "value4", dateunit.second.getmillis() * 3);\n\n//由于缓存容量只有3，当加入第四个元素的时候，根据lru规则，最少使用的将被移除（2被移除）\nstring value2 = lrucache.get("key");//null\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"文件缓存-FileCache",frontmatter:{title:"文件缓存-FileCache",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/FileCache/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/05.%E7%BC%93%E5%AD%98%EF%BC%88Hutool-cache%EF%BC%89/04.%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98-FileCache.html",relativePath:"01.指南/05.缓存（Hutool-cache）/04.文件缓存-FileCache.md",key:"v-7b681b77",path:"/pages/FileCache/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:69},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:109}],headersStr:"介绍 实现 使用",content:'# 介绍\n\nFileCache主要是将小文件以byte[]的形式缓存到内存中，减少文件的访问，以解决频繁读取文件引起的性能问题。\n\n\n# 实现\n\n * LFUFileCache\n * LRUFileCache\n\n\n# 使用\n\n//参数1：容量，能容纳的byte数\n//参数2：文件最大大小，byte数，决定能缓存多大的文件，大于这个值不被缓存直接读取\n//参数3：超时时间，0表示无超时时间。毫秒\nLFUFileCache cache = new LFUFileCache(1000, 500, 2000);\nbyte[] bytes = cache.getFileBytes("d:/a.jpg");\n\n\nLRUFileCache的使用与LFUFileCache一致，不再举例。',normalizedContent:'# 介绍\n\nfilecache主要是将小文件以byte[]的形式缓存到内存中，减少文件的访问，以解决频繁读取文件引起的性能问题。\n\n\n# 实现\n\n * lfufilecache\n * lrufilecache\n\n\n# 使用\n\n//参数1：容量，能容纳的byte数\n//参数2：文件最大大小，byte数，决定能缓存多大的文件，大于这个值不被缓存直接读取\n//参数3：超时时间，0表示无超时时间。毫秒\nlfufilecache cache = new lfufilecache(1000, 500, 2000);\nbyte[] bytes = cache.getfilebytes("d:/a.jpg");\n\n\nlrufilecache的使用与lfufilecache一致，不再举例。',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"超时-TimedCache",frontmatter:{title:"超时-TimedCache",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/TimedCache/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/05.%E7%BC%93%E5%AD%98%EF%BC%88Hutool-cache%EF%BC%89/07.%E8%B6%85%E6%97%B6-TimedCache.html",relativePath:"01.指南/05.缓存（Hutool-cache）/07.超时-TimedCache.md",key:"v-7037c498",path:"/pages/TimedCache/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:70}],headersStr:"介绍 使用",content:'# 介绍\n\n定时缓存，对被缓存的对象定义一个过期时间，当对象超过过期时间会被清理。此缓存没有容量限制，对象只有在过期后才会被移除。\n\n\n# 使用\n\n//创建缓存，默认4毫秒过期\nTimedCache<String, String> timedCache = CacheUtil.newTimedCache(4);\n//实例化创建\n//TimedCache<String, String> timedCache = new TimedCache<String, String>(4);\n\ntimedCache.put("key1", "value1", 1);//1毫秒过期\ntimedCache.put("key2", "value2", DateUnit.SECOND.getMillis() * 5);\ntimedCache.put("key3", "value3");//默认过期(4毫秒)\n\n//启动定时任务，每5毫秒清理一次过期条目，注释此行首次启动仍会清理过期条目\ntimedCache.schedulePrune(5);\n\n//等待5毫秒\nThreadUtil.sleep(5);\n\n//5毫秒后由于value2设置了5毫秒过期，因此只有value2被保留下来\nString value1 = timedCache.get("key1");//null\nString value2 = timedCache.get("key2");//value2\n\n//5毫秒后，由于设置了默认过期，key3只被保留4毫秒，因此为null\nString value3 = timedCache.get("key3");//null\n\n//取消定时清理\ntimedCache.cancelPruneSchedule();\n\n\n如果用户在超时前调用了get(key)方法，会重头计算起始时间。举个例子，用户设置key1的超时时间5s，用户在4s的时候调用了get("key1")，此时超时时间重新计算，再过4s调用get("key1")方法值依旧存在。如果想避开这个机制，请调用get("key1", false)方法。\n\n> 说明 如果启动了定时器，那会定时清理缓存中的过期值，但是如果不启动，那只有在get这个值得时候才检查过期并清理。不启动定时器带来的问题是：有些值如果长时间不访问，会占用缓存的空间。',normalizedContent:'# 介绍\n\n定时缓存，对被缓存的对象定义一个过期时间，当对象超过过期时间会被清理。此缓存没有容量限制，对象只有在过期后才会被移除。\n\n\n# 使用\n\n//创建缓存，默认4毫秒过期\ntimedcache<string, string> timedcache = cacheutil.newtimedcache(4);\n//实例化创建\n//timedcache<string, string> timedcache = new timedcache<string, string>(4);\n\ntimedcache.put("key1", "value1", 1);//1毫秒过期\ntimedcache.put("key2", "value2", dateunit.second.getmillis() * 5);\ntimedcache.put("key3", "value3");//默认过期(4毫秒)\n\n//启动定时任务，每5毫秒清理一次过期条目，注释此行首次启动仍会清理过期条目\ntimedcache.scheduleprune(5);\n\n//等待5毫秒\nthreadutil.sleep(5);\n\n//5毫秒后由于value2设置了5毫秒过期，因此只有value2被保留下来\nstring value1 = timedcache.get("key1");//null\nstring value2 = timedcache.get("key2");//value2\n\n//5毫秒后，由于设置了默认过期，key3只被保留4毫秒，因此为null\nstring value3 = timedcache.get("key3");//null\n\n//取消定时清理\ntimedcache.cancelpruneschedule();\n\n\n如果用户在超时前调用了get(key)方法，会重头计算起始时间。举个例子，用户设置key1的超时时间5s，用户在4s的时候调用了get("key1")，此时超时时间重新计算，再过4s调用get("key1")方法值依旧存在。如果想避开这个机制，请调用get("key1", false)方法。\n\n> 说明 如果启动了定时器，那会定时清理缓存中的过期值，但是如果不启动，那只有在get这个值得时候才检查过期并清理。不启动定时器带来的问题是：有些值如果长时间不访问，会占用缓存的空间。',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"弱引用-WeakCache",frontmatter:{title:"弱引用-WeakCache",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/WeakCache/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/05.%E7%BC%93%E5%AD%98%EF%BC%88Hutool-cache%EF%BC%89/08.%E5%BC%B1%E5%BC%95%E7%94%A8-WeakCache.html",relativePath:"01.指南/05.缓存（Hutool-cache）/08.弱引用-WeakCache.md",key:"v-f79652fc",path:"/pages/WeakCache/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:87}],headersStr:"介绍 使用",content:"# 介绍\n\n弱引用缓存。对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除。该类使用了WeakHashMap做为其实现，缓存的清理依赖于JVM的垃圾回收。\n\n\n# 使用\n\n与TimedCache使用方法一致：\n\nWeakCache<String, String> weakCache = CacheUtil.newWeakCache(DateUnit.SECOND.getMillis() * 3);\n\n\nWeakCache也可以像TimedCache一样设置定时清理时间，同时具备垃圾回收清理。",normalizedContent:"# 介绍\n\n弱引用缓存。对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除。该类使用了weakhashmap做为其实现，缓存的清理依赖于jvm的垃圾回收。\n\n\n# 使用\n\n与timedcache使用方法一致：\n\nweakcache<string, string> weakcache = cacheutil.newweakcache(dateunit.second.getmillis() * 3);\n\n\nweakcache也可以像timedcache一样设置定时清理时间，同时具备垃圾回收清理。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"JSON工具-JSONUtil",frontmatter:{title:"JSON工具-JSONUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/JSONUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/06.JSON%EF%BC%88Hutool-json%EF%BC%89/02.JSON%E5%B7%A5%E5%85%B7-JSONUtil.html",relativePath:"01.指南/06.JSON（Hutool-json）/02.JSON工具-JSONUtil.md",key:"v-c17338aa",path:"/pages/JSONUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:15},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:98},{level:3,title:"JSON字符串创建",slug:"json字符串创建",normalizedTitle:"json字符串创建",charIndex:105},{level:3,title:"JSON字符串解析",slug:"json字符串解析",normalizedTitle:"json字符串解析",charIndex:588},{level:3,title:"XML字符串转换为JSON",slug:"xml字符串转换为json",normalizedTitle:"xml字符串转换为json",charIndex:761},{level:3,title:"JSON转换为XML",slug:"json转换为xml",normalizedTitle:"json转换为xml",charIndex:940},{level:3,title:"JSON转Bean",slug:"json转bean",normalizedTitle:"json转bean",charIndex:1115},{level:3,title:"Bean转JSON",slug:"bean转json",normalizedTitle:"bean转json",charIndex:1453},{level:3,title:"readXXX",slug:"readxxx",normalizedTitle:"readxxx",charIndex:1859},{level:3,title:"其它方法",slug:"其它方法",normalizedTitle:"其它方法",charIndex:1953}],headersStr:"介绍 使用 JSON字符串创建 JSON字符串解析 XML字符串转换为JSON JSON转换为XML JSON转Bean Bean转JSON readXXX 其它方法",content:'# JSONUtil\n\n\n# 介绍\n\nJSONUtil是针对JSONObject和JSONArray的静态快捷方法集合，在之前的章节我们已经介绍了一些工具方法，在本章节我们将做一些补充。\n\n\n# 使用\n\n\n# JSON字符串创建\n\nJSONUtil.toJsonStr可以将任意对象（Bean、Map、集合等）直接转换为JSON字符串。 如果对象是有序的Map等对象，则转换后的JSON字符串也是有序的。\n\nSortedMap<Object, Object> sortedMap = new TreeMap<Object, Object>() {\n\tprivate static final long serialVersionUID = 1L;\n\t{\n\tput("attributes", "a");\n\tput("b", "b");\n\tput("c", "c");\n}};\n\nJSONUtil.toJsonStr(sortedMap);\n\n\n结果：\n\n{"attributes":"a","b":"b","c":"c"}\n\n\n如果我们想获得格式化后的JSON，则：\n\nJSONUtil.toJsonPrettyStr(sortedMap);\n\n\n结果：\n\n{\n    "attributes": "a",\n    "b": "b",\n    "c": "c"\n}\n\n\n\n# JSON字符串解析\n\nString html = "{\\"name\\":\\"Something must have been changed since you leave\\"}";\nJSONObject jsonObject = JSONUtil.parseObj(html);\njsonObject.getStr("name");\n\n\n\n# XML字符串转换为JSON\n\nString s = "<sfzh>123</sfzh><sfz>456</sfz><name>aa</name><gender>1</gender>";\nJSONObject json = JSONUtil.parseFromXml(s);\n\njson.get("sfzh");\njson.get("name");\n\n\n\n# JSON转换为XML\n\nfinal JSONObject put = JSONUtil.createObj()\n\t\t.set("aaa", "你好")\n\t\t.set("键2", "test");\n\n// <aaa>你好</aaa><键2>test</键2>\nfinal String s = JSONUtil.toXmlStr(put);\n\n\n\n# JSON转Bean\n\n我们先定义两个较为复杂的Bean（包含泛型）\n\n@Data\npublic class ADT {\n\tprivate List<String> BookingCode;\n}\n\n@Data\npublic class Price {\n\tprivate List<List<ADT>> ADT;\n}\n\n\nString json = "{\\"ADT\\":[[{\\"BookingCode\\":[\\"N\\",\\"N\\"]}]]}";\n\nPrice price = JSONUtil.toBean(json, Price.class);\n\n// N\nprice.getADT().get(0).get(0).getBookingCode().get(0);\n\n\n\n# Bean转JSON\n\n5.x的Hutool中增加了一个自定义注解：@Alias，通过此注解可以给Bean的字段设置别名。\n\n@Data\npublic class Test {\n    private String name;\n\n    @Alias("aliasSex")\n    private String sex;\n\n    public static void main(String[] args) {\n        Test test = new Test();\n        test.setName("handy");\n        test.setSex("男");\n        // 结果: {"name":"handy","aliasSex":"男"}\n        String json = JSONUtil.toJsonStr(test);\n    }\n\n}\n\n\n\n\n# readXXX\n\n这类方法主要是从JSON文件中读取JSON对象的快捷方法。包括：\n\n * readJSON\n * readJSONObject\n * readJSONArray\n\n\n# 其它方法\n\n除了上面中常用的一些方法，JSONUtil还提供了一些JSON辅助方法：\n\n * quote 对所有双引号做转义处理（使用双反斜杠做转义）\n * wrap 包装对象，可以将普通任意对象转为JSON对象\n * formatJsonStr 格式化JSON字符串，此方法并不严格检查JSON的格式正确与否',normalizedContent:'# jsonutil\n\n\n# 介绍\n\njsonutil是针对jsonobject和jsonarray的静态快捷方法集合，在之前的章节我们已经介绍了一些工具方法，在本章节我们将做一些补充。\n\n\n# 使用\n\n\n# json字符串创建\n\njsonutil.tojsonstr可以将任意对象（bean、map、集合等）直接转换为json字符串。 如果对象是有序的map等对象，则转换后的json字符串也是有序的。\n\nsortedmap<object, object> sortedmap = new treemap<object, object>() {\n\tprivate static final long serialversionuid = 1l;\n\t{\n\tput("attributes", "a");\n\tput("b", "b");\n\tput("c", "c");\n}};\n\njsonutil.tojsonstr(sortedmap);\n\n\n结果：\n\n{"attributes":"a","b":"b","c":"c"}\n\n\n如果我们想获得格式化后的json，则：\n\njsonutil.tojsonprettystr(sortedmap);\n\n\n结果：\n\n{\n    "attributes": "a",\n    "b": "b",\n    "c": "c"\n}\n\n\n\n# json字符串解析\n\nstring html = "{\\"name\\":\\"something must have been changed since you leave\\"}";\njsonobject jsonobject = jsonutil.parseobj(html);\njsonobject.getstr("name");\n\n\n\n# xml字符串转换为json\n\nstring s = "<sfzh>123</sfzh><sfz>456</sfz><name>aa</name><gender>1</gender>";\njsonobject json = jsonutil.parsefromxml(s);\n\njson.get("sfzh");\njson.get("name");\n\n\n\n# json转换为xml\n\nfinal jsonobject put = jsonutil.createobj()\n\t\t.set("aaa", "你好")\n\t\t.set("键2", "test");\n\n// <aaa>你好</aaa><键2>test</键2>\nfinal string s = jsonutil.toxmlstr(put);\n\n\n\n# json转bean\n\n我们先定义两个较为复杂的bean（包含泛型）\n\n@data\npublic class adt {\n\tprivate list<string> bookingcode;\n}\n\n@data\npublic class price {\n\tprivate list<list<adt>> adt;\n}\n\n\nstring json = "{\\"adt\\":[[{\\"bookingcode\\":[\\"n\\",\\"n\\"]}]]}";\n\nprice price = jsonutil.tobean(json, price.class);\n\n// n\nprice.getadt().get(0).get(0).getbookingcode().get(0);\n\n\n\n# bean转json\n\n5.x的hutool中增加了一个自定义注解：@alias，通过此注解可以给bean的字段设置别名。\n\n@data\npublic class test {\n    private string name;\n\n    @alias("aliassex")\n    private string sex;\n\n    public static void main(string[] args) {\n        test test = new test();\n        test.setname("handy");\n        test.setsex("男");\n        // 结果: {"name":"handy","aliassex":"男"}\n        string json = jsonutil.tojsonstr(test);\n    }\n\n}\n\n\n\n\n# readxxx\n\n这类方法主要是从json文件中读取json对象的快捷方法。包括：\n\n * readjson\n * readjsonobject\n * readjsonarray\n\n\n# 其它方法\n\n除了上面中常用的一些方法，jsonutil还提供了一些json辅助方法：\n\n * quote 对所有双引号做转义处理（使用双反斜杠做转义）\n * wrap 包装对象，可以将普通任意对象转为json对象\n * formatjsonstr 格式化json字符串，此方法并不严格检查json的格式正确与否',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/json/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/06.JSON%EF%BC%88Hutool-json%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/06.JSON（Hutool-json）/01.概述.md",key:"v-3a342a82",path:"/pages/json/",headers:[{level:2,title:"为何集成",slug:"为何集成",normalizedTitle:"为何集成",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:285}],headersStr:"为何集成 介绍",content:'# 为何集成\n\nJSON在现在的开发中做为跨平台的数据交换格式已经慢慢有替代XML的趋势（比如RESTful规范），我想大家在开发中对外提供接口也越来越多的使用JSON格式。\n\n不可否认，现在优秀的JSON框架非常多，我经常使用的像阿里的FastJSON，Jackson等都是非常优秀的包，性能突出，简单易用。Hutool开始也并不想自己写一个JSON，但是在各种工具的封装中，发现JSON已经不可或缺，因此将json.org官方的JSON解析纳入其中，进行改造。在改造过程中，积极吸取其它类库优点，优化成员方法，抽象接口和类，最终形成Hutool-json。\n\n\n# 介绍\n\nHutool-json的核心类只有两个：\n\n * JSONObject\n * JSONArray\n\n这与其它JSON包是类似的，与此同时，还提供一个JSONUtil工具类用于简化针对JSON的各种操作和转换。\n\n除了核心类，还提供了一些辅助类用于实现特定功能：\n\n * JSONSupport Bean类继承此对象即可无缝转换为JSON或JSON字符串。同时实现了toString()方法可将当前对象输出为JSON字符串。\n * XML 提供JSON与XML之间的快速转换，同时JSONUtil中有相应静态封装。\n * JSON JSONObject和JSONArray共同实现的接口类，JSONUtil.parse方法默认返回此对象（因为不知道是JSON对象还是JSON数组），然后可以根据实际类型判断后转换对象类型。\n\n与FastJSON类似，JSONObject实现了Map接口，JSONArray实现了List接口，这样我们便可以使用熟悉的API来操作JSON。\n\n在JSON中，Hutool封装了getXXX方法，支持大部分内置类型的值获取操作。比如：\n\nJSONObject json1 = JSONUtil.createObj();\njson1.getStr("key");\njson1.getInt("key");\njson1.getLong("key");\njson1.getDouble("key");\njson1.getBigDecimal("key");\n\n\n这些成员方法的加入，可以省掉大量的类型转换代码，大大提高JSON的操作简便性。',normalizedContent:'# 为何集成\n\njson在现在的开发中做为跨平台的数据交换格式已经慢慢有替代xml的趋势（比如restful规范），我想大家在开发中对外提供接口也越来越多的使用json格式。\n\n不可否认，现在优秀的json框架非常多，我经常使用的像阿里的fastjson，jackson等都是非常优秀的包，性能突出，简单易用。hutool开始也并不想自己写一个json，但是在各种工具的封装中，发现json已经不可或缺，因此将json.org官方的json解析纳入其中，进行改造。在改造过程中，积极吸取其它类库优点，优化成员方法，抽象接口和类，最终形成hutool-json。\n\n\n# 介绍\n\nhutool-json的核心类只有两个：\n\n * jsonobject\n * jsonarray\n\n这与其它json包是类似的，与此同时，还提供一个jsonutil工具类用于简化针对json的各种操作和转换。\n\n除了核心类，还提供了一些辅助类用于实现特定功能：\n\n * jsonsupport bean类继承此对象即可无缝转换为json或json字符串。同时实现了tostring()方法可将当前对象输出为json字符串。\n * xml 提供json与xml之间的快速转换，同时jsonutil中有相应静态封装。\n * json jsonobject和jsonarray共同实现的接口类，jsonutil.parse方法默认返回此对象（因为不知道是json对象还是json数组），然后可以根据实际类型判断后转换对象类型。\n\n与fastjson类似，jsonobject实现了map接口，jsonarray实现了list接口，这样我们便可以使用熟悉的api来操作json。\n\n在json中，hutool封装了getxxx方法，支持大部分内置类型的值获取操作。比如：\n\njsonobject json1 = jsonutil.createobj();\njson1.getstr("key");\njson1.getint("key");\njson1.getlong("key");\njson1.getdouble("key");\njson1.getbigdecimal("key");\n\n\n这些成员方法的加入，可以省掉大量的类型转换代码，大大提高json的操作简便性。',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"JSON数组-JSONArray",frontmatter:{title:"JSON数组-JSONArray",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/JSONArray/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/06.JSON%EF%BC%88Hutool-json%EF%BC%89/04.JSON%E6%95%B0%E7%BB%84-JSONArray.html",relativePath:"01.指南/06.JSON（Hutool-json）/04.JSON数组-JSONArray.md",key:"v-f24d97ba",path:"/pages/JSONArray/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:29},{level:3,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:108},{level:3,title:"从Bean列表解析",slug:"从bean列表解析",normalizedTitle:"从bean列表解析",charIndex:306},{level:3,title:"从JSON字符串解析",slug:"从json字符串解析",normalizedTitle:"从json字符串解析",charIndex:796},{level:3,title:"转换为bean的List",slug:"转换为bean的list",normalizedTitle:"转换为bean的list",charIndex:918},{level:3,title:"转换为Dict的List",slug:"转换为dict的list",normalizedTitle:"转换为dict的list",charIndex:1247},{level:3,title:"转换为数组",slug:"转换为数组",normalizedTitle:"转换为数组",charIndex:1547},{level:3,title:"JSON路径",slug:"json路径",normalizedTitle:"json路径",charIndex:1736}],headersStr:"介绍 使用 创建 从Bean列表解析 从JSON字符串解析 转换为bean的List 转换为Dict的List 转换为数组 JSON路径",content:'# 介绍\n\n在JSON中，JSONArray代表一个数组，使用中括号包围，每个元素使用逗号隔开。一个JSONArray类似于这样：\n\n["value1","value2","value3"]\n\n\n\n# 使用\n\n\n# 创建\n\n//方法1\nJSONArray array = JSONUtil.createArray();\n//方法2\nJSONArray array = new JSONArray();\n\narray.add("value1");\narray.add("value2");\narray.add("value3");\n\n//转为JSONArray字符串\narray.toString();\n\n\n\n# 从Bean列表解析\n\n先定义bean：\n\n@Data\npublic class KeyBean{\n\tprivate String akey;\n\tprivate String bkey;\n}\n\n\nKeyBean b1 = new KeyBean();\nb1.setAkey("aValue1");\nb1.setBkey("bValue1");\nKeyBean b2 = new KeyBean();\nb2.setAkey("aValue2");\nb2.setBkey("bValue2");\n\nArrayList<KeyBean> list = CollUtil.newArrayList(b1, b2);\n\n// [{"akey":"aValue1","bkey":"bValue1"},{"akey":"aValue2","bkey":"bValue2"}]\nJSONArray jsonArray = JSONUtil.parseArray(list);\n\n// aValue1\njsonArray.getJSONObject(0).getStr("akey");\n\n\n\n# 从JSON字符串解析\n\nString jsonStr = "[\\"value1\\", \\"value2\\", \\"value3\\"]";\nJSONArray array = JSONUtil.parseArray(jsonStr);\n\n\n\n# 转换为bean的List\n\n先定义一个Bean\n\n@Data\nstatic class User {\n\tprivate Integer id;\n\tprivate String name;\n}\n\n\nString jsonArr = "[{\\"id\\":111,\\"name\\":\\"test1\\"},{\\"id\\":112,\\"name\\":\\"test2\\"}]";\nJSONArray array = JSONUtil.parseArray(jsonArr);\n\nList<User> userList = JSONUtil.toList(array, User.class);\n\n// 111\nuserList.get(0).getId();\n\n\n\n# 转换为Dict的List\n\nDict是Hutool定义的特殊Map，提供了以字符串为key的Map功能，并提供getXXX方法，转换也类似：\n\nString jsonArr = "[{\\"id\\":111,\\"name\\":\\"test1\\"},{\\"id\\":112,\\"name\\":\\"test2\\"}]";\nJSONArray array = JSONUtil.parseArray(jsonArr);\n\nList<Dict> list = JSONUtil.toList(array, Dict.class);\n\n// 111\nlist.get(0).getInt("id");\n\n\n\n# 转换为数组\n\nString jsonArr = "[{\\"id\\":111,\\"name\\":\\"test1\\"},{\\"id\\":112,\\"name\\":\\"test2\\"}]";\nJSONArray array = JSONUtil.parseArray(jsonArr);\n\nUser[] list = array.toArray(new User[0]);\n\n\n\n# JSON路径\n\n如果JSON的层级特别深，那么获取某个值就变得非常麻烦，代码也很臃肿，Hutool提供了getByPath方法可以通过表达式获取JSON中的值。\n\nString jsonStr = "[{\\"id\\": \\"1\\",\\"name\\": \\"a\\"},{\\"id\\": \\"2\\",\\"name\\": \\"b\\"}]";\nfinal JSONArray jsonArray = JSONUtil.parseArray(jsonStr);\n\n// b\njsonArray.getByPath("[1].name");\n',normalizedContent:'# 介绍\n\n在json中，jsonarray代表一个数组，使用中括号包围，每个元素使用逗号隔开。一个jsonarray类似于这样：\n\n["value1","value2","value3"]\n\n\n\n# 使用\n\n\n# 创建\n\n//方法1\njsonarray array = jsonutil.createarray();\n//方法2\njsonarray array = new jsonarray();\n\narray.add("value1");\narray.add("value2");\narray.add("value3");\n\n//转为jsonarray字符串\narray.tostring();\n\n\n\n# 从bean列表解析\n\n先定义bean：\n\n@data\npublic class keybean{\n\tprivate string akey;\n\tprivate string bkey;\n}\n\n\nkeybean b1 = new keybean();\nb1.setakey("avalue1");\nb1.setbkey("bvalue1");\nkeybean b2 = new keybean();\nb2.setakey("avalue2");\nb2.setbkey("bvalue2");\n\narraylist<keybean> list = collutil.newarraylist(b1, b2);\n\n// [{"akey":"avalue1","bkey":"bvalue1"},{"akey":"avalue2","bkey":"bvalue2"}]\njsonarray jsonarray = jsonutil.parsearray(list);\n\n// avalue1\njsonarray.getjsonobject(0).getstr("akey");\n\n\n\n# 从json字符串解析\n\nstring jsonstr = "[\\"value1\\", \\"value2\\", \\"value3\\"]";\njsonarray array = jsonutil.parsearray(jsonstr);\n\n\n\n# 转换为bean的list\n\n先定义一个bean\n\n@data\nstatic class user {\n\tprivate integer id;\n\tprivate string name;\n}\n\n\nstring jsonarr = "[{\\"id\\":111,\\"name\\":\\"test1\\"},{\\"id\\":112,\\"name\\":\\"test2\\"}]";\njsonarray array = jsonutil.parsearray(jsonarr);\n\nlist<user> userlist = jsonutil.tolist(array, user.class);\n\n// 111\nuserlist.get(0).getid();\n\n\n\n# 转换为dict的list\n\ndict是hutool定义的特殊map，提供了以字符串为key的map功能，并提供getxxx方法，转换也类似：\n\nstring jsonarr = "[{\\"id\\":111,\\"name\\":\\"test1\\"},{\\"id\\":112,\\"name\\":\\"test2\\"}]";\njsonarray array = jsonutil.parsearray(jsonarr);\n\nlist<dict> list = jsonutil.tolist(array, dict.class);\n\n// 111\nlist.get(0).getint("id");\n\n\n\n# 转换为数组\n\nstring jsonarr = "[{\\"id\\":111,\\"name\\":\\"test1\\"},{\\"id\\":112,\\"name\\":\\"test2\\"}]";\njsonarray array = jsonutil.parsearray(jsonarr);\n\nuser[] list = array.toarray(new user[0]);\n\n\n\n# json路径\n\n如果json的层级特别深，那么获取某个值就变得非常麻烦，代码也很臃肿，hutool提供了getbypath方法可以通过表达式获取json中的值。\n\nstring jsonstr = "[{\\"id\\": \\"1\\",\\"name\\": \\"a\\"},{\\"id\\": \\"2\\",\\"name\\": \\"b\\"}]";\nfinal jsonarray jsonarray = jsonutil.parsearray(jsonstr);\n\n// b\njsonarray.getbypath("[1].name");\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"加密解密工具-SecureUtil",frontmatter:{title:"加密解密工具-SecureUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/SecureUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/07.%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%EF%BC%88Hutool-crypto%EF%BC%89/02.%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7-SecureUtil.html",relativePath:"01.指南/07.加密解密（Hutool-crypto）/02.加密解密工具-SecureUtil.md",key:"v-0b721a8b",path:"/pages/SecureUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方法介绍",slug:"方法介绍",normalizedTitle:"方法介绍",charIndex:56},{level:3,title:"对称加密",slug:"对称加密",normalizedTitle:"对称加密",charIndex:65},{level:3,title:"摘要算法",slug:"摘要算法",normalizedTitle:"摘要算法",charIndex:111},{level:3,title:"非对称加密",slug:"非对称加密",normalizedTitle:"非对称加密",charIndex:222},{level:3,title:"UUID",slug:"uuid",normalizedTitle:"uuid",charIndex:269},{level:3,title:"密钥生成",slug:"密钥生成",normalizedTitle:"密钥生成",charIndex:39}],headersStr:"介绍 方法介绍 对称加密 摘要算法 非对称加密 UUID 密钥生成",content:"# 介绍\n\nSecureUtil主要针对常用加密算法构建快捷方式，还有提供一些密钥生成的快捷工具方法。\n\n\n# 方法介绍\n\n\n# 对称加密\n\n * SecureUtil.aes\n * SecureUtil.des\n\n\n# 摘要算法\n\n * SecureUtil.md5\n * SecureUtil.sha1\n * SecureUtil.hmac\n * SecureUtil.hmacMd5\n * SecureUtil.hmacSha1\n\n\n# 非对称加密\n\n * SecureUtil.rsa\n * SecureUtil.dsa\n\n\n# UUID\n\n * SecureUtil.simpleUUID 方法提供无“-”的UUID\n\n\n# 密钥生成\n\n * SecureUtil.generateKey 针对对称加密生成密钥\n * SecureUtil.generateKeyPair 生成密钥对（用于非对称加密）\n * SecureUtil.generateSignature 生成签名（用于非对称加密）\n\n其它方法为针对特定加密方法的一些密钥生成和签名相关方法，详细请参阅API文档。",normalizedContent:"# 介绍\n\nsecureutil主要针对常用加密算法构建快捷方式，还有提供一些密钥生成的快捷工具方法。\n\n\n# 方法介绍\n\n\n# 对称加密\n\n * secureutil.aes\n * secureutil.des\n\n\n# 摘要算法\n\n * secureutil.md5\n * secureutil.sha1\n * secureutil.hmac\n * secureutil.hmacmd5\n * secureutil.hmacsha1\n\n\n# 非对称加密\n\n * secureutil.rsa\n * secureutil.dsa\n\n\n# uuid\n\n * secureutil.simpleuuid 方法提供无“-”的uuid\n\n\n# 密钥生成\n\n * secureutil.generatekey 针对对称加密生成密钥\n * secureutil.generatekeypair 生成密钥对（用于非对称加密）\n * secureutil.generatesignature 生成签名（用于非对称加密）\n\n其它方法为针对特定加密方法的一些密钥生成和签名相关方法，详细请参阅api文档。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"国密算法工具-SmUtil",frontmatter:{title:"国密算法工具-SmUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/SmUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/07.%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%EF%BC%88Hutool-crypto%EF%BC%89/03.%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95%E5%B7%A5%E5%85%B7-SmUtil.html",relativePath:"01.指南/07.加密解密（Hutool-crypto）/03.国密算法工具-SmUtil.md",key:"v-993a05a0",path:"/pages/SmUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:145},{level:3,title:"引入Bouncy Castle依赖",slug:"引入bouncy-castle依赖",normalizedTitle:"引入bouncy castle依赖",charIndex:152},{level:3,title:"非对称加密SM2",slug:"非对称加密sm2",normalizedTitle:"非对称加密sm2",charIndex:362},{level:3,title:"摘要加密算法SM3",slug:"摘要加密算法sm3",normalizedTitle:"摘要加密算法sm3",charIndex:3320},{level:3,title:"对称加密SM4",slug:"对称加密sm4",normalizedTitle:"对称加密sm4",charIndex:3447}],headersStr:"介绍 使用 引入Bouncy Castle依赖 非对称加密SM2 摘要加密算法SM3 对称加密SM4",content:'# 介绍\n\nHutool针对Bouncy Castle做了简化包装，用于实现国密算法中的SM2、SM3、SM4。\n\n国密算法工具封装包括：\n\n * 非对称加密和签名：SM2\n * 摘要签名算法：SM3\n * 对称加密：SM4\n\n国密算法需要引入Bouncy Castle库的依赖。\n\n\n# 使用\n\n\n# 引入Bouncy Castle依赖\n\n<dependency>\n  <groupId>org.bouncycastle</groupId>\n  <artifactId>bcpkix-jdk18on</artifactId>\n  <version>1.78.1</version>\n</dependency>\n\n\n> 说明 bcprov-jdk18on的版本请前往Maven中央库搜索，查找对应JDK的最新版本。\n\n\n# 非对称加密SM2\n\n 1. 使用随机生成的密钥对加密或解密\n\nString text = "我是一段测试aaaa";\n\nSM2 sm2 = SmUtil.sm2();\n// 公钥加密，私钥解密\nString encryptStr = sm2.encryptBcd(text, KeyType.PublicKey);\nString decryptStr = StrUtil.utf8Str(sm2.decryptFromBcd(encryptStr, KeyType.PrivateKey));\n\n\n 2. 使用自定义密钥对加密或解密\n\nString text = "我是一段测试aaaa";\n\nKeyPair pair = SecureUtil.generateKeyPair("SM2");\nbyte[] privateKey = pair.getPrivate().getEncoded();\nbyte[] publicKey = pair.getPublic().getEncoded();\n\nSM2 sm2 = SmUtil.sm2(privateKey, publicKey);\n// 公钥加密，私钥解密\nString encryptStr = sm2.encryptBcd(text, KeyType.PublicKey);\nString decryptStr = StrUtil.utf8Str(sm2.decryptFromBcd(encryptStr, KeyType.PrivateKey));\n\n\n 3. SM2签名和验签\n\nString content = "我是Hanley.";\nfinal SM2 sm2 = SmUtil.sm2();\nString sign = sm2.signHex(HexUtil.encodeHexStr(content));\n\n// true\nboolean verify = sm2.verifyHex(HexUtil.encodeHexStr(content), sign);\n\n\n当然，也可以自定义密钥对：\n\nString content = "我是Hanley.";\nKeyPair pair = SecureUtil.generateKeyPair("SM2");\nfinal SM2 sm2 = new SM2(pair.getPrivate(), pair.getPublic());\n\nbyte[] sign = sm2.sign(content.getBytes());\n\n// true\nboolean verify = sm2.verify(content.getBytes(), sign);\n\n\n 4. 使用SM2曲线点构建SM2\n\n使用曲线点构建中的点生成和验证见：https://i.goto327.top/CryptTools/SM2.aspx?tdsourcetag=s_pctim_aiomsg\n\nString privateKeyHex = "FAB8BBE670FAE338C9E9382B9FB6485225C11A3ECB84C938F10F20A93B6215F0";\nString x = "9EF573019D9A03B16B0BE44FC8A5B4E8E098F56034C97B312282DD0B4810AFC3";\nString y = "CC759673ED0FC9B9DC7E6FA38F0E2B121E02654BF37EA6B63FAF2A0D6013EADF";\n\n// 数据和ID此处使用16进制表示\nString data = "434477813974bf58f94bcf760833c2b40f77a5fc360485b0b9ed1bd9682edb45";\nString id = "31323334353637383132333435363738";\n\nfinal SM2 sm2 = new SM2(privateKeyHex, x, y);\n// 生成的签名是64位\nsm2.usePlainEncoding();\n\nfinal String sign = sm2.signHex(data, id);\n// true\nboolean verify = sm2.verifyHex(data, sign)\n\n\n 5. 使用私钥D值签名\n\n//需要签名的明文,得到明文对应的字节数组\nbyte[] dataBytes = "我是一段测试aaaa".getBytes();\n//指定的私钥\nString privateKeyHex = "1ebf8b341c695ee456fd1a41b82645724bc25d79935437d30e7e4b0a554baa5e";\n\n// 此构造从5.5.9开始可使用\nfinal SM2 sm2 = new SM2(privateKeyHex, null, null);\nsm2.usePlainEncoding();\nbyte[] sign = sm2.sign(dataBytes, null);\n\n\n 6. 使用公钥Q值验证签名\n\n//指定的公钥\nString publicKeyHex ="04db9629dd33ba568e9507add5df6587a0998361a03d3321948b448c653c2c1b7056434884ab6f3d1c529501f166a336e86f045cea10dffe58aa82ea13d725363";\n//需要加密的明文,得到明文对应的字节数组\nbyte[] dataBytes = "我是一段测试aaaa".getBytes();\n//签名值\nString signHex ="2881346e038d2ed706ccdd025f2b1dafa7377d5cf090134b98756fafe084dddbcdba0ab00b5348ed48025195af3f1dda29e819bb66aa9d4d088050ff148482a";\n\nfinal SM2 sm2 = new SM2(null, ECKeyUtil.toSm2PublicParams(publicKeyHex));\nsm2.usePlainEncoding();\n\n// true\nboolean verify = sm2.verify(dataBytes, HexUtil.decodeHex(signHex));\n\n\n 7. 其他格式的密钥\n\n在SM2算法中，密钥的格式分以下几种：\n\n私钥：\n\n * D值 一般为硬件直接生成的值\n * PKCS#8 JDK默认生成的私钥格式\n * PKCS#1 一般为OpenSSL生成的的EC密钥格式\n\n公钥：\n\n * Q值 一般为硬件直接生成的值\n * X.509 JDK默认生成的公钥格式\n * PKCS#1 一般为OpenSSL生成的的EC密钥格式\n\n在新版本的Hutool中，SM2的构造方法对这几类的密钥都做了兼容，即用户无需关注密钥类型：\n\n\n# 摘要加密算法SM3\n\n//结果为：136ce3c86e4ed909b76082055a61586af20b4dab674732ebd4b599eef080c9be\nString digestHex = SmUtil.sm3("aaaaa");\n\n\n\n# 对称加密SM4\n\n 1. 使用生成的随机密钥\n\nString content = "test中文";\n\n// 随机生成密钥\nSymmetricCrypto sm4 = SmUtil.sm4();\n\nString encryptHex = sm4.encryptHex(content);\nString decryptStr = sm4.decryptStr(encryptHex, CharsetUtil.CHARSET_UTF_8);\n\n\n 2. 使用自定义密钥\n\nString content = "test中文frfewrewrwerwer---------------------------------------------------";\n\n// 生成自定义密钥\nbyte[] key = KeyUtil.generateKey(SM4.ALGORITHM_NAME, 128).getEncoded();\n\nSM4 sm4 = SmUtil.sm4(key);\n\nString encryptHex = sm4.encryptHex(content);\nString decryptStr = sm4.decryptStr(encryptHex, CharsetUtil.CHARSET_UTF_8);\n',normalizedContent:'# 介绍\n\nhutool针对bouncy castle做了简化包装，用于实现国密算法中的sm2、sm3、sm4。\n\n国密算法工具封装包括：\n\n * 非对称加密和签名：sm2\n * 摘要签名算法：sm3\n * 对称加密：sm4\n\n国密算法需要引入bouncy castle库的依赖。\n\n\n# 使用\n\n\n# 引入bouncy castle依赖\n\n<dependency>\n  <groupid>org.bouncycastle</groupid>\n  <artifactid>bcpkix-jdk18on</artifactid>\n  <version>1.78.1</version>\n</dependency>\n\n\n> 说明 bcprov-jdk18on的版本请前往maven中央库搜索，查找对应jdk的最新版本。\n\n\n# 非对称加密sm2\n\n 1. 使用随机生成的密钥对加密或解密\n\nstring text = "我是一段测试aaaa";\n\nsm2 sm2 = smutil.sm2();\n// 公钥加密，私钥解密\nstring encryptstr = sm2.encryptbcd(text, keytype.publickey);\nstring decryptstr = strutil.utf8str(sm2.decryptfrombcd(encryptstr, keytype.privatekey));\n\n\n 2. 使用自定义密钥对加密或解密\n\nstring text = "我是一段测试aaaa";\n\nkeypair pair = secureutil.generatekeypair("sm2");\nbyte[] privatekey = pair.getprivate().getencoded();\nbyte[] publickey = pair.getpublic().getencoded();\n\nsm2 sm2 = smutil.sm2(privatekey, publickey);\n// 公钥加密，私钥解密\nstring encryptstr = sm2.encryptbcd(text, keytype.publickey);\nstring decryptstr = strutil.utf8str(sm2.decryptfrombcd(encryptstr, keytype.privatekey));\n\n\n 3. sm2签名和验签\n\nstring content = "我是hanley.";\nfinal sm2 sm2 = smutil.sm2();\nstring sign = sm2.signhex(hexutil.encodehexstr(content));\n\n// true\nboolean verify = sm2.verifyhex(hexutil.encodehexstr(content), sign);\n\n\n当然，也可以自定义密钥对：\n\nstring content = "我是hanley.";\nkeypair pair = secureutil.generatekeypair("sm2");\nfinal sm2 sm2 = new sm2(pair.getprivate(), pair.getpublic());\n\nbyte[] sign = sm2.sign(content.getbytes());\n\n// true\nboolean verify = sm2.verify(content.getbytes(), sign);\n\n\n 4. 使用sm2曲线点构建sm2\n\n使用曲线点构建中的点生成和验证见：https://i.goto327.top/crypttools/sm2.aspx?tdsourcetag=s_pctim_aiomsg\n\nstring privatekeyhex = "fab8bbe670fae338c9e9382b9fb6485225c11a3ecb84c938f10f20a93b6215f0";\nstring x = "9ef573019d9a03b16b0be44fc8a5b4e8e098f56034c97b312282dd0b4810afc3";\nstring y = "cc759673ed0fc9b9dc7e6fa38f0e2b121e02654bf37ea6b63faf2a0d6013eadf";\n\n// 数据和id此处使用16进制表示\nstring data = "434477813974bf58f94bcf760833c2b40f77a5fc360485b0b9ed1bd9682edb45";\nstring id = "31323334353637383132333435363738";\n\nfinal sm2 sm2 = new sm2(privatekeyhex, x, y);\n// 生成的签名是64位\nsm2.useplainencoding();\n\nfinal string sign = sm2.signhex(data, id);\n// true\nboolean verify = sm2.verifyhex(data, sign)\n\n\n 5. 使用私钥d值签名\n\n//需要签名的明文,得到明文对应的字节数组\nbyte[] databytes = "我是一段测试aaaa".getbytes();\n//指定的私钥\nstring privatekeyhex = "1ebf8b341c695ee456fd1a41b82645724bc25d79935437d30e7e4b0a554baa5e";\n\n// 此构造从5.5.9开始可使用\nfinal sm2 sm2 = new sm2(privatekeyhex, null, null);\nsm2.useplainencoding();\nbyte[] sign = sm2.sign(databytes, null);\n\n\n 6. 使用公钥q值验证签名\n\n//指定的公钥\nstring publickeyhex ="04db9629dd33ba568e9507add5df6587a0998361a03d3321948b448c653c2c1b7056434884ab6f3d1c529501f166a336e86f045cea10dffe58aa82ea13d725363";\n//需要加密的明文,得到明文对应的字节数组\nbyte[] databytes = "我是一段测试aaaa".getbytes();\n//签名值\nstring signhex ="2881346e038d2ed706ccdd025f2b1dafa7377d5cf090134b98756fafe084dddbcdba0ab00b5348ed48025195af3f1dda29e819bb66aa9d4d088050ff148482a";\n\nfinal sm2 sm2 = new sm2(null, eckeyutil.tosm2publicparams(publickeyhex));\nsm2.useplainencoding();\n\n// true\nboolean verify = sm2.verify(databytes, hexutil.decodehex(signhex));\n\n\n 7. 其他格式的密钥\n\n在sm2算法中，密钥的格式分以下几种：\n\n私钥：\n\n * d值 一般为硬件直接生成的值\n * pkcs#8 jdk默认生成的私钥格式\n * pkcs#1 一般为openssl生成的的ec密钥格式\n\n公钥：\n\n * q值 一般为硬件直接生成的值\n * x.509 jdk默认生成的公钥格式\n * pkcs#1 一般为openssl生成的的ec密钥格式\n\n在新版本的hutool中，sm2的构造方法对这几类的密钥都做了兼容，即用户无需关注密钥类型：\n\n\n# 摘要加密算法sm3\n\n//结果为：136ce3c86e4ed909b76082055a61586af20b4dab674732ebd4b599eef080c9be\nstring digesthex = smutil.sm3("aaaaa");\n\n\n\n# 对称加密sm4\n\n 1. 使用生成的随机密钥\n\nstring content = "test中文";\n\n// 随机生成密钥\nsymmetriccrypto sm4 = smutil.sm4();\n\nstring encrypthex = sm4.encrypthex(content);\nstring decryptstr = sm4.decryptstr(encrypthex, charsetutil.charset_utf_8);\n\n\n 2. 使用自定义密钥\n\nstring content = "test中文frfewrewrwerwer---------------------------------------------------";\n\n// 生成自定义密钥\nbyte[] key = keyutil.generatekey(sm4.algorithm_name, 128).getencoded();\n\nsm4 sm4 = smutil.sm4(key);\n\nstring encrypthex = sm4.encrypthex(content);\nstring decryptstr = sm4.decryptstr(encrypthex, charsetutil.charset_utf_8);\n',charsets:{cjk:!0},lastUpdated:"2024/05/29, 10:56:16",lastUpdatedTimestamp:1716951376e3},{title:"对称加密-SymmetricCrypto",frontmatter:{title:"对称加密-SymmetricCrypto",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/SymmetricCrypto/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/07.%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%EF%BC%88Hutool-crypto%EF%BC%89/04.%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-SymmetricCrypto.html",relativePath:"01.指南/07.加密解密（Hutool-crypto）/04.对称加密-SymmetricCrypto.md",key:"v-8eb9d4fc",path:"/pages/SymmetricCrypto/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:24},{level:3,title:"通用使用",slug:"通用使用",normalizedTitle:"通用使用",charIndex:527},{level:3,title:"DESede实现",slug:"desede实现",normalizedTitle:"desede实现",charIndex:980},{level:3,title:"AES封装",slug:"aes封装",normalizedTitle:"aes封装",charIndex:1399},{level:3,title:"DES封装",slug:"des封装",normalizedTitle:"des封装",charIndex:2594},{level:3,title:"SM4",slug:"sm4",normalizedTitle:"sm4",charIndex:2961}],headersStr:"介绍 使用 通用使用 DESede实现 AES封装 DES封装 SM4",content:'# 介绍\n\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。\n\n对于对称加密，封装了JDK的，具体介绍见：https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyGenerator：\n\n * AES (默认AES/ECB/PKCS5Padding)\n * ARCFOUR\n * Blowfish\n * DES (默认DES/ECB/PKCS5Padding)\n * DESede\n * RC2\n * PBEWithMD5AndDES\n * PBEWithSHA1AndDESede\n * PBEWithSHA1AndRC2_40\n\n\n# 使用\n\n\n# 通用使用\n\n以AES算法为例：\n\nString content = "test中文";\n\n//随机生成密钥\nbyte[] key = SecureUtil.generateKey(SymmetricAlgorithm.AES.getValue()).getEncoded();\n\n//构建\nSymmetricCrypto aes = new SymmetricCrypto(SymmetricAlgorithm.AES, key);\n\n//加密\nbyte[] encrypt = aes.encrypt(content);\n//解密\nbyte[] decrypt = aes.decrypt(encrypt);\n\n//加密为16进制表示\nString encryptHex = aes.encryptHex(content);\n//解密为字符串\nString decryptStr = aes.decryptStr(encryptHex, CharsetUtil.CHARSET_UTF_8);\n\n\n\n# DESede实现\n\nString content = "test中文";\n\nbyte[] key = SecureUtil.generateKey(SymmetricAlgorithm.DESede.getValue()).getEncoded();\n\nSymmetricCrypto des = new SymmetricCrypto(SymmetricAlgorithm.DESede, key);\n\n//加密\nbyte[] encrypt = des.encrypt(content);\n//解密\nbyte[] decrypt = des.decrypt(encrypt);\n\n//加密为16进制字符串（Hex表示）\nString encryptHex = des.encryptHex(content);\n//解密为字符串\nString decryptStr = des.decryptStr(encryptHex);\n\n\n\n# AES封装\n\nAES全称高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法。\n\n对于Java中AES的默认模式是：AES/ECB/PKCS5Padding，如果使用CryptoJS，请调整为：padding: CryptoJS.pad.Pkcs7\n\n 1. 快速构建\n\nString content = "test中文";\n\n// 随机生成密钥\nbyte[] key = SecureUtil.generateKey(SymmetricAlgorithm.AES.getValue()).getEncoded();\n\n// 构建\nAES aes = SecureUtil.aes(key);\n\n// 加密\nbyte[] encrypt = aes.encrypt(content);\n// 解密\nbyte[] decrypt = aes.decrypt(encrypt);\n\n// 加密为16进制表示\nString encryptHex = aes.encryptHex(content);\n// 解密为字符串\nString decryptStr = aes.decryptStr(encryptHex, CharsetUtil.CHARSET_UTF_8);\n\n\n 2. 自定义内置模式和偏移\n\nAES aes = new AES(Mode.CTS, Padding.PKCS5Padding, "0CoJUm6Qyw8W8jud".getBytes(), "0102030405060708".getBytes());\n\n\n 3. PKCS7Padding模式\n\n由于IOS等移动端对AES加密有要求，必须为PKCS7Padding模式，但JDK本身并不提供这种模式，因此想要支持必须做一些工作。\n\n首先引入bc库：\n\n<dependency>\n\t<groupId>org.bouncycastle</groupId>\n\t<artifactId>bcprov-jdk15to18</artifactId>\n\t<version>1.68</version>\n</dependency>\n\n\nAES aes = new AES("CBC", "PKCS7Padding",\n  // 密钥，可以自定义\n  "0123456789ABHAEQ".getBytes(),\n  // iv加盐，按照实际需求添加\n  "DYgjCEIMVrj2W9xN".getBytes());\n\n// 加密为16进制表示\nString encryptHex = aes.encryptHex(content);\n// 解密\nString decryptStr = aes.decryptStr(encryptHex);\n\n\n\n# DES封装\n\nDES全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，Java中默认实现为：DES/CBC/PKCS5Padding\n\nDES使用方法与AES一致，构建方法为：\n\n 1. 快速构建\n\nbyte[] key = SecureUtil.generateKey(SymmetricAlgorithm.DES.getValue()).getEncoded();\nDES des = SecureUtil.des(key);\n\n\n 2. 自定义模式和偏移\n\nDES des = new DES(Mode.CTS, Padding.PKCS5Padding, "0CoJUm6Qyw8W8jud".getBytes(), "01020304".getBytes());\n\n\n\n# SM4\n\n在4.2.1之后，Hutool借助Bouncy Castle库可以支持国密算法，以SM4为例：\n\n我们首先需要引入Bouncy Castle库：\n\n<dependency>\n  <groupId>org.bouncycastle</groupId>\n  <artifactId>bcpkix-jdk15on</artifactId>\n  <version>1.60</version>\n</dependency>\n\n\n然后可以调用SM4算法，调用方法与其它算法一致：\n\nString content = "test中文";\nSymmetricCrypto sm4 = new SymmetricCrypto("SM4");\n\nString encryptHex = sm4.encryptHex(content);\nString decryptStr = sm4.decryptStr(encryptHex, CharsetUtil.CHARSET_UTF_8);//test中文\n\n\n同样我们可以指定加密模式和偏移：\n\nString content = "test中文";\nSymmetricCrypto sm4 = new SymmetricCrypto("SM4/ECB/PKCS5Padding");\n\nString encryptHex = sm4.encryptHex(content);\nString decryptStr = sm4.decryptStr(encryptHex, CharsetUtil.CHARSET_UTF_8);//test中文\n',normalizedContent:'# 介绍\n\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。\n\n对于对称加密，封装了jdk的，具体介绍见：https://docs.oracle.com/javase/7/docs/technotes/guides/security/standardnames.html#keygenerator：\n\n * aes (默认aes/ecb/pkcs5padding)\n * arcfour\n * blowfish\n * des (默认des/ecb/pkcs5padding)\n * desede\n * rc2\n * pbewithmd5anddes\n * pbewithsha1anddesede\n * pbewithsha1andrc2_40\n\n\n# 使用\n\n\n# 通用使用\n\n以aes算法为例：\n\nstring content = "test中文";\n\n//随机生成密钥\nbyte[] key = secureutil.generatekey(symmetricalgorithm.aes.getvalue()).getencoded();\n\n//构建\nsymmetriccrypto aes = new symmetriccrypto(symmetricalgorithm.aes, key);\n\n//加密\nbyte[] encrypt = aes.encrypt(content);\n//解密\nbyte[] decrypt = aes.decrypt(encrypt);\n\n//加密为16进制表示\nstring encrypthex = aes.encrypthex(content);\n//解密为字符串\nstring decryptstr = aes.decryptstr(encrypthex, charsetutil.charset_utf_8);\n\n\n\n# desede实现\n\nstring content = "test中文";\n\nbyte[] key = secureutil.generatekey(symmetricalgorithm.desede.getvalue()).getencoded();\n\nsymmetriccrypto des = new symmetriccrypto(symmetricalgorithm.desede, key);\n\n//加密\nbyte[] encrypt = des.encrypt(content);\n//解密\nbyte[] decrypt = des.decrypt(encrypt);\n\n//加密为16进制字符串（hex表示）\nstring encrypthex = des.encrypthex(content);\n//解密为字符串\nstring decryptstr = des.decryptstr(encrypthex);\n\n\n\n# aes封装\n\naes全称高级加密标准（英语：advanced encryption standard，缩写：aes），在密码学中又称rijndael加密法。\n\n对于java中aes的默认模式是：aes/ecb/pkcs5padding，如果使用cryptojs，请调整为：padding: cryptojs.pad.pkcs7\n\n 1. 快速构建\n\nstring content = "test中文";\n\n// 随机生成密钥\nbyte[] key = secureutil.generatekey(symmetricalgorithm.aes.getvalue()).getencoded();\n\n// 构建\naes aes = secureutil.aes(key);\n\n// 加密\nbyte[] encrypt = aes.encrypt(content);\n// 解密\nbyte[] decrypt = aes.decrypt(encrypt);\n\n// 加密为16进制表示\nstring encrypthex = aes.encrypthex(content);\n// 解密为字符串\nstring decryptstr = aes.decryptstr(encrypthex, charsetutil.charset_utf_8);\n\n\n 2. 自定义内置模式和偏移\n\naes aes = new aes(mode.cts, padding.pkcs5padding, "0cojum6qyw8w8jud".getbytes(), "0102030405060708".getbytes());\n\n\n 3. pkcs7padding模式\n\n由于ios等移动端对aes加密有要求，必须为pkcs7padding模式，但jdk本身并不提供这种模式，因此想要支持必须做一些工作。\n\n首先引入bc库：\n\n<dependency>\n\t<groupid>org.bouncycastle</groupid>\n\t<artifactid>bcprov-jdk15to18</artifactid>\n\t<version>1.68</version>\n</dependency>\n\n\naes aes = new aes("cbc", "pkcs7padding",\n  // 密钥，可以自定义\n  "0123456789abhaeq".getbytes(),\n  // iv加盐，按照实际需求添加\n  "dygjceimvrj2w9xn".getbytes());\n\n// 加密为16进制表示\nstring encrypthex = aes.encrypthex(content);\n// 解密\nstring decryptstr = aes.decryptstr(encrypthex);\n\n\n\n# des封装\n\ndes全称为data encryption standard，即数据加密标准，是一种使用密钥加密的块算法，java中默认实现为：des/cbc/pkcs5padding\n\ndes使用方法与aes一致，构建方法为：\n\n 1. 快速构建\n\nbyte[] key = secureutil.generatekey(symmetricalgorithm.des.getvalue()).getencoded();\ndes des = secureutil.des(key);\n\n\n 2. 自定义模式和偏移\n\ndes des = new des(mode.cts, padding.pkcs5padding, "0cojum6qyw8w8jud".getbytes(), "01020304".getbytes());\n\n\n\n# sm4\n\n在4.2.1之后，hutool借助bouncy castle库可以支持国密算法，以sm4为例：\n\n我们首先需要引入bouncy castle库：\n\n<dependency>\n  <groupid>org.bouncycastle</groupid>\n  <artifactid>bcpkix-jdk15on</artifactid>\n  <version>1.60</version>\n</dependency>\n\n\n然后可以调用sm4算法，调用方法与其它算法一致：\n\nstring content = "test中文";\nsymmetriccrypto sm4 = new symmetriccrypto("sm4");\n\nstring encrypthex = sm4.encrypthex(content);\nstring decryptstr = sm4.decryptstr(encrypthex, charsetutil.charset_utf_8);//test中文\n\n\n同样我们可以指定加密模式和偏移：\n\nstring content = "test中文";\nsymmetriccrypto sm4 = new symmetriccrypto("sm4/ecb/pkcs5padding");\n\nstring encrypthex = sm4.encrypthex(content);\nstring decryptstr = sm4.decryptstr(encrypthex, charsetutil.charset_utf_8);//test中文\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"摘要加密-Digester",frontmatter:{title:"摘要加密-Digester",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Digester/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/07.%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%EF%BC%88Hutool-crypto%EF%BC%89/05.%E6%91%98%E8%A6%81%E5%8A%A0%E5%AF%86-Digester.html",relativePath:"01.指南/07.加密解密（Hutool-crypto）/05.摘要加密-Digester.md",key:"v-a210187a",path:"/pages/Digester/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"摘要算法介绍",slug:"摘要算法介绍",normalizedTitle:"摘要算法介绍",charIndex:9},{level:2,title:"Hutool支持的摘要算法类型",slug:"hutool支持的摘要算法类型",normalizedTitle:"hutool支持的摘要算法类型",charIndex:288},{level:3,title:"摘要算法",slug:"摘要算法",normalizedTitle:"摘要算法",charIndex:9},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:504},{level:3,title:"Digester",slug:"digester",normalizedTitle:"digester",charIndex:511},{level:2,title:"更多摘要算法",slug:"更多摘要算法",normalizedTitle:"更多摘要算法",charIndex:803},{level:3,title:"SM3",slug:"sm3",normalizedTitle:"sm3",charIndex:814}],headersStr:"介绍 摘要算法介绍 Hutool支持的摘要算法类型 摘要算法 使用 Digester 更多摘要算法 SM3",content:'# 介绍\n\n\n# 摘要算法介绍\n\n摘要算法是一种能产生特殊输出格式的算法，这种算法的特点是：无论用户输入什么长度的原始数据，经过计算后输出的密文都是固定长度的，这种算法的原理是根据一定的运算规则对原数据进行某种形式的提取，这种提取就是摘要，被摘要的数据内容与原数据有密切联系，只要原数据稍有改变，输出的“摘要”便完全不同，因此，基于这种原理的算法便能对数据完整性提供较为健全的保障。\n\n但是，由于输出的密文是提取原数据经过处理的定长值，所以它已经不能还原为原数据，即消息摘要算法是不可逆的，理论上无法通过反向运算取得原数据内容，因此它通常只能被用来做数据完整性验证。\n\n\n# Hutool支持的摘要算法类型\n\n在不引入第三方库的情况下，JDK支持有限的摘要算法：\n\n详细见：https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#MessageDigest\n\n\n# 摘要算法\n\n * MD2\n * MD5\n * SHA-1\n * SHA-256\n * SHA-384\n * SHA-512\n\n\n# 使用\n\n\n# Digester\n\n以MD5为例：\n\nDigester md5 = new Digester(DigestAlgorithm.MD5);\n\n// 5393554e94bf0eb6436f240a4fd71282\nString digestHex = md5.digestHex(testStr);\n\n\n当然，做为最为常用的方法，MD5等方法被封装为工具方法在DigestUtil中，以上代码可以进一步简化为：\n\n// 5393554e94bf0eb6436f240a4fd71282\nString md5Hex1 = DigestUtil.md5Hex(testStr);\n\n\n\n# 更多摘要算法\n\n\n# SM3\n\n在4.2.1之后，Hutool借助Bouncy Castle库可以支持国密算法，以SM3为例：\n\n我们首先需要引入Bouncy Castle库：\n\n<dependency>\n  <groupId>org.bouncycastle</groupId>\n  <artifactId>bcprov-jdk15to18</artifactId>\n  <version>1.66</version>\n</dependency>\n\n\n然后可以调用SM3算法，调用方法与其它摘要算法一致：\n\nDigester digester = DigestUtil.digester("sm3");\n\n//136ce3c86e4ed909b76082055a61586af20b4dab674732ebd4b599eef080c9be\nString digestHex = digester.digestHex("aaaaa");\n\n\n> Java标准库的java.security包提供了一种标准机制，允许第三方提供商无缝接入。当引入Bouncy Castle库的jar后，Hutool会自动检测并接入。具体方法可见SecureUtil.createMessageDigest。',normalizedContent:'# 介绍\n\n\n# 摘要算法介绍\n\n摘要算法是一种能产生特殊输出格式的算法，这种算法的特点是：无论用户输入什么长度的原始数据，经过计算后输出的密文都是固定长度的，这种算法的原理是根据一定的运算规则对原数据进行某种形式的提取，这种提取就是摘要，被摘要的数据内容与原数据有密切联系，只要原数据稍有改变，输出的“摘要”便完全不同，因此，基于这种原理的算法便能对数据完整性提供较为健全的保障。\n\n但是，由于输出的密文是提取原数据经过处理的定长值，所以它已经不能还原为原数据，即消息摘要算法是不可逆的，理论上无法通过反向运算取得原数据内容，因此它通常只能被用来做数据完整性验证。\n\n\n# hutool支持的摘要算法类型\n\n在不引入第三方库的情况下，jdk支持有限的摘要算法：\n\n详细见：https://docs.oracle.com/javase/7/docs/technotes/guides/security/standardnames.html#messagedigest\n\n\n# 摘要算法\n\n * md2\n * md5\n * sha-1\n * sha-256\n * sha-384\n * sha-512\n\n\n# 使用\n\n\n# digester\n\n以md5为例：\n\ndigester md5 = new digester(digestalgorithm.md5);\n\n// 5393554e94bf0eb6436f240a4fd71282\nstring digesthex = md5.digesthex(teststr);\n\n\n当然，做为最为常用的方法，md5等方法被封装为工具方法在digestutil中，以上代码可以进一步简化为：\n\n// 5393554e94bf0eb6436f240a4fd71282\nstring md5hex1 = digestutil.md5hex(teststr);\n\n\n\n# 更多摘要算法\n\n\n# sm3\n\n在4.2.1之后，hutool借助bouncy castle库可以支持国密算法，以sm3为例：\n\n我们首先需要引入bouncy castle库：\n\n<dependency>\n  <groupid>org.bouncycastle</groupid>\n  <artifactid>bcprov-jdk15to18</artifactid>\n  <version>1.66</version>\n</dependency>\n\n\n然后可以调用sm3算法，调用方法与其它摘要算法一致：\n\ndigester digester = digestutil.digester("sm3");\n\n//136ce3c86e4ed909b76082055a61586af20b4dab674732ebd4b599eef080c9be\nstring digesthex = digester.digesthex("aaaaa");\n\n\n> java标准库的java.security包提供了一种标准机制，允许第三方提供商无缝接入。当引入bouncy castle库的jar后，hutool会自动检测并接入。具体方法可见secureutil.createmessagedigest。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"日志工厂-LogFactory",frontmatter:{title:"日志工厂-LogFactory",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/LogFactory/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/04.%E6%97%A5%E5%BF%97%EF%BC%88Hutool-log%EF%BC%89/02.%E6%97%A5%E5%BF%97%E5%B7%A5%E5%8E%82-LogFactory.html",relativePath:"01.指南/04.日志（Hutool-log）/02.日志工厂-LogFactory.md",key:"v-78db46f9",path:"/pages/LogFactory/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:22},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:443},{level:3,title:"获取当前类对应的Log对象：",slug:"获取当前类对应的log对象",normalizedTitle:"获取当前类对应的log对象：",charIndex:450},{level:3,title:"自定义日志实现",slug:"自定义日志实现",normalizedTitle:"自定义日志实现",charIndex:652},{level:3,title:"自定义日志工厂（自定义日志门面实现）",slug:"自定义日志工厂-自定义日志门面实现",normalizedTitle:"自定义日志工厂（自定义日志门面实现）",charIndex:925}],headersStr:"介绍 使用 获取当前类对应的Log对象： 自定义日志实现 自定义日志工厂（自定义日志门面实现）",content:'# 日志工厂-LogFactory\n\n\n# 介绍\n\nHutool-log做为一个日志门面，为了兼容各大日志框架，一个用于自动创建日志对象的日志工厂类必不可少。\n\nLogFactory类用于灵活的创建日志对象，通过static方法创建我们需要的日志对象，主要功能如下：\n\n * LogFactory.get 自动识别引入的日志框架，从而创建对应日志框架的门面Log对象（此方法创建一次后，下次再次get会根据传入类名缓存Log对象，对于每个类，Log对象都是单例的），同时自动识别当前类，将当前类做为类名传入日志框架。\n\n * LogFactory.createLog 与get方法作用类似。但是此方法调用后会每次创建一个新的Log对象。\n\n * LogFactory.setCurrentLogFactory 自定义当前日志门面的日志实现类。当引入多个日志框架时，我们希望自定义所用的日志框架，调用此方法即可。需要注意的是，此方法为全局方法，在获取Log对象前只调用一次即可。\n\n\n# 使用\n\n\n# 获取当前类对应的Log对象：\n\n//推荐创建不可变静态类成员变量\nprivate static final Log log = LogFactory.get();\n\n\n如果你想获得自定义name的Log对象（像普通Log日志实现一样），那么可以使用如下方式获取Log：\n\nprivate static final Log log = LogFactory.get("我是一个自定义日志名");\n\n\n\n# 自定义日志实现\n\n//自定义日志实现为Apache Commons Logging\nLogFactory.setCurrentLogFactory(new ApacheCommonsLogFactory());\n\n//自定义日志实现为JDK Logging\nLogFactory.setCurrentLogFactory(new JdkLogFactory());\n\n//自定义日志实现为Console Logging\nLogFactory.setCurrentLogFactory(new ConsoleLogFactory());\n\n\n\n# 自定义日志工厂（自定义日志门面实现）\n\nLogFactory是一个抽象类，我们可以继承此类，实现createLog方法即可（同时我们可能需要实现Log接口来达到自定义门面的目的），这样我们就可以自定义一个日志门面。最后通过LogFactory.setCurrentLogFactory方法装入这个自定义LogFactory即可实现自定义日志门面。\n\n> PS 自定义日志门面的实现可以参考cn.hutool.log.dialect包中的实现内容自定义扩展。 本质上，实现Log接口，做一个日志实现的Wrapper，然后在相应的工厂类中创建此Log实例即可。同时，LogFactory中还可以初始化一些启动配置参数。',normalizedContent:'# 日志工厂-logfactory\n\n\n# 介绍\n\nhutool-log做为一个日志门面，为了兼容各大日志框架，一个用于自动创建日志对象的日志工厂类必不可少。\n\nlogfactory类用于灵活的创建日志对象，通过static方法创建我们需要的日志对象，主要功能如下：\n\n * logfactory.get 自动识别引入的日志框架，从而创建对应日志框架的门面log对象（此方法创建一次后，下次再次get会根据传入类名缓存log对象，对于每个类，log对象都是单例的），同时自动识别当前类，将当前类做为类名传入日志框架。\n\n * logfactory.createlog 与get方法作用类似。但是此方法调用后会每次创建一个新的log对象。\n\n * logfactory.setcurrentlogfactory 自定义当前日志门面的日志实现类。当引入多个日志框架时，我们希望自定义所用的日志框架，调用此方法即可。需要注意的是，此方法为全局方法，在获取log对象前只调用一次即可。\n\n\n# 使用\n\n\n# 获取当前类对应的log对象：\n\n//推荐创建不可变静态类成员变量\nprivate static final log log = logfactory.get();\n\n\n如果你想获得自定义name的log对象（像普通log日志实现一样），那么可以使用如下方式获取log：\n\nprivate static final log log = logfactory.get("我是一个自定义日志名");\n\n\n\n# 自定义日志实现\n\n//自定义日志实现为apache commons logging\nlogfactory.setcurrentlogfactory(new apachecommonslogfactory());\n\n//自定义日志实现为jdk logging\nlogfactory.setcurrentlogfactory(new jdklogfactory());\n\n//自定义日志实现为console logging\nlogfactory.setcurrentlogfactory(new consolelogfactory());\n\n\n\n# 自定义日志工厂（自定义日志门面实现）\n\nlogfactory是一个抽象类，我们可以继承此类，实现createlog方法即可（同时我们可能需要实现log接口来达到自定义门面的目的），这样我们就可以自定义一个日志门面。最后通过logfactory.setcurrentlogfactory方法装入这个自定义logfactory即可实现自定义日志门面。\n\n> ps 自定义日志门面的实现可以参考cn.hutool.log.dialect包中的实现内容自定义扩展。 本质上，实现log接口，做一个日志实现的wrapper，然后在相应的工厂类中创建此log实例即可。同时，logfactory中还可以初始化一些启动配置参数。',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/crypto/index/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/07.%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%EF%BC%88Hutool-crypto%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/07.加密解密（Hutool-crypto）/01.概述.md",key:"v-300f8496",path:"/pages/crypto/index/",headers:[{level:2,title:"Hutool-crypto概述",slug:"hutool-crypto概述",normalizedTitle:"hutool-crypto概述",charIndex:2}],headersStr:"Hutool-crypto概述",content:"# Hutool-crypto概述\n\n加密分为三种：\n\n 1. 对称加密（symmetric），例如：AES、DES等\n 2. 非对称加密（asymmetric），例如：RSA、DSA等\n 3. 摘要加密（digest），例如：MD5、SHA-1、SHA-256、HMAC等\n\nhutool-crypto针对这三种加密类型分别封装，并提供常用的大部分加密算法。\n\n对于非对称加密，实现了：\n\n * RSA\n * DSA\n\n对于对称加密，实现了：\n\n * AES\n * ARCFOUR\n * Blowfish\n * DES\n * DESede\n * RC2\n * PBEWithMD5AndDES\n * PBEWithSHA1AndDESede\n * PBEWithSHA1AndRC2_40\n\n对于摘要算法实现了：\n\n * MD2\n * MD5\n * SHA-1\n * SHA-256\n * SHA-384\n * SHA-512\n * HmacMD5\n * HmacSHA1\n * HmacSHA256\n * HmacSHA384\n * HmacSHA512\n\n其中，针对常用到的算法，模块还提供SecureUtil工具类用于快速实现加密。\n\n关于各种加密方式的使用，请参阅后续章节。",normalizedContent:"# hutool-crypto概述\n\n加密分为三种：\n\n 1. 对称加密（symmetric），例如：aes、des等\n 2. 非对称加密（asymmetric），例如：rsa、dsa等\n 3. 摘要加密（digest），例如：md5、sha-1、sha-256、hmac等\n\nhutool-crypto针对这三种加密类型分别封装，并提供常用的大部分加密算法。\n\n对于非对称加密，实现了：\n\n * rsa\n * dsa\n\n对于对称加密，实现了：\n\n * aes\n * arcfour\n * blowfish\n * des\n * desede\n * rc2\n * pbewithmd5anddes\n * pbewithsha1anddesede\n * pbewithsha1andrc2_40\n\n对于摘要算法实现了：\n\n * md2\n * md5\n * sha-1\n * sha-256\n * sha-384\n * sha-512\n * hmacmd5\n * hmacsha1\n * hmacsha256\n * hmacsha384\n * hmacsha512\n\n其中，针对常用到的算法，模块还提供secureutil工具类用于快速实现加密。\n\n关于各种加密方式的使用，请参阅后续章节。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"消息认证码算法-HMac",frontmatter:{title:"消息认证码算法-HMac",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/HMac/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/07.%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%EF%BC%88Hutool-crypto%EF%BC%89/06.%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%E7%AE%97%E6%B3%95-HMac.html",relativePath:"01.指南/07.加密解密（Hutool-crypto）/06.消息认证码算法-HMac.md",key:"v-1bff50da",path:"/pages/HMac/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"HMAC介绍",slug:"hmac介绍",normalizedTitle:"hmac介绍",charIndex:9},{level:2,title:"Hutool支持的算法类型",slug:"hutool支持的算法类型",normalizedTitle:"hutool支持的算法类型",charIndex:220},{level:3,title:"Hmac算法",slug:"hmac算法",normalizedTitle:"hmac算法",charIndex:238},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:163},{level:3,title:"HMac",slug:"hmac",normalizedTitle:"hmac",charIndex:350},{level:2,title:"更多HMac算法",slug:"更多hmac算法",normalizedTitle:"更多hmac算法",charIndex:589}],headersStr:"介绍 HMAC介绍 Hutool支持的算法类型 Hmac算法 使用 HMac 更多HMac算法",content:'# 介绍\n\n\n# HMAC介绍\n\nHMAC，全称为“Hash Message Authentication Code”，中文名“散列消息鉴别码”，主要是利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。一般的，消息鉴别码用于验证传输于两个共同享有一个密钥的单位之间的消息。HMAC 可以与任何迭代散列函数捆绑使用。MD5 和 SHA-1 就是这种散列函数。HMAC 还可以使用一个用于计算和确认消息鉴别值的密钥。\n\n\n# Hutool支持的算法类型\n\n\n# Hmac算法\n\n在不引入第三方库的情况下，JDK支持有限的摘要算法：\n\n * HmacMD5\n * HmacSHA1\n * HmacSHA256\n * HmacSHA384\n * HmacSHA512\n\n\n# 使用\n\n\n# HMac\n\n以HmacMD5为例：\n\nString testStr = "test中文";\n\n// 此处密钥如果有非ASCII字符，考虑编码\nbyte[] key = "password".getBytes();\nHMac mac = new HMac(HmacAlgorithm.HmacMD5, key);\n\n// b977f4b13f93f549e06140971bded384\nString macHex1 = mac.digestHex(testStr);\n\n\n\n# 更多HMac算法\n\n与摘要算法类似，通过加入Bouncy Castle库可以调用更多算法，使用也类似：\n\nHMac mac = new HMac("XXXX", key);\n',normalizedContent:'# 介绍\n\n\n# hmac介绍\n\nhmac，全称为“hash message authentication code”，中文名“散列消息鉴别码”，主要是利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。一般的，消息鉴别码用于验证传输于两个共同享有一个密钥的单位之间的消息。hmac 可以与任何迭代散列函数捆绑使用。md5 和 sha-1 就是这种散列函数。hmac 还可以使用一个用于计算和确认消息鉴别值的密钥。\n\n\n# hutool支持的算法类型\n\n\n# hmac算法\n\n在不引入第三方库的情况下，jdk支持有限的摘要算法：\n\n * hmacmd5\n * hmacsha1\n * hmacsha256\n * hmacsha384\n * hmacsha512\n\n\n# 使用\n\n\n# hmac\n\n以hmacmd5为例：\n\nstring teststr = "test中文";\n\n// 此处密钥如果有非ascii字符，考虑编码\nbyte[] key = "password".getbytes();\nhmac mac = new hmac(hmacalgorithm.hmacmd5, key);\n\n// b977f4b13f93f549e06140971bded384\nstring machex1 = mac.digesthex(teststr);\n\n\n\n# 更多hmac算法\n\n与摘要算法类似，通过加入bouncy castle库可以调用更多算法，使用也类似：\n\nhmac mac = new hmac("xxxx", key);\n',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"签名和验证-Sign",frontmatter:{title:"签名和验证-Sign",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Sign/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/07.%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%EF%BC%88Hutool-crypto%EF%BC%89/07.%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E8%AF%81-Sign.html",relativePath:"01.指南/07.加密解密（Hutool-crypto）/07.签名和验证-Sign.md",key:"v-57c6ee20",path:"/pages/Sign/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:644}],headersStr:"介绍 使用",content:'# 介绍\n\nHutool针对java.security.Signature做了简化包装，包装类为：Sign，用于生成签名和签名验证。\n\n对于签名算法，Hutool封装了JDK的Signature，具体介绍见：https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Signature：\n\n// The RSA signature algorithm\nNONEwithRSA\n\n// The MD2/MD5 with RSA Encryption signature algorithm\nMD2withRSA\nMD5withRSA\n\n// The signature algorithm with SHA-* and the RSA\nSHA1withRSA\nSHA256withRSA\nSHA384withRSA\nSHA512withRSA\n\n// The Digital Signature Algorithm\nNONEwithDSA\n\n// The DSA with SHA-1 signature algorithm\nSHA1withDSA\n\n// The ECDSA signature algorithms\nNONEwithECDSA\nSHA1withECDSA\nSHA256withECDSA\nSHA384withECDSA\nSHA512withECDSA\n\n\n\n# 使用\n\nbyte[] data = "我是一段测试字符串".getBytes();\nSign sign = SecureUtil.sign(SignAlgorithm.MD5withRSA);\n//签名\nbyte[] signed = sign.sign(data);\n//验证签名\nboolean verify = sign.verify(data, signed);\n',normalizedContent:'# 介绍\n\nhutool针对java.security.signature做了简化包装，包装类为：sign，用于生成签名和签名验证。\n\n对于签名算法，hutool封装了jdk的signature，具体介绍见：https://docs.oracle.com/javase/7/docs/technotes/guides/security/standardnames.html#signature：\n\n// the rsa signature algorithm\nnonewithrsa\n\n// the md2/md5 with rsa encryption signature algorithm\nmd2withrsa\nmd5withrsa\n\n// the signature algorithm with sha-* and the rsa\nsha1withrsa\nsha256withrsa\nsha384withrsa\nsha512withrsa\n\n// the digital signature algorithm\nnonewithdsa\n\n// the dsa with sha-1 signature algorithm\nsha1withdsa\n\n// the ecdsa signature algorithms\nnonewithecdsa\nsha1withecdsa\nsha256withecdsa\nsha384withecdsa\nsha512withecdsa\n\n\n\n# 使用\n\nbyte[] data = "我是一段测试字符串".getbytes();\nsign sign = secureutil.sign(signalgorithm.md5withrsa);\n//签名\nbyte[] signed = sign.sign(data);\n//验证签名\nboolean verify = sign.verify(data, signed);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/db/index/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/09.数据库（Hutool-db）/01.概述.md",key:"v-76cd8bd2",path:"/pages/db/index/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"整体的架构",slug:"整体的架构",normalizedTitle:"整体的架构",charIndex:150},{level:3,title:"CRUD的封装 Db SqlConnRunner SqlRunner",slug:"crud的封装-db-sqlconnrunner-sqlrunner",normalizedTitle:"crud的封装 db sqlconnrunner sqlrunner",charIndex:490},{level:3,title:"各种结果集处理类 handler",slug:"各种结果集处理类-handler",normalizedTitle:"各种结果集处理类 handler",charIndex:278},{level:3,title:"数据库的一些工具方法汇总",slug:"数据库的一些工具方法汇总",normalizedTitle:"数据库的一些工具方法汇总",charIndex:299},{level:2,title:"对象解释",slug:"对象解释",normalizedTitle:"对象解释",charIndex:1045},{level:3,title:"1. Entity",slug:"_1-entity",normalizedTitle:"1. entity",charIndex:740},{level:3,title:"2. Table和Column",slug:"_2-table和column",normalizedTitle:"2. table和column",charIndex:1429}],headersStr:"由来 整体的架构 CRUD的封装 Db SqlConnRunner SqlRunner 各种结果集处理类 handler 数据库的一些工具方法汇总 对象解释 1. Entity 2. Table和Column",content:'# 由来\n\nHutool-db是一个在JDBC基础上封装的数据库操作工具类，通过包装，使用ActiveRecord思想操作数据库。在Hutool-db中，使用Entity（本质上是个Map）代替Bean来使数据库操作更加灵活，同时提供Bean和Entity的转换来提供传统ORM的兼容支持。\n\n\n# 整体的架构\n\n整体分为几部分:\n\n\n\n 1. 数据源 DataSource\n 2. SQL执行器 SqlExecutor\n 3. CRUD的封装 Db、SqlConnRunner SqlRunner\n 4. 支持事务的CRUD封装 Session\n 5. 各种结果集处理类 handler\n 6. 数据库的一些工具方法汇总 DbUtil\n\n还有就是没有列出来的dialect（数据库方言），我会根据给定的DataSource、Connection等对象自动识别是什么数据库，然后使用不同的方言构造SQL语句，暂时支持的数据库有MySQL、Oracle、SqlLite3，当然如果识别失败会用ANSI SQL，这样遇到不支持的数据库，也可以搞定大部分方法。\n\n下面解释下：\n\n\n# CRUD的封装 Db SqlConnRunner SqlRunner\n\n这两个类有些相似，里面都封装了增、删、改、查、分页、个数方法，差别是SqlConnRunner需要每个方法都传Connection对象，而SqlRunner继承自SqlConnRunner，在传入DataSource后会自动获取Connection对象。\n\n\n# 各种结果集处理类 handler\n\n此包中有个叫做RsHandler的接口，传入ResultSet对象，返回什么则在handle方法中自己指定。 实现的类有：\n\n 1. EntityListHandler 转换为Entity列表\n 2. NumberHandler 当使用select count(1)这类语句的时候，或者返回只有一个结果，且为数字结果的时候，用这个handler\n 3. EntityHandler 返回一条记录的时候用这个\n\n\n# 数据库的一些工具方法汇总\n\nDbUtil 提供一些工具方法，最常用的就是close方法了，由于JDK7才把ResultSet、Statement、PreparedStatement、Connection这几个接口实现了Closeable接口，所以之前只能判断类型再去关闭，这样一个close方法可以关闭多个对象。\n\n\n# 对象解释\n\n\n# 1. Entity\n\n在ORM中，我把一张表中的一条数据映射成为一个叫做Entity的类，继承自HashMap，key是字段名，value是Object类型，字段值，这样一个Entity对象就是数据库表中的一条记录，当然这个对象中还有个字段是表的名字，方便之后的操作。之后对数据库增删改查操作的对象大多是这个。\n\n这个对象充当着两种角色，一个是数据的载体，表示一条数据，另一个就是where语句的条件，充当where条件时，key依旧是字段名，value是字段条件值。例如：\n\nEntity where = Entity.create(TABLE_NAME).set("条件1", "条件值");\n\n\n表示的where语句是：\n\nWHERE `条件1` = 条件值\n\n\n当然到时候会用PreparedStatement，不会出现SQL注入。\n\n\n# 2. Table和Column\n\n这两个对象主要是描述数据库表结构的，暂时和ORM本身没啥关系，只是当你想获得一些字段信息的时候，这样来获得表结构信息：\n\n// 获得当前库的所有表的表名\nList<String> tableNames = MetaUtil.getTables(dataSource);\nLog.info("{}", tableNames);\n\n/*\n * 获得表结构 表结构封装为一个表对象，里面有Column对象表示一列，列中有列名、类型、大小、是否允许为空等信息\n */\nTable table = MetaUtil.getTableMeta(dataSource, TABLE_NAME);\nLog.info("{}", table);\n',normalizedContent:'# 由来\n\nhutool-db是一个在jdbc基础上封装的数据库操作工具类，通过包装，使用activerecord思想操作数据库。在hutool-db中，使用entity（本质上是个map）代替bean来使数据库操作更加灵活，同时提供bean和entity的转换来提供传统orm的兼容支持。\n\n\n# 整体的架构\n\n整体分为几部分:\n\n\n\n 1. 数据源 datasource\n 2. sql执行器 sqlexecutor\n 3. crud的封装 db、sqlconnrunner sqlrunner\n 4. 支持事务的crud封装 session\n 5. 各种结果集处理类 handler\n 6. 数据库的一些工具方法汇总 dbutil\n\n还有就是没有列出来的dialect（数据库方言），我会根据给定的datasource、connection等对象自动识别是什么数据库，然后使用不同的方言构造sql语句，暂时支持的数据库有mysql、oracle、sqllite3，当然如果识别失败会用ansi sql，这样遇到不支持的数据库，也可以搞定大部分方法。\n\n下面解释下：\n\n\n# crud的封装 db sqlconnrunner sqlrunner\n\n这两个类有些相似，里面都封装了增、删、改、查、分页、个数方法，差别是sqlconnrunner需要每个方法都传connection对象，而sqlrunner继承自sqlconnrunner，在传入datasource后会自动获取connection对象。\n\n\n# 各种结果集处理类 handler\n\n此包中有个叫做rshandler的接口，传入resultset对象，返回什么则在handle方法中自己指定。 实现的类有：\n\n 1. entitylisthandler 转换为entity列表\n 2. numberhandler 当使用select count(1)这类语句的时候，或者返回只有一个结果，且为数字结果的时候，用这个handler\n 3. entityhandler 返回一条记录的时候用这个\n\n\n# 数据库的一些工具方法汇总\n\ndbutil 提供一些工具方法，最常用的就是close方法了，由于jdk7才把resultset、statement、preparedstatement、connection这几个接口实现了closeable接口，所以之前只能判断类型再去关闭，这样一个close方法可以关闭多个对象。\n\n\n# 对象解释\n\n\n# 1. entity\n\n在orm中，我把一张表中的一条数据映射成为一个叫做entity的类，继承自hashmap，key是字段名，value是object类型，字段值，这样一个entity对象就是数据库表中的一条记录，当然这个对象中还有个字段是表的名字，方便之后的操作。之后对数据库增删改查操作的对象大多是这个。\n\n这个对象充当着两种角色，一个是数据的载体，表示一条数据，另一个就是where语句的条件，充当where条件时，key依旧是字段名，value是字段条件值。例如：\n\nentity where = entity.create(table_name).set("条件1", "条件值");\n\n\n表示的where语句是：\n\nwhere `条件1` = 条件值\n\n\n当然到时候会用preparedstatement，不会出现sql注入。\n\n\n# 2. table和column\n\n这两个对象主要是描述数据库表结构的，暂时和orm本身没啥关系，只是当你想获得一些字段信息的时候，这样来获得表结构信息：\n\n// 获得当前库的所有表的表名\nlist<string> tablenames = metautil.gettables(datasource);\nlog.info("{}", tablenames);\n\n/*\n * 获得表结构 表结构封装为一个表对象，里面有column对象表示一列，列中有列名、类型、大小、是否允许为空等信息\n */\ntable table = metautil.gettablemeta(datasource, table_name);\nlog.info("{}", table);\n',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"SQL执行器-SqlExecutor",frontmatter:{title:"SQL执行器-SqlExecutor",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/SqlExecutor/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89/02.SQL%E6%89%A7%E8%A1%8C%E5%99%A8-SqlExecutor.html",relativePath:"01.指南/09.数据库（Hutool-db）/02.SQL执行器-SqlExecutor.md",key:"v-5ac4680a",path:"/pages/SqlExecutor/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:61}],headersStr:"介绍 使用",content:'# 介绍\n\n这是一个静态类，对JDBC的薄封装，里面的静态方法只有两种：执行非查询的SQL语句和查询的SQL语句\n\n\n# 使用\n\nConnection conn = null;\ntry {\n\tconn = ds.getConnection();\n\t// 执行非查询语句，返回影响的行数\n\tint count = SqlExecutor.execute(conn, "UPDATE " + TABLE_NAME + " set field1 = ? where id = ?", 0, 0);\n\tlog.info("影响行数：{}", count);\n\t// 执行非查询语句，返回自增的键，如果有多个自增键，只返回第一个\n\tLong generatedKey = SqlExecutor.executeForGeneratedKey(conn, "UPDATE " + TABLE_NAME + " set field1 = ? where id = ?", 0, 0);\n\tlog.info("主键：{}", generatedKey);\n\n\t/* 执行查询语句，返回实体列表，一个Entity对象表示一行的数据，Entity对象是一个继承自HashMap的对象，存储的key为字段名，value为字段值 */\n\tList<Entity> entityList = SqlExecutor.query(conn, "select * from " + TABLE_NAME + " where param1 = ?", new EntityListHandler(), "值");\n\tlog.info("{}", entityList);\n} catch (SQLException e) {\n\tLog.error(log, e, "SQL error!");\n} finally {\n\tDbUtil.close(conn);\n}\n',normalizedContent:'# 介绍\n\n这是一个静态类，对jdbc的薄封装，里面的静态方法只有两种：执行非查询的sql语句和查询的sql语句\n\n\n# 使用\n\nconnection conn = null;\ntry {\n\tconn = ds.getconnection();\n\t// 执行非查询语句，返回影响的行数\n\tint count = sqlexecutor.execute(conn, "update " + table_name + " set field1 = ? where id = ?", 0, 0);\n\tlog.info("影响行数：{}", count);\n\t// 执行非查询语句，返回自增的键，如果有多个自增键，只返回第一个\n\tlong generatedkey = sqlexecutor.executeforgeneratedkey(conn, "update " + table_name + " set field1 = ? where id = ?", 0, 0);\n\tlog.info("主键：{}", generatedkey);\n\n\t/* 执行查询语句，返回实体列表，一个entity对象表示一行的数据，entity对象是一个继承自hashmap的对象，存储的key为字段名，value为字段值 */\n\tlist<entity> entitylist = sqlexecutor.query(conn, "select * from " + table_name + " where param1 = ?", new entitylisthandler(), "值");\n\tlog.info("{}", entitylist);\n} catch (sqlexception e) {\n\tlog.error(log, e, "sql error!");\n} finally {\n\tdbutil.close(conn);\n}\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"支持事务的CRUD-Session",frontmatter:{title:"支持事务的CRUD-Session",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Session/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89/03.%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E7%9A%84CRUD-Session.html",relativePath:"01.指南/09.数据库（Hutool-db）/03.支持事务的CRUD-Session.md",key:"v-2f953151",path:"/pages/Session/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"Session创建",slug:"session创建",normalizedTitle:"session创建",charIndex:137},{level:3,title:"事务CRUD",slug:"事务crud",normalizedTitle:"事务crud",charIndex:314}],headersStr:"介绍 Session创建 事务CRUD",content:'# 介绍\n\nSession非常类似于SqlRunner，差别是Session对象中只有一个Connection，所有操作也是用这个Connection，便于事务操作，而SqlRunner每执行一个方法都要从DataSource中去要Connection。样例如下：\n\n\n# Session创建\n\n与SqlRunner类似，Session也可以通过调用create\n\n//默认数据源\nSession session = Session.create();\n\n//自定义数据源（此处取test分组的数据源）\nSession session = Session.create(DSFactory.get("test"));\n\n\n\n# 事务CRUD\n\nsession.beginTransaction()表示事务开始，调用后每次执行语句将不被提交，只有调用commit方法后才会合并提交，提交或者回滚后会恢复默认的自动提交模式。\n\n 1. 新增\n\nEntity entity = Entity.create(TABLE_NAME).set("字段1", "值").set("字段2", 2);\ntry {\n\tsession.beginTransaction();\n\t// 增，生成SQL为 INSERT INTO `table_name` SET(`字段1`, `字段2`) VALUES(?,?)\n\tsession.insert(entity);\n\tsession.commit();\n} catch (SQLException e) {\n\tsession.quietRollback();\n}\n\n\n 2. 更新\n\nEntity entity = Entity.create(TABLE_NAME).set("字段1", "值").set("字段2", 2);\nEntity where = Entity.create(TABLE_NAME).set("条件1", "条件值");\ntry {\n\tsession.beginTransaction();\n\t// 改，生成SQL为 UPDATE `table_name` SET `字段1` = ?, `字段2` = ? WHERE `条件1` = ?\n\tsession.update(entity, where);\n\tsession.commit();\n} catch (SQLException e) {\n\tsession.quietRollback();\n}\n\n\n 3. 删除\n\nEntity where = Entity.create(TABLE_NAME).set("条件1", "条件值");\ntry {\n\tsession.beginTransaction();\n\t// 删，生成SQL为 DELETE FROM `table_name` WHERE `条件1` = ?\n\tsession.del(where);\n\tsession.commit();\n} catch (SQLException e) {\n\tsession.quietRollback();\n}\n',normalizedContent:'# 介绍\n\nsession非常类似于sqlrunner，差别是session对象中只有一个connection，所有操作也是用这个connection，便于事务操作，而sqlrunner每执行一个方法都要从datasource中去要connection。样例如下：\n\n\n# session创建\n\n与sqlrunner类似，session也可以通过调用create\n\n//默认数据源\nsession session = session.create();\n\n//自定义数据源（此处取test分组的数据源）\nsession session = session.create(dsfactory.get("test"));\n\n\n\n# 事务crud\n\nsession.begintransaction()表示事务开始，调用后每次执行语句将不被提交，只有调用commit方法后才会合并提交，提交或者回滚后会恢复默认的自动提交模式。\n\n 1. 新增\n\nentity entity = entity.create(table_name).set("字段1", "值").set("字段2", 2);\ntry {\n\tsession.begintransaction();\n\t// 增，生成sql为 insert into `table_name` set(`字段1`, `字段2`) values(?,?)\n\tsession.insert(entity);\n\tsession.commit();\n} catch (sqlexception e) {\n\tsession.quietrollback();\n}\n\n\n 2. 更新\n\nentity entity = entity.create(table_name).set("字段1", "值").set("字段2", 2);\nentity where = entity.create(table_name).set("条件1", "条件值");\ntry {\n\tsession.begintransaction();\n\t// 改，生成sql为 update `table_name` set `字段1` = ?, `字段2` = ? where `条件1` = ?\n\tsession.update(entity, where);\n\tsession.commit();\n} catch (sqlexception e) {\n\tsession.quietrollback();\n}\n\n\n 3. 删除\n\nentity where = entity.create(table_name).set("条件1", "条件值");\ntry {\n\tsession.begintransaction();\n\t// 删，生成sql为 delete from `table_name` where `条件1` = ?\n\tsession.del(where);\n\tsession.commit();\n} catch (sqlexception e) {\n\tsession.quietrollback();\n}\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"数据库简单操作-Db",frontmatter:{title:"数据库简单操作-Db",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Db/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89/04.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C-Db.html",relativePath:"01.指南/09.数据库（Hutool-db）/04.数据库简单操作-Db.md",key:"v-fcf54dac",path:"/pages/Db/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:63},{level:3,title:"1、添加配置文件",slug:"_1、添加配置文件",normalizedTitle:"1、添加配置文件",charIndex:230},{level:3,title:"2、引入MySQL JDBC驱动jar",slug:"_2、引入mysql-jdbc驱动jar",normalizedTitle:"2、引入mysql jdbc驱动jar",charIndex:559},{level:3,title:"3、增删改查",slug:"_3、增删改查",normalizedTitle:"3、增删改查",charIndex:788},{level:4,title:"增",slug:"增",normalizedTitle:"增",charIndex:19},{level:4,title:"删",slug:"删",normalizedTitle:"删",charIndex:20},{level:4,title:"改",slug:"改",normalizedTitle:"改",charIndex:21},{level:4,title:"查",slug:"查",normalizedTitle:"查",charIndex:22}],headersStr:"由来 使用 1、添加配置文件 2、引入MySQL JDBC驱动jar 3、增删改查 增 删 改 查",content:'# 由来\n\n数据库操作不外乎四门功课：增删改查，在Java的世界中，由于JDBC的存在，这项工作变得简单易用，但是也并没有做到使用上的简化。于是出现了JPA（Hibernate）、MyBatis、Jfinal、BeetlSQL等解决框架，或解决多数据库差异问题，或解决SQL维护问题。而Hutool对JDBC的封装，多数为在小型项目中对数据处理的简化，尤其只涉及单表操作时。OK，废话不多说，来个Demo感受下。\n\n\n# 使用\n\n我们以MySQL为例\n\n\n# 1、添加配置文件\n\nMaven项目中在src/main/resources目录下添加db.setting文件（非Maven项目添加到ClassPath中即可）：\n\n## db.setting文件\n\nurl = jdbc:mysql://localhost:3306/test\nuser = root\npass = 123456\n\n## 可选配置\n# 是否在日志中显示执行的SQL\nshowSql = true\n# 是否格式化显示的SQL\nformatSql = false\n# 是否显示SQL参数\nshowParams = true\n# 打印SQL的日志等级，默认debug，可以是info、warn、error\nsqlLevel = debug\n\n\n\n# 2、引入MySQL JDBC驱动jar\n\n\x3c!--mysql数据库驱动 --\x3e\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>${mysql.version}</version>\n</dependency>\n\n\n> 注意 此处不定义MySQL版本，请参考官方文档使用匹配的驱动包版本。\n\n\n# 3、增删改查\n\n# 增\n\nDb.use().insert(\n    Entity.create("user")\n    .set("name", "unitTestUser")\n    .set("age", 66)\n);\n\n\n插入数据并返回自增主键：\n\nDb.use().insertForGeneratedKey(\n    Entity.create("user")\n    .set("name", "unitTestUser")\n    .set("age", 66)\n);\n\n\n# 删\n\nDb.use().del(\n    Entity.create("user").set("name", "unitTestUser")//where条件\n);\n\n\n> 注意 考虑安全性，使用del方法时不允许使用空的where条件，防止全表删除，如有相关操作需要，请调用execute方法执行SQL实现。\n\n# 改\n\nDb.use().update(\n    Entity.create().set("age", 88), //修改的数据\n    Entity.create("user").set("name", "unitTestUser") //where条件\n);\n\n\n> 注意 条件语句除了可以用=精确匹配外，也可以范围条件匹配，例如表示 age < 12 可以这样构造Entity：Entity.create("user").set("age", "< 12")，但是通过Entity方式传入条件暂时不支持同字段多条件的情况。\n\n# 查\n\n 1. 查询全部字段\n\n//user为表名\nDb.use().findAll("user");\n\n\n 2. 条件查询\n\nDb.use().findAll(Entity.create("user").set("name", "unitTestUser"));\n\n\n 3. 模糊查询\n\nDb.use().findLike("user", "name", "Test", LikeType.Contains);\n\n\n或者：\n\nList<Entity> find = Db.use().find(Entity.create("user").set("name", "like 王%"));\n\n\n 4. 分页查询\n\n//Page对象通过传入页码和每页条目数达到分页目的\nPageResult<Entity> result = Db.use().page(Entity.create("user").set("age", "> 30"), new Page(10, 20));\n\n\n 5. 执行SQL语句\n\n//查询\nList<Entity> result = Db.use().query("select * from user where age < ?", 3);\n\n\n//模糊查询\nList<Entity> result = Db.use().query("select * from user where name like ?", "王%");\n\n\n//新增\nDb.use().execute("insert into user values (?, ?, ?)", "张三", 17, 1);\n\n\n//删除\nDb.use().execute("delete from user where name = ?", "张三");\n\n\n//更新\nDb.use().execute("update user set age = ? where name = ?", 3, "张三");\n\n\n 6. 事务\n\nDb.use().tx(new TxFunc() {\n    @Override\n    public void call(Db db) throws SQLException {\n        db.insert(Entity.create("user").set("name", "unitTestUser"));\n        db.update(Entity.create().set("age", 79), Entity.create("user").set("name", "unitTestUser"));\n    }\n});\n\n\nJDK8中可以用lambda表达式（since：5.x）：\n\nDb.use().tx(db -> {\n\tdb.insert(Entity.create("user").set("name", "unitTestUser2"));\n\tdb.update(Entity.create().set("age", 79), Entity.create("user").set("name", "unitTestUser2"));\n});\n\n\n 7. 支持命名占位符的SQL执行\n\n有时候使用?占位符比较繁琐，且在复杂SQL中很容易出错，Hutool支持使用命名占位符来执行SQL。\n\nMap<String, Object> paramMap = MapUtil.builder("name1", (Object)"张三").put("age", 12).put("subName", "小豆豆").build();\nDb.use().query("select * from table where id=@id and name = @name1 and nickName = @subName", paramMap);\n\n\n在Hutool中，占位符支持以下几种形式：\n\n * :name\n * ?name\n * @name\n\n 8. IN查询\n\n我们在执行类似于select * from user where id in 1,2,3这类SQL的时候，Hutool封装如下：\n\nList<Entity> results = db.findAll(\n    Entity.create("user")\n        .set("id", "in 1,2,3"));\n\n\n当然你也可以直接：\n\nList<Entity> results = db.findAll(\n    Entity.create("user")\n        .set("id", new long[]{1, 2, 3}));\n',normalizedContent:'# 由来\n\n数据库操作不外乎四门功课：增删改查，在java的世界中，由于jdbc的存在，这项工作变得简单易用，但是也并没有做到使用上的简化。于是出现了jpa（hibernate）、mybatis、jfinal、beetlsql等解决框架，或解决多数据库差异问题，或解决sql维护问题。而hutool对jdbc的封装，多数为在小型项目中对数据处理的简化，尤其只涉及单表操作时。ok，废话不多说，来个demo感受下。\n\n\n# 使用\n\n我们以mysql为例\n\n\n# 1、添加配置文件\n\nmaven项目中在src/main/resources目录下添加db.setting文件（非maven项目添加到classpath中即可）：\n\n## db.setting文件\n\nurl = jdbc:mysql://localhost:3306/test\nuser = root\npass = 123456\n\n## 可选配置\n# 是否在日志中显示执行的sql\nshowsql = true\n# 是否格式化显示的sql\nformatsql = false\n# 是否显示sql参数\nshowparams = true\n# 打印sql的日志等级，默认debug，可以是info、warn、error\nsqllevel = debug\n\n\n\n# 2、引入mysql jdbc驱动jar\n\n\x3c!--mysql数据库驱动 --\x3e\n<dependency>\n    <groupid>mysql</groupid>\n    <artifactid>mysql-connector-java</artifactid>\n    <version>${mysql.version}</version>\n</dependency>\n\n\n> 注意 此处不定义mysql版本，请参考官方文档使用匹配的驱动包版本。\n\n\n# 3、增删改查\n\n# 增\n\ndb.use().insert(\n    entity.create("user")\n    .set("name", "unittestuser")\n    .set("age", 66)\n);\n\n\n插入数据并返回自增主键：\n\ndb.use().insertforgeneratedkey(\n    entity.create("user")\n    .set("name", "unittestuser")\n    .set("age", 66)\n);\n\n\n# 删\n\ndb.use().del(\n    entity.create("user").set("name", "unittestuser")//where条件\n);\n\n\n> 注意 考虑安全性，使用del方法时不允许使用空的where条件，防止全表删除，如有相关操作需要，请调用execute方法执行sql实现。\n\n# 改\n\ndb.use().update(\n    entity.create().set("age", 88), //修改的数据\n    entity.create("user").set("name", "unittestuser") //where条件\n);\n\n\n> 注意 条件语句除了可以用=精确匹配外，也可以范围条件匹配，例如表示 age < 12 可以这样构造entity：entity.create("user").set("age", "< 12")，但是通过entity方式传入条件暂时不支持同字段多条件的情况。\n\n# 查\n\n 1. 查询全部字段\n\n//user为表名\ndb.use().findall("user");\n\n\n 2. 条件查询\n\ndb.use().findall(entity.create("user").set("name", "unittestuser"));\n\n\n 3. 模糊查询\n\ndb.use().findlike("user", "name", "test", liketype.contains);\n\n\n或者：\n\nlist<entity> find = db.use().find(entity.create("user").set("name", "like 王%"));\n\n\n 4. 分页查询\n\n//page对象通过传入页码和每页条目数达到分页目的\npageresult<entity> result = db.use().page(entity.create("user").set("age", "> 30"), new page(10, 20));\n\n\n 5. 执行sql语句\n\n//查询\nlist<entity> result = db.use().query("select * from user where age < ?", 3);\n\n\n//模糊查询\nlist<entity> result = db.use().query("select * from user where name like ?", "王%");\n\n\n//新增\ndb.use().execute("insert into user values (?, ?, ?)", "张三", 17, 1);\n\n\n//删除\ndb.use().execute("delete from user where name = ?", "张三");\n\n\n//更新\ndb.use().execute("update user set age = ? where name = ?", 3, "张三");\n\n\n 6. 事务\n\ndb.use().tx(new txfunc() {\n    @override\n    public void call(db db) throws sqlexception {\n        db.insert(entity.create("user").set("name", "unittestuser"));\n        db.update(entity.create().set("age", 79), entity.create("user").set("name", "unittestuser"));\n    }\n});\n\n\njdk8中可以用lambda表达式（since：5.x）：\n\ndb.use().tx(db -> {\n\tdb.insert(entity.create("user").set("name", "unittestuser2"));\n\tdb.update(entity.create().set("age", 79), entity.create("user").set("name", "unittestuser2"));\n});\n\n\n 7. 支持命名占位符的sql执行\n\n有时候使用?占位符比较繁琐，且在复杂sql中很容易出错，hutool支持使用命名占位符来执行sql。\n\nmap<string, object> parammap = maputil.builder("name1", (object)"张三").put("age", 12).put("subname", "小豆豆").build();\ndb.use().query("select * from table where id=@id and name = @name1 and nickname = @subname", parammap);\n\n\n在hutool中，占位符支持以下几种形式：\n\n * :name\n * ?name\n * @name\n\n 8. in查询\n\n我们在执行类似于select * from user where id in 1,2,3这类sql的时候，hutool封装如下：\n\nlist<entity> results = db.findall(\n    entity.create("user")\n        .set("id", "in 1,2,3"));\n\n\n当然你也可以直接：\n\nlist<entity> results = db.findall(\n    entity.create("user")\n        .set("id", new long[]{1, 2, 3}));\n',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"JSON对象-JSONObject",frontmatter:{title:"JSON对象-JSONObject",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/JSONObject/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/06.JSON%EF%BC%88Hutool-json%EF%BC%89/03.JSON%E5%AF%B9%E8%B1%A1-JSONObject.html",relativePath:"01.指南/06.JSON（Hutool-json）/03.JSON对象-JSONObject.md",key:"v-41e2f6ee",path:"/pages/JSONObject/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:47},{level:3,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:175},{level:3,title:"转换",slug:"转换",normalizedTitle:"转换",charIndex:389}],headersStr:"介绍 使用 创建 转换",content:'# 介绍\n\nJSONObject代表一个JSON中的键值对象，这个对象以大括号包围，每个键值对使用,隔开，键与值使用:隔开，一个JSONObject类似于这样：\n\n{\n  "key1":"value1",\n  "key2":"value2"\n}\n\n\n此处键部分可以省略双引号，值为字符串时不能省略，为数字或布尔值时不加双引号。\n\n\n# 使用\n\n\n# 创建\n\nJSONObject json1 = JSONUtil.createObj()\n  .put("a", "value1")\n  .put("b", "value2")\n  .put("c", "value3");\n\n\nJSONUtil.createObj()是快捷新建JSONObject的工具方法，同样我们可以直接new：\n\nJSONObject json1 = new JSONObject();\n...\n\n\n\n# 转换\n\n 1. JSON字符串解析\n\nString jsonStr = "{\\"b\\":\\"value2\\",\\"c\\":\\"value3\\",\\"a\\":\\"value1\\"}";\n//方法一：使用工具类转换\nJSONObject jsonObject = JSONUtil.parseObj(jsonStr);\n//方法二：new的方式转换\nJSONObject jsonObject2 = new JSONObject(jsonStr);\n\n//JSON对象转字符串（一行）\njsonObject.toString();\n\n// 也可以美化一下，即显示出带缩进的JSON：\njsonObject.toStringPretty();\n\n\n 2. JavaBean解析\n\n首先我们定义一个Bean\n\n// 注解使用Lombok\n@Data\npublic class UserA {\n\tprivate String name;\n\tprivate String a;\n\tprivate Date date;\n\tprivate List<Seq> sqs;\n}\n\n\n解析为JSON：\n\nUserA userA = new UserA();\nuserA.setName("nameTest");\nuserA.setDate(new Date());\nuserA.setSqs(CollectionUtil.newArrayList(new Seq(null), new Seq("seq2")));\n\n// false表示不跳过空值\nJSONObject json = JSONUtil.parseObj(userA, false);\nConsole.log(json.toStringPretty());\n\n\n结果：\n\n{\n    "date": 1585618492295,\n    "a": null,\n    "sqs": [\n        {\n            "seq": null\n        },\n        {\n            "seq": "seq2"\n        }\n    ],\n    "name": "nameTest"\n}\n\n\n可以看到，输出的字段顺序和Bean的字段顺序不一致，如果想保持一致，可以：\n\n// 第二个参数表示保持有序\nJSONObject json = JSONUtil.parseObj(userA, false, true);\n\n\n结果：\n\n{\n    "name": "nameTest",\n    "a": null,\n    "date": 1585618648523,\n    "sqs": [\n        {\n            "seq": null\n        },\n        {\n            "seq": "seq2"\n        }\n    ]\n}\n\n\n默认的，Hutool将日期输出为时间戳，如果需要自定义日期格式，可以调用：\n\njson.setDateFormat("yyyy-MM-dd HH:mm:ss");\n\n\n得到结果为：\n\n{\n    "name": "nameTest",\n    "a": null,\n    "date": "2020-03-31 09:41:29",\n    "sqs": [\n        {\n            "seq": null\n        },\n        {\n            "seq": "seq2"\n        }\n    ]\n}\n',normalizedContent:'# 介绍\n\njsonobject代表一个json中的键值对象，这个对象以大括号包围，每个键值对使用,隔开，键与值使用:隔开，一个jsonobject类似于这样：\n\n{\n  "key1":"value1",\n  "key2":"value2"\n}\n\n\n此处键部分可以省略双引号，值为字符串时不能省略，为数字或布尔值时不加双引号。\n\n\n# 使用\n\n\n# 创建\n\njsonobject json1 = jsonutil.createobj()\n  .put("a", "value1")\n  .put("b", "value2")\n  .put("c", "value3");\n\n\njsonutil.createobj()是快捷新建jsonobject的工具方法，同样我们可以直接new：\n\njsonobject json1 = new jsonobject();\n...\n\n\n\n# 转换\n\n 1. json字符串解析\n\nstring jsonstr = "{\\"b\\":\\"value2\\",\\"c\\":\\"value3\\",\\"a\\":\\"value1\\"}";\n//方法一：使用工具类转换\njsonobject jsonobject = jsonutil.parseobj(jsonstr);\n//方法二：new的方式转换\njsonobject jsonobject2 = new jsonobject(jsonstr);\n\n//json对象转字符串（一行）\njsonobject.tostring();\n\n// 也可以美化一下，即显示出带缩进的json：\njsonobject.tostringpretty();\n\n\n 2. javabean解析\n\n首先我们定义一个bean\n\n// 注解使用lombok\n@data\npublic class usera {\n\tprivate string name;\n\tprivate string a;\n\tprivate date date;\n\tprivate list<seq> sqs;\n}\n\n\n解析为json：\n\nusera usera = new usera();\nusera.setname("nametest");\nusera.setdate(new date());\nusera.setsqs(collectionutil.newarraylist(new seq(null), new seq("seq2")));\n\n// false表示不跳过空值\njsonobject json = jsonutil.parseobj(usera, false);\nconsole.log(json.tostringpretty());\n\n\n结果：\n\n{\n    "date": 1585618492295,\n    "a": null,\n    "sqs": [\n        {\n            "seq": null\n        },\n        {\n            "seq": "seq2"\n        }\n    ],\n    "name": "nametest"\n}\n\n\n可以看到，输出的字段顺序和bean的字段顺序不一致，如果想保持一致，可以：\n\n// 第二个参数表示保持有序\njsonobject json = jsonutil.parseobj(usera, false, true);\n\n\n结果：\n\n{\n    "name": "nametest",\n    "a": null,\n    "date": 1585618648523,\n    "sqs": [\n        {\n            "seq": null\n        },\n        {\n            "seq": "seq2"\n        }\n    ]\n}\n\n\n默认的，hutool将日期输出为时间戳，如果需要自定义日期格式，可以调用：\n\njson.setdateformat("yyyy-mm-dd hh:mm:ss");\n\n\n得到结果为：\n\n{\n    "name": "nametest",\n    "a": null,\n    "date": "2020-03-31 09:41:29",\n    "sqs": [\n        {\n            "seq": null\n        },\n        {\n            "seq": "seq2"\n        }\n    ]\n}\n',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"数据源工厂-DsFactory",frontmatter:{title:"数据源工厂-DsFactory",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/DsFactory/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89/05.%E6%95%B0%E6%8D%AE%E6%BA%90%E5%B7%A5%E5%8E%82-DsFactory.html",relativePath:"01.指南/09.数据库（Hutool-db）/05.数据源工厂-DsFactory.md",key:"v-07a84ac0",path:"/pages/DsFactory/",headers:[{level:2,title:"释义",slug:"释义",normalizedTitle:"释义",charIndex:2},{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:563},{level:3,title:"1. 引入连接池的jar",slug:"_1-引入连接池的jar",normalizedTitle:"1. 引入连接池的jar",charIndex:572},{level:3,title:"2. 编写配置文件",slug:"_2-编写配置文件",normalizedTitle:"2. 编写配置文件",charIndex:646},{level:4,title:"1. 基本连接信息",slug:"_1-基本连接信息",normalizedTitle:"1. 基本连接信息",charIndex:771},{level:4,title:"2. 连接池特有配置信息",slug:"_2-连接池特有配置信息",normalizedTitle:"2. 连接池特有配置信息",charIndex:1097},{level:3,title:"3. 获取数据源",slug:"_3-获取数据源",normalizedTitle:"3. 获取数据源",charIndex:1756},{level:3,title:"4. 直接创建数据源",slug:"_4-直接创建数据源",normalizedTitle:"4. 直接创建数据源",charIndex:1877},{level:3,title:"5. 创建简单数据源",slug:"_5-创建简单数据源",normalizedTitle:"5. 创建简单数据源",charIndex:2101},{level:2,title:"高级实用",slug:"高级实用",normalizedTitle:"高级实用",charIndex:2432},{level:3,title:"1. 自定义连接池",slug:"_1-自定义连接池",normalizedTitle:"1. 自定义连接池",charIndex:2441},{level:3,title:"2. 自定义配置文件",slug:"_2-自定义配置文件",normalizedTitle:"2. 自定义配置文件",charIndex:2682},{level:3,title:"3. 多数据源",slug:"_3-多数据源",normalizedTitle:"3. 多数据源",charIndex:3009},{level:4,title:"1. 多个配置文件分别获得数据源",slug:"_1-多个配置文件分别获得数据源",normalizedTitle:"1. 多个配置文件分别获得数据源",charIndex:3110},{level:4,title:"2. 在同一配置文件中使用分组隔离不同的数据源配置：",slug:"_2-在同一配置文件中使用分组隔离不同的数据源配置",normalizedTitle:"2. 在同一配置文件中使用分组隔离不同的数据源配置：",charIndex:3157},{level:2,title:"结语",slug:"结语",normalizedTitle:"结语",charIndex:3520}],headersStr:"释义 基本使用 1. 引入连接池的jar 2. 编写配置文件 1. 基本连接信息 2. 连接池特有配置信息 3. 获取数据源 4. 直接创建数据源 5. 创建简单数据源 高级实用 1. 自定义连接池 2. 自定义配置文件 3. 多数据源 1. 多个配置文件分别获得数据源 2. 在同一配置文件中使用分组隔离不同的数据源配置： 结语",content:'# 释义\n\n数据源（DataSource）的概念来自于JDBC规范中，一个数据源表示针对一个数据库（或者集群）的描述，从数据源中我们可以获得N个数据库连接，从而对数据库进行操作。\n\n每一个开源JDBC连接池都有对DataSource的实现，比如Druid为DruidDataSource，Hikari为HikariDataSource。但是各大连接池配置各不相同，配置文件也不一样，Hutool的针对常用的连接池做了封装，最大限度简化和提供一致性配置。\n\nHutool的解决方案是：在ClassPath中使用config/db.setting一个配置文件，配置所有种类连接池的数据源，然后使用DsFactory.get()方法自动识别数据源以及自动注入配置文件中的连接池配置（包括数据库连接配置）。DsFactory通过try的方式按照顺序检测项目中引入的jar包来甄别用户使用的是哪种连接池，从而自动构建相应的数据源。\n\nHutool支持以下连接池，并按照其顺序检测存在与否：\n\n 1. HikariCP\n 2. Druid\n 3. Tomcat\n 4. Dbcp\n 5. C3p0\n\n在没有引入任何连接池的情况下，Hutool会使用其内置的连接池：Hutool Pooled（简易连接池，不推荐在线上环境使用）。\n\n\n# 基本使用\n\n\n# 1. 引入连接池的jar\n\nHutool不会强依赖于任何第三方库，在Hutool支持的连接池范围内，用户需自行选择自己喜欢的连接池并引入。\n\n\n# 2. 编写配置文件\n\nMaven项目中，在src/main/resources/config下创建文件db.setting，编写配置文件即可。这个配置文件位置就是Hutool与用户间的一个约定（符合约定大于配置的原则）：\n\n配置文件分为两部分\n\n# 1. 基本连接信息\n\n## 基本配置信息\n# JDBC URL，根据不同的数据库，使用相应的JDBC连接字符串\nurl = jdbc:mysql://<host>:<port>/<database_name>\n# 用户名，此处也可以使用 user 代替\nusername = 用户名\n# 密码，此处也可以使用 pass 代替\npassword = 密码\n# JDBC驱动名，可选（Hutool会自动识别）\ndriver = com.mysql.jdbc.Driver\n\n\n> 小提示 其中driver是可选的，Hutool会根据url自动加载相应的Driver类。基本连接信息是所有连接池通用的，原则上，只有基本信息就可以成功连接并操作数据库。\n\n# 2. 连接池特有配置信息\n\n针对不同的连接池，除了基本信息外的配置都各不相同，Hutool针对不同的连接池封装了其配置项，可以在项目的src/test/resources/example中看到针对不同连接池的配置文件样例。\n\n我们以HikariCP为例：\n\n# 自动提交\nautoCommit = true\n# 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 缺省:30秒\nconnectionTimeout = 30000\n# 一个连接idle状态的最大时长（毫秒），超时则被释放（retired），缺省:10分钟\nidleTimeout = 600000\n# 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考MySQL wait_timeout参数（show variables like \'%timeout%\';）\nmaxLifetime = 1800000\n# 获取连接前的测试SQL\nconnectionTestQuery = SELECT 1\n# 最小闲置连接数\nminimumIdle = 10\n# 连接池中允许的最大连接数。缺省值：10；推荐的公式：((core_count * 2) + effective_spindle_count)\nmaximumPoolSize = 10\n# 连接只读数据库时配置为true， 保证安全\nreadOnly = false\n\n\n\n# 3. 获取数据源\n\n//获取默认数据源\nDataSource ds = DSFactory.get()\n\n\n是滴，就是这么简单，一个简单的方法，可以识别数据源并读取默认路径(config/db.setting)下信息从而获取数据源。\n\n\n# 4. 直接创建数据源\n\n当然你依旧可以按照连接池本身的方式获取数据源对象。我们以Druid为例：\n\n//具体的配置参数请参阅Druid官方文档\nDruidDataSource ds2 = new DruidDataSource();\nds2.setUrl("jdbc:mysql://localhost:3306/dbName");\nds2.setUsername("root");\nds2.setPassword("123456");\n\n\n\n# 5. 创建简单数据源\n\n有时候我们的操作非常简单，亦或者只是测试下远程数据库是否畅通，我们可以使用Hutool提供的SimpleDataSource:\n\nDataSource ds = new SimpleDataSource("jdbc:mysql://localhost:3306/dbName", "root", "123456");\n\n\nSimpleDataSource只是DriverManager.getConnection的简单包装，本身并不支持池化功能，此类特别适合少量数据库连接的操作。\n\n同样的，SimpleDataSource也支持默认配置文件：\n\nDataSource ds = new SimpleDataSource();\n\n\n\n# 高级实用\n\n\n# 1. 自定义连接池\n\n有时候当项目引入多种数据源时，我们希望自定义需要的连接池，此时可以：\n\n//自定义连接池实现为Tomcat-pool\nDSFactory.setCurrentDSFactory(new TomcatDSFactory());\nDataSource ds = DSFactory.get();\n\n\n需要注意的是，DSFactory.setCurrentDSFactory是一个全局方法，必须在所有获取数据源的时机之前调用，调用一次即可（例如项目启动）。\n\n\n# 2. 自定义配置文件\n\n有时候由于项目规划的问题，我们希望自定义数据库配置Setting的位置，甚至是动态加载Setting对象，此时我们可以使用以下方法从其它的Setting对象中获取数据库连接信息：\n\n//自定义数据库Setting，更多实用请参阅Hutool-Setting章节\nSetting setting = new Setting("otherPath/other.setting");\n//获取指定配置，第二个参数为分组，用于多数据源，无分组情况下传null\n// 注意此处DSFactory需要复用或者关闭\nDataSource ds = DSFactory.create(setting).getDataSource();\n\n\n\n# 3. 多数据源\n\n有的时候我们需要操作不同的数据库，也有可能我们需要针对线上、开发和测试分别操作其数据库，无论哪种情况，Hutool都针对多数据源做了很棒的支持。\n\n多数据源有两种方式可以实现：\n\n# 1. 多个配置文件分别获得数据源\n\n就是按照自定义配置文件的方式读取多个配置文件即可。\n\n# 2. 在同一配置文件中使用分组隔离不同的数据源配置：\n\n[group_db1]\nurl = jdbc:mysql://<host>:<port>/<database_name>\nusername = 用户名\npassword = 密码\n\n[group_db2]\nurl = jdbc:mysql://<host2>:<port>/<database_name>\nusername = 用户名\npassword = 密码\n\n\n我们按照上面的方式编写db.setting文件，然后：\n\nDataSource ds1 = DSFactory.get("group_db1");\nDataSource ds2 = DSFactory.get("group_db2");\n\n\n这样我们就可以在一个配置文件中实现多数据源的配置。\n\n\n# 结语\n\nHutool通过多种方式获取DataSource对象，获取后除了可以在Hutool自身应用外，还可以将此对象传入不同的框架以实现无缝结合。\n\nHutool对数据源的封装很好的诠释了以下几个原则：\n\n 1. 自动识别优于用户定义\n 2. 便捷性与灵活性并存\n 3. 适配与兼容',normalizedContent:'# 释义\n\n数据源（datasource）的概念来自于jdbc规范中，一个数据源表示针对一个数据库（或者集群）的描述，从数据源中我们可以获得n个数据库连接，从而对数据库进行操作。\n\n每一个开源jdbc连接池都有对datasource的实现，比如druid为druiddatasource，hikari为hikaridatasource。但是各大连接池配置各不相同，配置文件也不一样，hutool的针对常用的连接池做了封装，最大限度简化和提供一致性配置。\n\nhutool的解决方案是：在classpath中使用config/db.setting一个配置文件，配置所有种类连接池的数据源，然后使用dsfactory.get()方法自动识别数据源以及自动注入配置文件中的连接池配置（包括数据库连接配置）。dsfactory通过try的方式按照顺序检测项目中引入的jar包来甄别用户使用的是哪种连接池，从而自动构建相应的数据源。\n\nhutool支持以下连接池，并按照其顺序检测存在与否：\n\n 1. hikaricp\n 2. druid\n 3. tomcat\n 4. dbcp\n 5. c3p0\n\n在没有引入任何连接池的情况下，hutool会使用其内置的连接池：hutool pooled（简易连接池，不推荐在线上环境使用）。\n\n\n# 基本使用\n\n\n# 1. 引入连接池的jar\n\nhutool不会强依赖于任何第三方库，在hutool支持的连接池范围内，用户需自行选择自己喜欢的连接池并引入。\n\n\n# 2. 编写配置文件\n\nmaven项目中，在src/main/resources/config下创建文件db.setting，编写配置文件即可。这个配置文件位置就是hutool与用户间的一个约定（符合约定大于配置的原则）：\n\n配置文件分为两部分\n\n# 1. 基本连接信息\n\n## 基本配置信息\n# jdbc url，根据不同的数据库，使用相应的jdbc连接字符串\nurl = jdbc:mysql://<host>:<port>/<database_name>\n# 用户名，此处也可以使用 user 代替\nusername = 用户名\n# 密码，此处也可以使用 pass 代替\npassword = 密码\n# jdbc驱动名，可选（hutool会自动识别）\ndriver = com.mysql.jdbc.driver\n\n\n> 小提示 其中driver是可选的，hutool会根据url自动加载相应的driver类。基本连接信息是所有连接池通用的，原则上，只有基本信息就可以成功连接并操作数据库。\n\n# 2. 连接池特有配置信息\n\n针对不同的连接池，除了基本信息外的配置都各不相同，hutool针对不同的连接池封装了其配置项，可以在项目的src/test/resources/example中看到针对不同连接池的配置文件样例。\n\n我们以hikaricp为例：\n\n# 自动提交\nautocommit = true\n# 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生sqlexception， 缺省:30秒\nconnectiontimeout = 30000\n# 一个连接idle状态的最大时长（毫秒），超时则被释放（retired），缺省:10分钟\nidletimeout = 600000\n# 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考mysql wait_timeout参数（show variables like \'%timeout%\';）\nmaxlifetime = 1800000\n# 获取连接前的测试sql\nconnectiontestquery = select 1\n# 最小闲置连接数\nminimumidle = 10\n# 连接池中允许的最大连接数。缺省值：10；推荐的公式：((core_count * 2) + effective_spindle_count)\nmaximumpoolsize = 10\n# 连接只读数据库时配置为true， 保证安全\nreadonly = false\n\n\n\n# 3. 获取数据源\n\n//获取默认数据源\ndatasource ds = dsfactory.get()\n\n\n是滴，就是这么简单，一个简单的方法，可以识别数据源并读取默认路径(config/db.setting)下信息从而获取数据源。\n\n\n# 4. 直接创建数据源\n\n当然你依旧可以按照连接池本身的方式获取数据源对象。我们以druid为例：\n\n//具体的配置参数请参阅druid官方文档\ndruiddatasource ds2 = new druiddatasource();\nds2.seturl("jdbc:mysql://localhost:3306/dbname");\nds2.setusername("root");\nds2.setpassword("123456");\n\n\n\n# 5. 创建简单数据源\n\n有时候我们的操作非常简单，亦或者只是测试下远程数据库是否畅通，我们可以使用hutool提供的simpledatasource:\n\ndatasource ds = new simpledatasource("jdbc:mysql://localhost:3306/dbname", "root", "123456");\n\n\nsimpledatasource只是drivermanager.getconnection的简单包装，本身并不支持池化功能，此类特别适合少量数据库连接的操作。\n\n同样的，simpledatasource也支持默认配置文件：\n\ndatasource ds = new simpledatasource();\n\n\n\n# 高级实用\n\n\n# 1. 自定义连接池\n\n有时候当项目引入多种数据源时，我们希望自定义需要的连接池，此时可以：\n\n//自定义连接池实现为tomcat-pool\ndsfactory.setcurrentdsfactory(new tomcatdsfactory());\ndatasource ds = dsfactory.get();\n\n\n需要注意的是，dsfactory.setcurrentdsfactory是一个全局方法，必须在所有获取数据源的时机之前调用，调用一次即可（例如项目启动）。\n\n\n# 2. 自定义配置文件\n\n有时候由于项目规划的问题，我们希望自定义数据库配置setting的位置，甚至是动态加载setting对象，此时我们可以使用以下方法从其它的setting对象中获取数据库连接信息：\n\n//自定义数据库setting，更多实用请参阅hutool-setting章节\nsetting setting = new setting("otherpath/other.setting");\n//获取指定配置，第二个参数为分组，用于多数据源，无分组情况下传null\n// 注意此处dsfactory需要复用或者关闭\ndatasource ds = dsfactory.create(setting).getdatasource();\n\n\n\n# 3. 多数据源\n\n有的时候我们需要操作不同的数据库，也有可能我们需要针对线上、开发和测试分别操作其数据库，无论哪种情况，hutool都针对多数据源做了很棒的支持。\n\n多数据源有两种方式可以实现：\n\n# 1. 多个配置文件分别获得数据源\n\n就是按照自定义配置文件的方式读取多个配置文件即可。\n\n# 2. 在同一配置文件中使用分组隔离不同的数据源配置：\n\n[group_db1]\nurl = jdbc:mysql://<host>:<port>/<database_name>\nusername = 用户名\npassword = 密码\n\n[group_db2]\nurl = jdbc:mysql://<host2>:<port>/<database_name>\nusername = 用户名\npassword = 密码\n\n\n我们按照上面的方式编写db.setting文件，然后：\n\ndatasource ds1 = dsfactory.get("group_db1");\ndatasource ds2 = dsfactory.get("group_db2");\n\n\n这样我们就可以在一个配置文件中实现多数据源的配置。\n\n\n# 结语\n\nhutool通过多种方式获取datasource对象，获取后除了可以在hutool自身应用外，还可以将此对象传入不同的框架以实现无缝结合。\n\nhutool对数据源的封装很好的诠释了以下几个原则：\n\n 1. 自动识别优于用户定义\n 2. 便捷性与灵活性并存\n 3. 适配与兼容',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"案例1-导出Blob字段图像",frontmatter:{title:"案例1-导出Blob字段图像",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/blob/example/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89/07.%E6%A1%88%E4%BE%8B1-%E5%AF%BC%E5%87%BABlob%E5%AD%97%E6%AE%B5%E5%9B%BE%E5%83%8F.html",relativePath:"01.指南/09.数据库（Hutool-db）/07.案例1-导出Blob字段图像.md",key:"v-2d01b0d8",path:"/pages/blob/example/",headers:[{level:2,title:"需求：",slug:"需求",normalizedTitle:"需求：",charIndex:2},{level:2,title:"环境",slug:"环境",normalizedTitle:"环境",charIndex:83},{level:2,title:"编码",slug:"编码",normalizedTitle:"编码",charIndex:128},{level:3,title:"数据库配置：src/main/resources/config/db.setting",slug:"数据库配置-src-main-resources-config-db-setting",normalizedTitle:"数据库配置：src/main/resources/config/db.setting",charIndex:135},{level:3,title:"代码：PicTransfer.java",slug:"代码-pictransfer-java",normalizedTitle:"代码：pictransfer.java",charIndex:299}],headersStr:"需求： 环境 编码 数据库配置：src/main/resources/config/db.setting 代码：PicTransfer.java",content:'# 需求：\n\n有一张单表存储着图片（图片使用Blob字段）以及图片的相关信息，需求是从数据库中将这些Blob字段内容保存为图片文件，文件名为图片的相关信息。\n\n\n# 环境\n\n数据库：Oracle\n本地：Windows\n工具：Hutool-db模块\n\n\n# 编码\n\n\n# 数据库配置：src/main/resources/config/db.setting\n\n#JDBC url，必须\nurl = jdbc:oracle:thin:@localhost:1521/orcl\n#用户名，必须\nuser = test\n#密码，必须，如果密码为空，请填写 pass = \npass = test\n\n\n\n# 代码：PicTransfer.java\n\npublic class PicTransfer {\n\tpublic static void main(String[] args) throws SQLException {\n\t\tDb.use().find(\n\t\t\t\tListUtil.of("NAME", "TYPE", "GROUP", "PIC"), \n\t\t\t\tEntity.create("PIC_INFO").set("TYPE", 1),\n\t\t\t\trs -> {\n\t\t\t\t\twhile(rs.next()){\n\t\t\t\t\t\tsave(rs);\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t);\n\t}\n\t\n\tprivate static void save(ResultSet rs) throws SQLException{\n\t\tString destDir = "f:/pic";\n\t\tString path = StrUtil.format("{}/{}-{}.jpg", destDir, rs.getString("NAME"), rs.getString("GROUP"));\n\t\tFileUtil.writeFromStream(rs.getBlob("PIC").getBinaryStream(), path);\n\t}\n}\n',normalizedContent:'# 需求：\n\n有一张单表存储着图片（图片使用blob字段）以及图片的相关信息，需求是从数据库中将这些blob字段内容保存为图片文件，文件名为图片的相关信息。\n\n\n# 环境\n\n数据库：oracle\n本地：windows\n工具：hutool-db模块\n\n\n# 编码\n\n\n# 数据库配置：src/main/resources/config/db.setting\n\n#jdbc url，必须\nurl = jdbc:oracle:thin:@localhost:1521/orcl\n#用户名，必须\nuser = test\n#密码，必须，如果密码为空，请填写 pass = \npass = test\n\n\n\n# 代码：pictransfer.java\n\npublic class pictransfer {\n\tpublic static void main(string[] args) throws sqlexception {\n\t\tdb.use().find(\n\t\t\t\tlistutil.of("name", "type", "group", "pic"), \n\t\t\t\tentity.create("pic_info").set("type", 1),\n\t\t\t\trs -> {\n\t\t\t\t\twhile(rs.next()){\n\t\t\t\t\t\tsave(rs);\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t);\n\t}\n\t\n\tprivate static void save(resultset rs) throws sqlexception{\n\t\tstring destdir = "f:/pic";\n\t\tstring path = strutil.format("{}/{}-{}.jpg", destdir, rs.getstring("name"), rs.getstring("group"));\n\t\tfileutil.writefromstream(rs.getblob("pic").getbinarystream(), path);\n\t}\n}\n',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"数据源配置db.setting样例",frontmatter:{title:"数据源配置db.setting样例",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/db/setting/example/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89/06.%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AEdb.setting%E6%A0%B7%E4%BE%8B.html",relativePath:"01.指南/09.数据库（Hutool-db）/06.数据源配置db.setting样例.md",key:"v-ba965380",path:"/pages/db/setting/example/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"基本配置样例",slug:"基本配置样例",normalizedTitle:"基本配置样例",charIndex:148},{level:2,title:"HikariCP",slug:"hikaricp",normalizedTitle:"hikaricp",charIndex:709},{level:2,title:"Druid",slug:"druid",normalizedTitle:"druid",charIndex:1259},{level:2,title:"Tomcat JDBC Pool",slug:"tomcat-jdbc-pool",normalizedTitle:"tomcat jdbc pool",charIndex:2585},{level:2,title:"C3P0（不推荐）",slug:"c3p0-不推荐",normalizedTitle:"c3p0（不推荐）",charIndex:3964},{level:2,title:"DBCP（不推荐）",slug:"dbcp-不推荐",normalizedTitle:"dbcp（不推荐）",charIndex:5128}],headersStr:"介绍 基本配置样例 HikariCP Druid Tomcat JDBC Pool C3P0（不推荐） DBCP（不推荐）",content:"# 介绍\n\nDsFactory默认读取的配置文件是config/db.setting或db.setting，db.setting的配置包括两部分：基本连接信息和连接池配置信息。\n\n基本连接信息所有连接池都支持，连接池配置信息根据不同的连接池，连接池配置是根据连接池相应的配置项移植而来。\n\n\n# 基本配置样例\n\n#------------------------------------------------------------------------------------------\n## 基本配置信息\n# JDBC URL，根据不同的数据库，使用相应的JDBC连接字符串\nurl = jdbc:mysql://<host>:<port>/<database_name>\n# 用户名，此处也可以使用 user 代替\nusername = 用户名\n# 密码，此处也可以使用 pass 代替\npassword = 密码\n# JDBC驱动名，可选（Hutool会自动识别）\ndriver = com.mysql.jdbc.Driver\n\n## 可选配置\n# 是否在日志中显示执行的SQL\nshowSql = true\n# 是否格式化显示的SQL\nformatSql = false\n# 是否显示SQL参数\nshowParams = true\n# 打印SQL的日志等级，默认debug\nsqlLevel = debug\n#------------------------------------------------------------------------------------------\n\n\n\n# HikariCP\n\n## 连接池配置项\n# 自动提交\nautoCommit = true\n# 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 缺省:30秒\nconnectionTimeout = 30000\n# 一个连接idle状态的最大时长（毫秒），超时则被释放（retired），缺省:10分钟\nidleTimeout = 600000\n# 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考MySQL wait_timeout参数（show variables like '%timeout%';）\nmaxLifetime = 1800000\n# 获取连接前的测试SQL\nconnectionTestQuery = SELECT 1\n# 最小闲置连接数\nminimumIdle = 10\n# 连接池中允许的最大连接数。缺省值：10；推荐的公式：((core_count * 2) + effective_spindle_count)\nmaximumPoolSize = 10\n# 连接只读数据库时配置为true， 保证安全\nreadOnly = false\n\n\n\n# Druid\n\n# 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时\ninitialSize = 0\n# 最大连接池数量\nmaxActive = 8\n# 最小连接池数量\nminIdle = 0\n# 获取连接时最大等待时间，单位毫秒。配置了maxWait之后， 缺省启用公平锁，并发效率会有所下降， 如果需要可以通过配置useUnfairLock属性为true使用非公平锁。\nmaxWait = 0\n# 是否缓存preparedStatement，也就是PSCache。 PSCache对支持游标的数据库性能提升巨大，比如说oracle。 在mysql5.5以下的版本中没有PSCache功能，建议关闭掉。作者在5.5版本中使用PSCache，通过监控界面发现PSCache有缓存命中率记录， 该应该是支持PSCache。\npoolPreparedStatements = false\n# 要启用PSCache，必须配置大于0，当大于0时， poolPreparedStatements自动触发修改为true。 在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100\nmaxOpenPreparedStatements = -1\n# 用来检测连接是否有效的sql，要求是一个查询语句。 如果validationQuery为null，testOnBorrow、testOnReturn、 testWhileIdle都不会其作用。\nvalidationQuery = SELECT 1\n# 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\ntestOnBorrow = true\n# 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能\ntestOnReturn = false\n# 建议配置为true，不影响性能，并且保证安全性。 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\ntestWhileIdle = false\n# 有两个含义： 1) Destroy线程会检测连接的间隔时间 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\ntimeBetweenEvictionRunsMillis = 60000\n# 物理连接初始化的时候执行的sql\nconnectionInitSqls = SELECT 1\n# 属性类型是字符串，通过别名的方式配置扩展插件， 常用的插件有： 监控统计用的filter:stat  日志用的filter:log4j 防御sql注入的filter:wall\nfilters = stat\n# 类型是List<com.alibaba.druid.filter.Filter>， 如果同时配置了filters和proxyFilters， 是组合关系，并非替换关系\nproxyFilters = \n\n\n\n# Tomcat JDBC Pool\n\n# (boolean) 连接池创建的连接的默认的auto-commit 状态\ndefaultAutoCommit = true\n# (boolean) 连接池创建的连接的默认的read-only 状态。 如果没有设置则setReadOnly 方法将不会被调用。 ( 某些驱动不支持只读模式， 比如：Informix)\ndefaultReadOnly = false\n# (String) 连接池创建的连接的默认的TransactionIsolation 状态。 下面列表当中的某一个： ( 参考javadoc) NONE READ_COMMITTED EAD_UNCOMMITTED REPEATABLE_READ SERIALIZABLE\ndefaultTransactionIsolation = NONE\n# (int) 初始化连接： 连接池启动时创建的初始化连接数量，1。2 版本后支持\ninitialSize = 10\n# (int) 最大活动连接： 连接池在同一时间能够分配的最大活动连接的数量， 如果设置为非正数则表示不限制\nmaxActive = 100\n# (int) 最大空闲连接： 连接池中容许保持空闲状态的最大连接数量， 超过的空闲连接将被释放， 如果设置为负数表示不限制 如果启用，将定期检查限制连接，如果空闲时间超过minEvictableIdleTimeMillis 则释放连接 （ 参考testWhileIdle ）\nmaxIdle = 8\n# (int) 最小空闲连接： 连接池中容许保持空闲状态的最小连接数量， 低于这个数量将创建新的连接， 如果设置为0 则不创建 如果连接验证失败将缩小这个值（ 参考testWhileIdle ）\nminIdle = 0\n# (int) 最大等待时间： 当没有可用连接时， 连接池等待连接被归还的最大时间( 以毫秒计数)， 超过时间则抛出异常， 如果设置为-1 表示无限等待\nmaxWait = 30000\n# (String) SQL 查询， 用来验证从连接池取出的连接， 在将连接返回给调用者之前。 如果指定， 则查询必须是一个SQL SELECT 并且必须返回至少一行记录 查询不必返回记录，但这样将不能抛出SQL异常\nvalidationQuery = SELECT 1\n# (boolean) 指明是否在从池中取出连接前进行检验， 如果检验失败， 则从池中去除连接并尝试取出另一个。注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串 参考validationInterval以获得更有效的验证\ntestOnBorrow = false\n# (boolean) 指明是否在归还到池中前进行检验 注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串\ntestOnReturn = false\n# (boolean) 指明连接是否被空闲连接回收器( 如果有) 进行检验。 如果检测失败， 则连接将被从池中去除。注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串\ntestWhileIdle = false\n\n\n\n# C3P0（不推荐）\n\n# 连接池中保留的最大连接数。默认值: 15\nmaxPoolSize = 15\n# 连接池中保留的最小连接数，默认为：3\nminPoolSize = 3\n# 初始化连接池中的连接数，取值应在minPoolSize与maxPoolSize之间，默认为3\ninitialPoolSize = 3\n# 最大空闲时间，60秒内未使用则连接被丢弃。若为0则永不丢弃。默认值: 0\nmaxIdleTime = 0\n# 当连接池连接耗尽时，客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException，如设为0则无限期等待。单位毫秒。默认: 0\ncheckoutTimeout = 0\n# 当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。默认值: 3\nacquireIncrement = 3\n# 定义在从数据库获取新连接失败后重复尝试的次数。默认值: 30 ；小于等于0表示无限次\nacquireRetryAttempts = 0\n# 重新尝试的时间间隔，默认为：1000毫秒\nacquireRetryDelay = 1000\n# 关闭连接时，是否提交未提交的事务，默认为false，即关闭连接，回滚未提交的事务\nautoCommitOnClose = false\n# c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。默认值: null\nautomaticTestTable = null\n# 如果为false，则获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常，但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。默认: false\nbreakAfterAcquireFailure = false\n# 检查所有连接池中的空闲连接的检查频率。默认值: 0，不检查\nidleConnectionTestPeriod = 0\n# c3p0全局的PreparedStatements缓存的大小。如果maxStatements与maxStatementsPerConnection均为0，则缓存不生效，只要有一个不为0，则语句的缓存就能生效。如果默认值: 0\nmaxStatements = 0\n# maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。默认值: 0\nmaxStatementsPerConnection = 0\n\n\n\n# DBCP（不推荐）\n\n# (boolean) 连接池创建的连接的默认的auto-commit 状态\ndefaultAutoCommit = true\n# (boolean) 连接池创建的连接的默认的read-only 状态。 如果没有设置则setReadOnly 方法将不会被调用。 ( 某些驱动不支持只读模式， 比如：Informix)\ndefaultReadOnly = false\n# (String) 连接池创建的连接的默认的TransactionIsolation 状态。 下面列表当中的某一个： ( 参考javadoc) NONE READ_COMMITTED EAD_UNCOMMITTED REPEATABLE_READ SERIALIZABLE\ndefaultTransactionIsolation = NONE\n# (int) 初始化连接： 连接池启动时创建的初始化连接数量，1。2 版本后支持\ninitialSize = 10\n# (int) 最大活动连接： 连接池在同一时间能够分配的最大活动连接的数量， 如果设置为非正数则表示不限制\nmaxActive = 100\n# (int) 最大空闲连接： 连接池中容许保持空闲状态的最大连接数量， 超过的空闲连接将被释放， 如果设置为负数表示不限制 如果启用，将定期检查限制连接，如果空闲时间超过minEvictableIdleTimeMillis 则释放连接 （ 参考testWhileIdle ）\nmaxIdle = 8\n# (int) 最小空闲连接： 连接池中容许保持空闲状态的最小连接数量， 低于这个数量将创建新的连接， 如果设置为0 则不创建 如果连接验证失败将缩小这个值（ 参考testWhileIdle ）\nminIdle = 0\n# (int) 最大等待时间： 当没有可用连接时， 连接池等待连接被归还的最大时间( 以毫秒计数)， 超过时间则抛出异常， 如果设置为-1 表示无限等待\nmaxWait = 30000\n# (String) SQL 查询， 用来验证从连接池取出的连接， 在将连接返回给调用者之前。 如果指定， 则查询必须是一个SQL SELECT 并且必须返回至少一行记录 查询不必返回记录，但这样将不能抛出SQL异常\nvalidationQuery = SELECT 1\n# (boolean) 指明是否在从池中取出连接前进行检验， 如果检验失败， 则从池中去除连接并尝试取出另一个。注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串 参考validationInterval以获得更有效的验证\ntestOnBorrow = false\n# (boolean) 指明是否在归还到池中前进行检验 注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串\ntestOnReturn = false\n# (boolean) 指明连接是否被空闲连接回收器( 如果有) 进行检验。 如果检测失败， 则连接将被从池中去除。注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串\ntestWhileIdle = false\n",normalizedContent:"# 介绍\n\ndsfactory默认读取的配置文件是config/db.setting或db.setting，db.setting的配置包括两部分：基本连接信息和连接池配置信息。\n\n基本连接信息所有连接池都支持，连接池配置信息根据不同的连接池，连接池配置是根据连接池相应的配置项移植而来。\n\n\n# 基本配置样例\n\n#------------------------------------------------------------------------------------------\n## 基本配置信息\n# jdbc url，根据不同的数据库，使用相应的jdbc连接字符串\nurl = jdbc:mysql://<host>:<port>/<database_name>\n# 用户名，此处也可以使用 user 代替\nusername = 用户名\n# 密码，此处也可以使用 pass 代替\npassword = 密码\n# jdbc驱动名，可选（hutool会自动识别）\ndriver = com.mysql.jdbc.driver\n\n## 可选配置\n# 是否在日志中显示执行的sql\nshowsql = true\n# 是否格式化显示的sql\nformatsql = false\n# 是否显示sql参数\nshowparams = true\n# 打印sql的日志等级，默认debug\nsqllevel = debug\n#------------------------------------------------------------------------------------------\n\n\n\n# hikaricp\n\n## 连接池配置项\n# 自动提交\nautocommit = true\n# 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生sqlexception， 缺省:30秒\nconnectiontimeout = 30000\n# 一个连接idle状态的最大时长（毫秒），超时则被释放（retired），缺省:10分钟\nidletimeout = 600000\n# 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考mysql wait_timeout参数（show variables like '%timeout%';）\nmaxlifetime = 1800000\n# 获取连接前的测试sql\nconnectiontestquery = select 1\n# 最小闲置连接数\nminimumidle = 10\n# 连接池中允许的最大连接数。缺省值：10；推荐的公式：((core_count * 2) + effective_spindle_count)\nmaximumpoolsize = 10\n# 连接只读数据库时配置为true， 保证安全\nreadonly = false\n\n\n\n# druid\n\n# 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getconnection时\ninitialsize = 0\n# 最大连接池数量\nmaxactive = 8\n# 最小连接池数量\nminidle = 0\n# 获取连接时最大等待时间，单位毫秒。配置了maxwait之后， 缺省启用公平锁，并发效率会有所下降， 如果需要可以通过配置useunfairlock属性为true使用非公平锁。\nmaxwait = 0\n# 是否缓存preparedstatement，也就是pscache。 pscache对支持游标的数据库性能提升巨大，比如说oracle。 在mysql5.5以下的版本中没有pscache功能，建议关闭掉。作者在5.5版本中使用pscache，通过监控界面发现pscache有缓存命中率记录， 该应该是支持pscache。\npoolpreparedstatements = false\n# 要启用pscache，必须配置大于0，当大于0时， poolpreparedstatements自动触发修改为true。 在druid中，不会存在oracle下pscache占用内存过多的问题， 可以把这个数值配置大一些，比如说100\nmaxopenpreparedstatements = -1\n# 用来检测连接是否有效的sql，要求是一个查询语句。 如果validationquery为null，testonborrow、testonreturn、 testwhileidle都不会其作用。\nvalidationquery = select 1\n# 申请连接时执行validationquery检测连接是否有效，做了这个配置会降低性能。\ntestonborrow = true\n# 归还连接时执行validationquery检测连接是否有效，做了这个配置会降低性能\ntestonreturn = false\n# 建议配置为true，不影响性能，并且保证安全性。 申请连接的时候检测，如果空闲时间大于 timebetweenevictionrunsmillis，执行validationquery检测连接是否有效。\ntestwhileidle = false\n# 有两个含义： 1) destroy线程会检测连接的间隔时间 2) testwhileidle的判断依据，详细看testwhileidle属性的说明\ntimebetweenevictionrunsmillis = 60000\n# 物理连接初始化的时候执行的sql\nconnectioninitsqls = select 1\n# 属性类型是字符串，通过别名的方式配置扩展插件， 常用的插件有： 监控统计用的filter:stat  日志用的filter:log4j 防御sql注入的filter:wall\nfilters = stat\n# 类型是list<com.alibaba.druid.filter.filter>， 如果同时配置了filters和proxyfilters， 是组合关系，并非替换关系\nproxyfilters = \n\n\n\n# tomcat jdbc pool\n\n# (boolean) 连接池创建的连接的默认的auto-commit 状态\ndefaultautocommit = true\n# (boolean) 连接池创建的连接的默认的read-only 状态。 如果没有设置则setreadonly 方法将不会被调用。 ( 某些驱动不支持只读模式， 比如：informix)\ndefaultreadonly = false\n# (string) 连接池创建的连接的默认的transactionisolation 状态。 下面列表当中的某一个： ( 参考javadoc) none read_committed ead_uncommitted repeatable_read serializable\ndefaulttransactionisolation = none\n# (int) 初始化连接： 连接池启动时创建的初始化连接数量，1。2 版本后支持\ninitialsize = 10\n# (int) 最大活动连接： 连接池在同一时间能够分配的最大活动连接的数量， 如果设置为非正数则表示不限制\nmaxactive = 100\n# (int) 最大空闲连接： 连接池中容许保持空闲状态的最大连接数量， 超过的空闲连接将被释放， 如果设置为负数表示不限制 如果启用，将定期检查限制连接，如果空闲时间超过minevictableidletimemillis 则释放连接 （ 参考testwhileidle ）\nmaxidle = 8\n# (int) 最小空闲连接： 连接池中容许保持空闲状态的最小连接数量， 低于这个数量将创建新的连接， 如果设置为0 则不创建 如果连接验证失败将缩小这个值（ 参考testwhileidle ）\nminidle = 0\n# (int) 最大等待时间： 当没有可用连接时， 连接池等待连接被归还的最大时间( 以毫秒计数)， 超过时间则抛出异常， 如果设置为-1 表示无限等待\nmaxwait = 30000\n# (string) sql 查询， 用来验证从连接池取出的连接， 在将连接返回给调用者之前。 如果指定， 则查询必须是一个sql select 并且必须返回至少一行记录 查询不必返回记录，但这样将不能抛出sql异常\nvalidationquery = select 1\n# (boolean) 指明是否在从池中取出连接前进行检验， 如果检验失败， 则从池中去除连接并尝试取出另一个。注意： 设置为true 后如果要生效，validationquery 参数必须设置为非空字符串 参考validationinterval以获得更有效的验证\ntestonborrow = false\n# (boolean) 指明是否在归还到池中前进行检验 注意： 设置为true 后如果要生效，validationquery 参数必须设置为非空字符串\ntestonreturn = false\n# (boolean) 指明连接是否被空闲连接回收器( 如果有) 进行检验。 如果检测失败， 则连接将被从池中去除。注意： 设置为true 后如果要生效，validationquery 参数必须设置为非空字符串\ntestwhileidle = false\n\n\n\n# c3p0（不推荐）\n\n# 连接池中保留的最大连接数。默认值: 15\nmaxpoolsize = 15\n# 连接池中保留的最小连接数，默认为：3\nminpoolsize = 3\n# 初始化连接池中的连接数，取值应在minpoolsize与maxpoolsize之间，默认为3\ninitialpoolsize = 3\n# 最大空闲时间，60秒内未使用则连接被丢弃。若为0则永不丢弃。默认值: 0\nmaxidletime = 0\n# 当连接池连接耗尽时，客户端调用getconnection()后等待获取新连接的时间，超时后将抛出sqlexception，如设为0则无限期等待。单位毫秒。默认: 0\ncheckouttimeout = 0\n# 当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。默认值: 3\nacquireincrement = 3\n# 定义在从数据库获取新连接失败后重复尝试的次数。默认值: 30 ；小于等于0表示无限次\nacquireretryattempts = 0\n# 重新尝试的时间间隔，默认为：1000毫秒\nacquireretrydelay = 1000\n# 关闭连接时，是否提交未提交的事务，默认为false，即关闭连接，回滚未提交的事务\nautocommitonclose = false\n# c3p0将建一张名为test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredtestquery将被忽略。你不能在这张test表上进行任何操作，它将只供c3p0测试使用。默认值: null\nautomatictesttable = null\n# 如果为false，则获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常，但是数据源仍有效保留，并在下次调用getconnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。默认: false\nbreakafteracquirefailure = false\n# 检查所有连接池中的空闲连接的检查频率。默认值: 0，不检查\nidleconnectiontestperiod = 0\n# c3p0全局的preparedstatements缓存的大小。如果maxstatements与maxstatementsperconnection均为0，则缓存不生效，只要有一个不为0，则语句的缓存就能生效。如果默认值: 0\nmaxstatements = 0\n# maxstatementsperconnection定义了连接池内单个连接所拥有的最大缓存statements数。默认值: 0\nmaxstatementsperconnection = 0\n\n\n\n# dbcp（不推荐）\n\n# (boolean) 连接池创建的连接的默认的auto-commit 状态\ndefaultautocommit = true\n# (boolean) 连接池创建的连接的默认的read-only 状态。 如果没有设置则setreadonly 方法将不会被调用。 ( 某些驱动不支持只读模式， 比如：informix)\ndefaultreadonly = false\n# (string) 连接池创建的连接的默认的transactionisolation 状态。 下面列表当中的某一个： ( 参考javadoc) none read_committed ead_uncommitted repeatable_read serializable\ndefaulttransactionisolation = none\n# (int) 初始化连接： 连接池启动时创建的初始化连接数量，1。2 版本后支持\ninitialsize = 10\n# (int) 最大活动连接： 连接池在同一时间能够分配的最大活动连接的数量， 如果设置为非正数则表示不限制\nmaxactive = 100\n# (int) 最大空闲连接： 连接池中容许保持空闲状态的最大连接数量， 超过的空闲连接将被释放， 如果设置为负数表示不限制 如果启用，将定期检查限制连接，如果空闲时间超过minevictableidletimemillis 则释放连接 （ 参考testwhileidle ）\nmaxidle = 8\n# (int) 最小空闲连接： 连接池中容许保持空闲状态的最小连接数量， 低于这个数量将创建新的连接， 如果设置为0 则不创建 如果连接验证失败将缩小这个值（ 参考testwhileidle ）\nminidle = 0\n# (int) 最大等待时间： 当没有可用连接时， 连接池等待连接被归还的最大时间( 以毫秒计数)， 超过时间则抛出异常， 如果设置为-1 表示无限等待\nmaxwait = 30000\n# (string) sql 查询， 用来验证从连接池取出的连接， 在将连接返回给调用者之前。 如果指定， 则查询必须是一个sql select 并且必须返回至少一行记录 查询不必返回记录，但这样将不能抛出sql异常\nvalidationquery = select 1\n# (boolean) 指明是否在从池中取出连接前进行检验， 如果检验失败， 则从池中去除连接并尝试取出另一个。注意： 设置为true 后如果要生效，validationquery 参数必须设置为非空字符串 参考validationinterval以获得更有效的验证\ntestonborrow = false\n# (boolean) 指明是否在归还到池中前进行检验 注意： 设置为true 后如果要生效，validationquery 参数必须设置为非空字符串\ntestonreturn = false\n# (boolean) 指明连接是否被空闲连接回收器( 如果有) 进行检验。 如果检测失败， 则连接将被从池中去除。注意： 设置为true 后如果要生效，validationquery 参数必须设置为非空字符串\ntestwhileidle = false\n",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"DFA查找",frontmatter:{title:"DFA查找",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/dfa/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/08.DFA%E6%9F%A5%E6%89%BE%EF%BC%88Hutool-dfa%EF%BC%89/02.DFA%E6%9F%A5%E6%89%BE.html",relativePath:"01.指南/08.DFA查找（Hutool-dfa）/02.DFA查找.md",key:"v-116c32ea",path:"/pages/dfa/",headers:[{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:2},{level:3,title:"1. 构建关键词树",slug:"_1-构建关键词树",normalizedTitle:"1. 构建关键词树",charIndex:9},{level:3,title:"2. 查找关键词",slug:"_2-查找关键词",normalizedTitle:"2. 查找关键词",charIndex:158},{level:2,title:"针对特殊字符",slug:"针对特殊字符",normalizedTitle:"针对特殊字符",charIndex:1224}],headersStr:"使用 1. 构建关键词树 2. 查找关键词 针对特殊字符",content:'# 使用\n\n\n# 1. 构建关键词树\n\nWordTree tree = new WordTree();\ntree.addWord("大");\ntree.addWord("大土豆");\ntree.addWord("土豆");\ntree.addWord("刚出锅");\ntree.addWord("出锅");\n\n\n\n# 2. 查找关键词\n\n//正文\nString text = "我有一颗大土豆，刚出锅的";\n\n\n 1. 情况一：标准匹配，匹配到最短关键词，并跳过已经匹配的关键词\n\n// 匹配到【大】，就不再继续匹配了，因此【大土豆】不匹配\n// 匹配到【刚出锅】，就跳过这三个字了，因此【出锅】不匹配（由于【刚】首先被匹配，因此长的被匹配，最短匹配只针对第一个字相同选最短）\nList<String> matchAll = tree.matchAll(text, -1, false, false);\nAssert.assertEquals(matchAll.toString(), "[大, 土豆, 刚出锅]");\n\n\n 2. 情况二：匹配到最短关键词，不跳过已经匹配的关键词\n\n// 【大】被匹配，最短匹配原则【大土豆】被跳过，【土豆】继续被匹配\n// 【刚出锅】被匹配，由于不跳过已经匹配的词，【出锅】被匹配\nmatchAll = tree.matchAll(text, -1, true, false);\nAssert.assertEquals(matchAll.toString(), "[大, 土豆, 刚出锅, 出锅]");\n\n\n 3. 情况三：匹配到最长关键词，跳过已经匹配的关键词\n\n// 匹配到【大】，由于非密集匹配，因此从下一个字符开始查找，匹配到【土豆】接着被匹配\n// 由于【刚出锅】被匹配，由于非密集匹配，【出锅】被跳过\nmatchAll = tree.matchAll(text, -1, false, true);\nAssert.assertEquals(matchAll.toString(), "[大, 土豆, 刚出锅]");\n\n\n 4. 情况四：匹配到最长关键词，不跳过已经匹配的关键词（最全关键词）\n\n// 匹配到【大】，由于是最长匹配，因此【大土豆】接着被匹配，由于不跳过已经匹配的关键词，【土豆】继续被匹配\n// 【刚出锅】被匹配，由于不跳过已经匹配的词，【出锅】被匹配\nmatchAll = tree.matchAll(text, -1, true, true);\nAssert.assertEquals(matchAll.toString(), "[大, 大土豆, 土豆, 刚出锅, 出锅]");\n\n\n> 除了matchAll方法，WordTree还提供了match和isMatch两个方法，这两个方法只会查找第一个匹配的结果，这样一旦找到第一个关键字，就会停止继续匹配，大大提高了匹配效率。\n\n\n# 针对特殊字符\n\n有时候，正文中的关键字常常包含特殊字符，比如:"〓关键☆字"，针对这种情况，Hutool提供了StopChar类，专门针对特殊字符做跳过处理，这个过程是在match方法或matchAll方法执行的时候自动去掉特殊字符。',normalizedContent:'# 使用\n\n\n# 1. 构建关键词树\n\nwordtree tree = new wordtree();\ntree.addword("大");\ntree.addword("大土豆");\ntree.addword("土豆");\ntree.addword("刚出锅");\ntree.addword("出锅");\n\n\n\n# 2. 查找关键词\n\n//正文\nstring text = "我有一颗大土豆，刚出锅的";\n\n\n 1. 情况一：标准匹配，匹配到最短关键词，并跳过已经匹配的关键词\n\n// 匹配到【大】，就不再继续匹配了，因此【大土豆】不匹配\n// 匹配到【刚出锅】，就跳过这三个字了，因此【出锅】不匹配（由于【刚】首先被匹配，因此长的被匹配，最短匹配只针对第一个字相同选最短）\nlist<string> matchall = tree.matchall(text, -1, false, false);\nassert.assertequals(matchall.tostring(), "[大, 土豆, 刚出锅]");\n\n\n 2. 情况二：匹配到最短关键词，不跳过已经匹配的关键词\n\n// 【大】被匹配，最短匹配原则【大土豆】被跳过，【土豆】继续被匹配\n// 【刚出锅】被匹配，由于不跳过已经匹配的词，【出锅】被匹配\nmatchall = tree.matchall(text, -1, true, false);\nassert.assertequals(matchall.tostring(), "[大, 土豆, 刚出锅, 出锅]");\n\n\n 3. 情况三：匹配到最长关键词，跳过已经匹配的关键词\n\n// 匹配到【大】，由于非密集匹配，因此从下一个字符开始查找，匹配到【土豆】接着被匹配\n// 由于【刚出锅】被匹配，由于非密集匹配，【出锅】被跳过\nmatchall = tree.matchall(text, -1, false, true);\nassert.assertequals(matchall.tostring(), "[大, 土豆, 刚出锅]");\n\n\n 4. 情况四：匹配到最长关键词，不跳过已经匹配的关键词（最全关键词）\n\n// 匹配到【大】，由于是最长匹配，因此【大土豆】接着被匹配，由于不跳过已经匹配的关键词，【土豆】继续被匹配\n// 【刚出锅】被匹配，由于不跳过已经匹配的词，【出锅】被匹配\nmatchall = tree.matchall(text, -1, true, true);\nassert.assertequals(matchall.tostring(), "[大, 大土豆, 土豆, 刚出锅, 出锅]");\n\n\n> 除了matchall方法，wordtree还提供了match和ismatch两个方法，这两个方法只会查找第一个匹配的结果，这样一旦找到第一个关键字，就会停止继续匹配，大大提高了匹配效率。\n\n\n# 针对特殊字符\n\n有时候，正文中的关键字常常包含特殊字符，比如:"〓关键☆字"，针对这种情况，hutool提供了stopchar类，专门针对特殊字符做跳过处理，这个过程是在match方法或matchall方法执行的时候自动去掉特殊字符。',charsets:{cjk:!0},lastUpdated:"2023/12/05, 21:55:56",lastUpdatedTimestamp:1701784556e3},{title:"Redis客户端封装-RedisDS",frontmatter:{title:"Redis客户端封装-RedisDS",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/RedisDS/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89/09.NoSQL/01.Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B0%81%E8%A3%85-RedisDS.html",relativePath:"01.指南/09.数据库（Hutool-db）/09.NoSQL/01.Redis客户端封装-RedisDS.md",key:"v-754889d9",path:"/pages/RedisDS/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:25},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:64},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:71},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:201},{level:2,title:"构建",slug:"构建",normalizedTitle:"构建",charIndex:1803}],headersStr:"介绍 使用 引入依赖 配置 构建",content:'# Redis客户端封装-RedisDS\n\n\n# 介绍\n\nRedisDS基于Jedis封装，需自行引入Jedis依赖。\n\n\n# 使用\n\n\n# 引入依赖\n\n<dependency>\n\t<groupId>redis.clients</groupId>\n\t<artifactId>jedis</artifactId>\n\t<version>3.7.0</version>\n</dependency>\n\n\n\n# 配置\n\n在ClassPath（或者src/main/resources）的config目录下新建redis.setting\n\n#-------------------------------------------------------------------------------\n# Redis客户端配置样例\n# 每一个分组代表一个Redis实例\n# 无分组的Pool配置为所有分组的共用配置，如果分组自己定义Pool配置，则覆盖共用配置\n# 池配置来自于：https://www.cnblogs.com/jklk/p/7095067.html\n#-------------------------------------------------------------------------------\n\n#----- 默认（公有）配置\n# 地址，默认localhost\nhost = localhost\n# 端口，默认6379\nport = 6379\n# 超时，默认2000\ntimeout = 2000\n# 连接超时，默认timeout\nconnectionTimeout = 2000\n# 读取超时，默认timeout\nsoTimeout = 2000\n# 密码，默认无\npassword = \n# 数据库序号，默认0\ndatabase = 0\n# 客户端名，默认"Hutool"\nclientName = Hutool\n# SSL连接，默认false\nssl = false;\n\n#----- 自定义分组的连接\n[custom]\n# 地址，默认localhost\nhost = localhost\n# 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true\nBlockWhenExhausted = true;\n# 设置的逐出策略类名, 默认DefaultEvictionPolicy(当连接超过最大空闲时间,或连接数超过最大空闲连接数)\nevictionPolicyClassName = org.apache.commons.pool2.impl.DefaultEvictionPolicy\n# 是否启用pool的jmx管理功能, 默认true\njmxEnabled = true;\n# 是否启用后进先出, 默认true\nlifo = true;\n# 最大空闲连接数, 默认8个\nmaxIdle = 8\n# 最小空闲连接数, 默认0\nminIdle = 0\n# 最大连接数, 默认8个\nmaxTotal = 8\n# 获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1\nmaxWaitMillis = -1\n# 逐出连接的最小空闲时间 默认1800000毫秒(30分钟)\nminEvictableIdleTimeMillis = 1800000\n# 每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3\nnumTestsPerEvictionRun = 3;\n# 对象空闲多久后逐出, 当空闲时间>该值 且 空闲连接>最大空闲数 时直接逐出,不再根据MinEvictableIdleTimeMillis判断  (默认逐出策略)\nSoftMinEvictableIdleTimeMillis = 1800000\n# 在获取连接的时候检查有效性, 默认false\ntestOnBorrow = false\n# 在空闲时检查有效性, 默认false\ntestWhileIdle = false\n# 逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1\ntimeBetweenEvictionRunsMillis = -1\n\n\n\n# 构建\n\nJedis jedis = RedisDS.create().getJedis();\n',normalizedContent:'# redis客户端封装-redisds\n\n\n# 介绍\n\nredisds基于jedis封装，需自行引入jedis依赖。\n\n\n# 使用\n\n\n# 引入依赖\n\n<dependency>\n\t<groupid>redis.clients</groupid>\n\t<artifactid>jedis</artifactid>\n\t<version>3.7.0</version>\n</dependency>\n\n\n\n# 配置\n\n在classpath（或者src/main/resources）的config目录下新建redis.setting\n\n#-------------------------------------------------------------------------------\n# redis客户端配置样例\n# 每一个分组代表一个redis实例\n# 无分组的pool配置为所有分组的共用配置，如果分组自己定义pool配置，则覆盖共用配置\n# 池配置来自于：https://www.cnblogs.com/jklk/p/7095067.html\n#-------------------------------------------------------------------------------\n\n#----- 默认（公有）配置\n# 地址，默认localhost\nhost = localhost\n# 端口，默认6379\nport = 6379\n# 超时，默认2000\ntimeout = 2000\n# 连接超时，默认timeout\nconnectiontimeout = 2000\n# 读取超时，默认timeout\nsotimeout = 2000\n# 密码，默认无\npassword = \n# 数据库序号，默认0\ndatabase = 0\n# 客户端名，默认"hutool"\nclientname = hutool\n# ssl连接，默认false\nssl = false;\n\n#----- 自定义分组的连接\n[custom]\n# 地址，默认localhost\nhost = localhost\n# 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true\nblockwhenexhausted = true;\n# 设置的逐出策略类名, 默认defaultevictionpolicy(当连接超过最大空闲时间,或连接数超过最大空闲连接数)\nevictionpolicyclassname = org.apache.commons.pool2.impl.defaultevictionpolicy\n# 是否启用pool的jmx管理功能, 默认true\njmxenabled = true;\n# 是否启用后进先出, 默认true\nlifo = true;\n# 最大空闲连接数, 默认8个\nmaxidle = 8\n# 最小空闲连接数, 默认0\nminidle = 0\n# 最大连接数, 默认8个\nmaxtotal = 8\n# 获取连接时的最大等待毫秒数(如果设置为阻塞时blockwhenexhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1\nmaxwaitmillis = -1\n# 逐出连接的最小空闲时间 默认1800000毫秒(30分钟)\nminevictableidletimemillis = 1800000\n# 每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3\nnumtestsperevictionrun = 3;\n# 对象空闲多久后逐出, 当空闲时间>该值 且 空闲连接>最大空闲数 时直接逐出,不再根据minevictableidletimemillis判断  (默认逐出策略)\nsoftminevictableidletimemillis = 1800000\n# 在获取连接的时候检查有效性, 默认false\ntestonborrow = false\n# 在空闲时检查有效性, 默认false\ntestwhileidle = false\n# 逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1\ntimebetweenevictionrunsmillis = -1\n\n\n\n# 构建\n\njedis jedis = redisds.create().getjedis();\n',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/http/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/00.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/00.概述.md",key:"v-73b83b96",path:"/pages/http/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:9},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:236},{level:3,title:"Hutool-http优点",slug:"hutool-http优点",normalizedTitle:"hutool-http优点",charIndex:409},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:670},{level:2,title:"更多",slug:"更多",normalizedTitle:"更多",charIndex:947}],headersStr:"由来 介绍 Hutool-http优点 使用 更多",content:'# 概述\n\n\n# 由来\n\n在Java的世界中，Http客户端之前一直是Apache家的HttpClient占据主导，但是由于此包较为庞大，API又比较难用，因此并不适用很多场景。而新兴的OkHttp、Jodd-http固然好用，但是面对一些场景时，学习成本还是有一些的。很多时候，我们想追求轻量级的Http客户端，并且追求简单易用。而JDK自带的HttpUrlConnection可以满足大部分需求。Hutool针对此类做了一层封装，使Http请求变得无比简单。\n\n\n# 介绍\n\nHutool-http针对JDK的HttpUrlConnection做一层封装，简化了HTTPS请求、文件上传、Cookie记忆等操作，使Http请求变得无比简单。\n\nHutool-http的核心集中在两个类：\n\n * HttpRequest\n * HttpResponse\n\n同时针对大部分情境，封装了HttpUtil工具类。\n\n\n# Hutool-http优点\n\n 1. 根据URL自动判断是请求HTTP还是HTTPS，不需要单独写多余的代码。\n 2. 表单数据中有File对象时自动转为multipart/form-data表单，不必单独做操作。\n 3. 默认情况下Cookie自动记录，比如可以实现模拟登录，即第一次访问登录URL后后续请求就是登录状态。\n 4. 自动识别304跳转并二次请求\n 5. 自动识别页面编码，即根据header信息或者页面中的相关标签信息自动识别编码，最大可能避免乱码。\n 6. 自动识别并解压Gzip格式返回内容\n\n\n# 使用\n\n最简单的使用莫过于用HttpUtil工具类快速请求某个页面：\n\n//GET请求\nString content = HttpUtil.get(url);\n\n\n一行代码即可搞定，当然Post请求也很简单：\n\n//POST请求\nHashMap<String, Object> paramMap = new HashMap<>();\nparamMap.put("city", "北京");\n\nString result1 = HttpUtil.post(url, paramMap);\n\n\nPost请求只需使用Map预先制定form表单项即可。\n\n\n# 更多\n\n根据Hutool的“便捷性与灵活性并存”原则，HttpUtil的存在体现了便捷性，那HttpRequest对象的使用则体现了灵活性，使用此对象可以自定义更多的属性给请求，以适应Http请求中的不同场景（例如自定义header、自定义cookie、自定义代理等等）。相关类的使用请见下几个章节。',normalizedContent:'# 概述\n\n\n# 由来\n\n在java的世界中，http客户端之前一直是apache家的httpclient占据主导，但是由于此包较为庞大，api又比较难用，因此并不适用很多场景。而新兴的okhttp、jodd-http固然好用，但是面对一些场景时，学习成本还是有一些的。很多时候，我们想追求轻量级的http客户端，并且追求简单易用。而jdk自带的httpurlconnection可以满足大部分需求。hutool针对此类做了一层封装，使http请求变得无比简单。\n\n\n# 介绍\n\nhutool-http针对jdk的httpurlconnection做一层封装，简化了https请求、文件上传、cookie记忆等操作，使http请求变得无比简单。\n\nhutool-http的核心集中在两个类：\n\n * httprequest\n * httpresponse\n\n同时针对大部分情境，封装了httputil工具类。\n\n\n# hutool-http优点\n\n 1. 根据url自动判断是请求http还是https，不需要单独写多余的代码。\n 2. 表单数据中有file对象时自动转为multipart/form-data表单，不必单独做操作。\n 3. 默认情况下cookie自动记录，比如可以实现模拟登录，即第一次访问登录url后后续请求就是登录状态。\n 4. 自动识别304跳转并二次请求\n 5. 自动识别页面编码，即根据header信息或者页面中的相关标签信息自动识别编码，最大可能避免乱码。\n 6. 自动识别并解压gzip格式返回内容\n\n\n# 使用\n\n最简单的使用莫过于用httputil工具类快速请求某个页面：\n\n//get请求\nstring content = httputil.get(url);\n\n\n一行代码即可搞定，当然post请求也很简单：\n\n//post请求\nhashmap<string, object> parammap = new hashmap<>();\nparammap.put("city", "北京");\n\nstring result1 = httputil.post(url, parammap);\n\n\npost请求只需使用map预先制定form表单项即可。\n\n\n# 更多\n\n根据hutool的“便捷性与灵活性并存”原则，httputil的存在体现了便捷性，那httprequest对象的使用则体现了灵活性，使用此对象可以自定义更多的属性给请求，以适应http请求中的不同场景（例如自定义header、自定义cookie、自定义代理等等）。相关类的使用请见下几个章节。',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:48:56",lastUpdatedTimestamp:1697798936e3},{title:"非对称加密-AsymmetricCrypto",frontmatter:{title:"非对称加密-AsymmetricCrypto",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/AsymmetricCrypto/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/07.%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%EF%BC%88Hutool-crypto%EF%BC%89/08.%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-AsymmetricCrypto.html",relativePath:"01.指南/07.加密解密（Hutool-crypto）/08.非对称加密-AsymmetricCrypto.md",key:"v-72ff0920",path:"/pages/AsymmetricCrypto/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:36},{level:3,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:618},{level:3,title:"自助生成密钥对",slug:"自助生成密钥对",normalizedTitle:"自助生成密钥对",charIndex:1441},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:1668},{level:3,title:"案例一：",slug:"案例一",normalizedTitle:"案例一：",charIndex:1675},{level:2,title:"其它算法",slug:"其它算法",normalizedTitle:"其它算法",charIndex:3162},{level:3,title:"ECIES",slug:"ecies",normalizedTitle:"ecies",charIndex:458}],headersStr:"介绍 使用 基本使用 自助生成密钥对 案例 案例一： 其它算法 ECIES",content:'# 介绍\n\n对于非对称加密，最常用的就是RSA和DSA，在Hutool中使用AsymmetricCrypto对象来负责加密解密。\n\n非对称加密有公钥和私钥两个概念，私钥自己拥有，不能给别人，公钥公开。根据应用的不同，我们可以选择使用不同的密钥加密：\n\n 1. 签名：使用私钥加密，公钥解密。用于让所有公钥所有者验证私钥所有者的身份并且用来防止私钥所有者发布的内容被篡改，但是不用来保证内容不被他人获得。\n\n 2. 加密：用公钥加密，私钥解密。用于向公钥所有者发布信息,这个信息可能被他人篡改,但是无法被他人获得。\n\nHutool封装了JDK的，详细见https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyPairGenerator：\n\n * RSA\n * RSA_ECB_PKCS1（RSA/ECB/PKCS1Padding）\n * RSA_None（RSA/None/NoPadding）\n * ECIES（需要Bouncy Castle库）\n\n\n# 使用\n\n在非对称加密中，我们可以通过AsymmetricCrypto(AsymmetricAlgorithm algorithm)构造方法，通过传入不同的算法枚举，获得其加密解密器。\n\n当然，为了方便，我们针对最常用的RSA算法构建了单独的对象：RSA。\n\n\n# 基本使用\n\n我们以RSA为例，介绍使用RSA加密和解密 在构建RSA对象时，可以传入公钥或私钥，当使用无参构造方法时，Hutool将自动生成随机的公钥私钥密钥对：\n\nRSA rsa = new RSA();\n\n//获得私钥\nrsa.getPrivateKey();\nrsa.getPrivateKeyBase64();\n//获得公钥\nrsa.getPublicKey();\nrsa.getPublicKeyBase64();\n\n//公钥加密，私钥解密\nbyte[] encrypt = rsa.encrypt(StrUtil.bytes("我是一段测试aaaa", CharsetUtil.CHARSET_UTF_8), KeyType.PublicKey);\nbyte[] decrypt = rsa.decrypt(encrypt, KeyType.PrivateKey);\n\n//Junit单元测试\n//Assert.assertEquals("我是一段测试aaaa", StrUtil.str(decrypt, CharsetUtil.CHARSET_UTF_8));\n\n//私钥加密，公钥解密\nbyte[] encrypt2 = rsa.encrypt(StrUtil.bytes("我是一段测试aaaa", CharsetUtil.CHARSET_UTF_8), KeyType.PrivateKey);\nbyte[] decrypt2 = rsa.decrypt(encrypt2, KeyType.PublicKey);\n\n//Junit单元测试\n//Assert.assertEquals("我是一段测试aaaa", StrUtil.str(decrypt2, CharsetUtil.CHARSET_UTF_8));\n\n\n> 对于加密和解密可以完全分开，对于RSA对象，如果只使用公钥或私钥，另一个参数可以为null\n\n\n# 自助生成密钥对\n\n有时候我们想自助生成密钥对可以：\n\nKeyPair pair = SecureUtil.generateKeyPair("RSA");\npair.getPrivate();\npair.getPublic();\n\n\n自助生成的密钥对是byte[]形式，我们可以使用Base64.encode方法转为Base64，便于存储为文本。\n\n当然，如果使用RSA对象，也可以使用encryptStr和decryptStr加密解密为字符串。\n\n\n# 案例\n\n\n# 案例一：\n\n已知私钥和密文，如何解密密文？\n\nString PRIVATE_KEY = "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAIL7pbQ+5KKGYRhw7jE31hmA"\n\t\t+ "f8Q60ybd+xZuRmuO5kOFBRqXGxKTQ9TfQI+aMW+0lw/kibKzaD/EKV91107xE384qOy6IcuBfaR5lv39OcoqNZ"\n\t\t+ "5l+Dah5ABGnVkBP9fKOFhPgghBknTRo0/rZFGI6Q1UHXb+4atP++LNFlDymJcPAgMBAAECgYBammGb1alndta"\n\t\t+ "xBmTtLLdveoBmp14p04D8mhkiC33iFKBcLUvvxGg2Vpuc+cbagyu/NZG+R/WDrlgEDUp6861M5BeFN0L9O4hz"\n\t\t+ "GAEn8xyTE96f8sh4VlRmBOvVdwZqRO+ilkOM96+KL88A9RKdp8V2tna7TM6oI3LHDyf/JBoXaQJBAMcVN7fKlYP"\n\t\t+ "Skzfh/yZzW2fmC0ZNg/qaW8Oa/wfDxlWjgnS0p/EKWZ8BxjR/d199L3i/KMaGdfpaWbYZLvYENqUCQQCobjsuCW"\n\t\t+ "nlZhcWajjzpsSuy8/bICVEpUax1fUZ58Mq69CQXfaZemD9Ar4omzuEAAs2/uee3kt3AvCBaeq05NyjAkBme8SwB0iK"\n\t\t+ "kLcaeGuJlq7CQIkjSrobIqUEf+CzVZPe+AorG+isS+Cw2w/2bHu+G0p5xSYvdH59P0+ZT0N+f9LFAkA6v3Ae56OrI"\n\t\t+ "wfMhrJksfeKbIaMjNLS9b8JynIaXg9iCiyOHmgkMl5gAbPoH/ULXqSKwzBw5mJ2GW1gBlyaSfV3AkA/RJC+adIjsRGg"\n\t\t+ "JOkiRjSmPpGv3FOhl9fsBPjupZBEIuoMWOC8GXK/73DHxwmfNmN7C9+sIi4RBcjEeQ5F5FHZ";\n\nRSA rsa = new RSA(PRIVATE_KEY, null);\n\nString a = "2707F9FD4288CEF302C972058712F24A5F3EC62C5A14AD2FC59DAB93503AA0FA17113A020EE4EA35EB53F"\n\t\t+ "75F36564BA1DABAA20F3B90FD39315C30E68FE8A1803B36C29029B23EB612C06ACF3A34BE815074F5EB5AA3A"\n\t\t+ "C0C8832EC42DA725B4E1C38EF4EA1B85904F8B10B2D62EA782B813229F9090E6F7394E42E6F44494BB8";\n\nbyte[] aByte = HexUtil.decodeHex(a);\nbyte[] decrypt = rsa.decrypt(aByte, KeyType.PrivateKey);\n\n//Junit单元测试\n//Assert.assertEquals("虎头闯杭州,多抬头看天,切勿只管种地", StrUtil.str(decrypt, CharsetUtil.CHARSET_UTF_8));\n\n\n\n# 其它算法\n\n\n# ECIES\n\nECIES全称集成加密方案（elliptic curve integrate encrypt scheme）\n\nHutool借助Bouncy Castle库可以支持ECIES算法：\n\n我们首先需要引入Bouncy Castle库：\n\n<dependency>\n  <groupId>org.bouncycastle</groupId>\n  <artifactId>bcpkix-jdk18on</artifactId>\n  <version>1.78.1</version>\n</dependency>\n\n\nfinal ECIES ecies = new ECIES();\nfinal IESParameterSpec iesParameterSpec = new IESParameterSpec(null, null, 128);\necies.setAlgorithmParameterSpec(iesParameterSpec);\n\nString textBase = "我是一段特别长的测试";\nStringBuilder text = new StringBuilder();\nfor (int i = 0; i < 10; i++) {\n\ttext.append(textBase);\n}\n\n// 公钥加密，私钥解密\nString encryptStr = ecies.encryptBase64(text.toString(), KeyType.PublicKey);\nString decryptStr = StrUtil.utf8Str(ecies.decrypt(encryptStr, KeyType.PrivateKey));\n',normalizedContent:'# 介绍\n\n对于非对称加密，最常用的就是rsa和dsa，在hutool中使用asymmetriccrypto对象来负责加密解密。\n\n非对称加密有公钥和私钥两个概念，私钥自己拥有，不能给别人，公钥公开。根据应用的不同，我们可以选择使用不同的密钥加密：\n\n 1. 签名：使用私钥加密，公钥解密。用于让所有公钥所有者验证私钥所有者的身份并且用来防止私钥所有者发布的内容被篡改，但是不用来保证内容不被他人获得。\n\n 2. 加密：用公钥加密，私钥解密。用于向公钥所有者发布信息,这个信息可能被他人篡改,但是无法被他人获得。\n\nhutool封装了jdk的，详细见https://docs.oracle.com/javase/7/docs/technotes/guides/security/standardnames.html#keypairgenerator：\n\n * rsa\n * rsa_ecb_pkcs1（rsa/ecb/pkcs1padding）\n * rsa_none（rsa/none/nopadding）\n * ecies（需要bouncy castle库）\n\n\n# 使用\n\n在非对称加密中，我们可以通过asymmetriccrypto(asymmetricalgorithm algorithm)构造方法，通过传入不同的算法枚举，获得其加密解密器。\n\n当然，为了方便，我们针对最常用的rsa算法构建了单独的对象：rsa。\n\n\n# 基本使用\n\n我们以rsa为例，介绍使用rsa加密和解密 在构建rsa对象时，可以传入公钥或私钥，当使用无参构造方法时，hutool将自动生成随机的公钥私钥密钥对：\n\nrsa rsa = new rsa();\n\n//获得私钥\nrsa.getprivatekey();\nrsa.getprivatekeybase64();\n//获得公钥\nrsa.getpublickey();\nrsa.getpublickeybase64();\n\n//公钥加密，私钥解密\nbyte[] encrypt = rsa.encrypt(strutil.bytes("我是一段测试aaaa", charsetutil.charset_utf_8), keytype.publickey);\nbyte[] decrypt = rsa.decrypt(encrypt, keytype.privatekey);\n\n//junit单元测试\n//assert.assertequals("我是一段测试aaaa", strutil.str(decrypt, charsetutil.charset_utf_8));\n\n//私钥加密，公钥解密\nbyte[] encrypt2 = rsa.encrypt(strutil.bytes("我是一段测试aaaa", charsetutil.charset_utf_8), keytype.privatekey);\nbyte[] decrypt2 = rsa.decrypt(encrypt2, keytype.publickey);\n\n//junit单元测试\n//assert.assertequals("我是一段测试aaaa", strutil.str(decrypt2, charsetutil.charset_utf_8));\n\n\n> 对于加密和解密可以完全分开，对于rsa对象，如果只使用公钥或私钥，另一个参数可以为null\n\n\n# 自助生成密钥对\n\n有时候我们想自助生成密钥对可以：\n\nkeypair pair = secureutil.generatekeypair("rsa");\npair.getprivate();\npair.getpublic();\n\n\n自助生成的密钥对是byte[]形式，我们可以使用base64.encode方法转为base64，便于存储为文本。\n\n当然，如果使用rsa对象，也可以使用encryptstr和decryptstr加密解密为字符串。\n\n\n# 案例\n\n\n# 案例一：\n\n已知私钥和密文，如何解密密文？\n\nstring private_key = "miicdqibadanbgkqhkig9w0baqefaascal8wggjbageaaogbail7pbq+5kkgyrhw7je31hma"\n\t\t+ "f8q60ybd+xzurmuo5kofbrqxgxktq9tfqi+amw+0lw/kibkzad/ekv91107xe384qoy6icubfar5lv39ocoqnz"\n\t\t+ "5l+dah5abgnvkbp9fkofhpgghbkntro0/rzfgi6q1uhxb+4atp++lnfldymjcpagmbaaecgybammgb1alndta"\n\t\t+ "xbmttlldveobmp14p04d8mhkic33ifkbcluvvxgg2vpuc+cbagyu/nzg+r/wdrlgedup6861m5befn0l9o4hz"\n\t\t+ "gaen8xyte96f8sh4vlrmbovvdwzqro+ilkom96+kl88a9rkdp8v2tna7tm6oi3lhdyf/jboxaqjbamcvn7fklyp"\n\t\t+ "skzfh/yzzw2fmc0zng/qaw8oa/wfdxlwjgns0p/ekwz8bxjr/d199l3i/kmagdfpawbyzlvyenqucqqcobjsucw"\n\t\t+ "nlzhcwajjzpssuy8/bicvepuax1fuz58mq69cqxfazemd9ar4omzueaas2/uee3kt3avcbaeq05nyjakbme8swb0ik"\n\t\t+ "klcaegujlq7cqikjsrobiquef+czvzpe+aorg+iss+cw2w/2bhu+g0p5xsyvdh59p0+zt0n+f9lfaka6v3ae56ori"\n\t\t+ "wfmhrjksfekbiamjnls9b8jyniaxg9iciyohmgkml5gabpoh/ulxqskwzbw5mj2gw1gblyasfv3aka/rjc+adijsrgg"\n\t\t+ "jokirjsmppgv3fohl9fsbpjupzbeiuomwoc8gxk/73dhxwmfnmn7c9+sii4rbcjeeq5f5fhz";\n\nrsa rsa = new rsa(private_key, null);\n\nstring a = "2707f9fd4288cef302c972058712f24a5f3ec62c5a14ad2fc59dab93503aa0fa17113a020ee4ea35eb53f"\n\t\t+ "75f36564ba1dabaa20f3b90fd39315c30e68fe8a1803b36c29029b23eb612c06acf3a34be815074f5eb5aa3a"\n\t\t+ "c0c8832ec42da725b4e1c38ef4ea1b85904f8b10b2d62ea782b813229f9090e6f7394e42e6f44494bb8";\n\nbyte[] abyte = hexutil.decodehex(a);\nbyte[] decrypt = rsa.decrypt(abyte, keytype.privatekey);\n\n//junit单元测试\n//assert.assertequals("虎头闯杭州,多抬头看天,切勿只管种地", strutil.str(decrypt, charsetutil.charset_utf_8));\n\n\n\n# 其它算法\n\n\n# ecies\n\necies全称集成加密方案（elliptic curve integrate encrypt scheme）\n\nhutool借助bouncy castle库可以支持ecies算法：\n\n我们首先需要引入bouncy castle库：\n\n<dependency>\n  <groupid>org.bouncycastle</groupid>\n  <artifactid>bcpkix-jdk18on</artifactid>\n  <version>1.78.1</version>\n</dependency>\n\n\nfinal ecies ecies = new ecies();\nfinal iesparameterspec iesparameterspec = new iesparameterspec(null, null, 128);\necies.setalgorithmparameterspec(iesparameterspec);\n\nstring textbase = "我是一段特别长的测试";\nstringbuilder text = new stringbuilder();\nfor (int i = 0; i < 10; i++) {\n\ttext.append(textbase);\n}\n\n// 公钥加密，私钥解密\nstring encryptstr = ecies.encryptbase64(text.tostring(), keytype.publickey);\nstring decryptstr = strutil.utf8str(ecies.decrypt(encryptstr, keytype.privatekey));\n',charsets:{cjk:!0},lastUpdated:"2024/11/21, 09:59:40",lastUpdatedTimestamp:173215438e4},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/dfa/index/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/08.DFA%E6%9F%A5%E6%89%BE%EF%BC%88Hutool-dfa%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/08.DFA查找（Hutool-dfa）/01.概述.md",key:"v-a075a47e",path:"/pages/dfa/index/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:3,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:133},{level:2,title:"DFA介绍",slug:"dfa介绍",normalizedTitle:"dfa介绍",charIndex:283}],headersStr:"由来 思路 DFA介绍",content:"# 由来\n\n在我最早入职的一家公司，主要负责内容方面的业务，对我来说大部分的工作是对内容的清洗和规整。当然，清洗过程免不了的就是按照关键词过滤，你懂的。需求如下：\n\n后台人员添加N个关键字，然后对主站所有的内容进行清洗，含有这些关键字的所有内容都置为无效。\n\n\n# 思路\n\n拿到此需求，我最早的方案比较粗暴：针对关键字建立一个HashSet，然后遍历整个数据库，针对每篇文章遍历这个Set，查找是否contains关键字……好吧我承认这不是一个好方法，随着关键字的增多和数据的增多，这个过程消耗的时间成指数型增长！\n\n于是我找到度娘，发现一个算法：DFA。\n\n\n# DFA介绍\n\nDFA全称为：Deterministic Finite Automaton,即确定有穷自动机。因为本人算法学的不好，有兴趣的可以看这篇博客: 基于DFA敏感词查询的算法简析\n\n解释起来原理其实也不难，就是用所有关键字构造一棵树，然后用正文遍历这棵树，遍历到叶子节点即表示文章中存在这个关键字。\n\n我们暂且忽略构建关键词树的时间，每次查找正文只需要O(n)复杂度就可以搞定。\n\n针对DFA算法以及网上的一些实现，Hutool做了整理和改进，最终形成现在的Hutool-dfa模块。",normalizedContent:"# 由来\n\n在我最早入职的一家公司，主要负责内容方面的业务，对我来说大部分的工作是对内容的清洗和规整。当然，清洗过程免不了的就是按照关键词过滤，你懂的。需求如下：\n\n后台人员添加n个关键字，然后对主站所有的内容进行清洗，含有这些关键字的所有内容都置为无效。\n\n\n# 思路\n\n拿到此需求，我最早的方案比较粗暴：针对关键字建立一个hashset，然后遍历整个数据库，针对每篇文章遍历这个set，查找是否contains关键字……好吧我承认这不是一个好方法，随着关键字的增多和数据的增多，这个过程消耗的时间成指数型增长！\n\n于是我找到度娘，发现一个算法：dfa。\n\n\n# dfa介绍\n\ndfa全称为：deterministic finite automaton,即确定有穷自动机。因为本人算法学的不好，有兴趣的可以看这篇博客: 基于dfa敏感词查询的算法简析\n\n解释起来原理其实也不难，就是用所有关键字构造一棵树，然后用正文遍历这棵树，遍历到叶子节点即表示文章中存在这个关键字。\n\n我们暂且忽略构建关键词树的时间，每次查找正文只需要o(n)复杂度就可以搞定。\n\n针对dfa算法以及网上的一些实现，hutool做了整理和改进，最终形成现在的hutool-dfa模块。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"常见问题",frontmatter:{title:"常见问题",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/db/faq/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89/08.%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html",relativePath:"01.指南/09.数据库（Hutool-db）/08.常见问题.md",key:"v-7a2ddb60",path:"/pages/db/faq/",headers:[{level:2,title:"问题描述：no suitable driver found for jdbc",slug:"问题描述-no-suitable-driver-found-for-jdbc",normalizedTitle:"问题描述：no suitable driver found for jdbc",charIndex:2}],headersStr:"问题描述：no suitable driver found for jdbc",content:"# 问题描述：no suitable driver found for jdbc\n\n\n\n解答：出现此类问题一般是JDBC驱动版本不一致导致的，出现此问题的用户使用的是ojdbc14，服务端使用Oracle11g，JDK8，此处升级到ojdbc6即可。\n\n版本对应见：https://www.oracle.com/technetwork/database/application-development/jdbc/downloads/index.html",normalizedContent:"# 问题描述：no suitable driver found for jdbc\n\n\n\n解答：出现此类问题一般是jdbc驱动版本不一致导致的，出现此问题的用户使用的是ojdbc14，服务端使用oracle11g，jdk8，此处升级到ojdbc6即可。\n\n版本对应见：https://www.oracle.com/technetwork/database/application-development/jdbc/downloads/index.html",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Http客户端工具类-HttpUtil",frontmatter:{title:"Http客户端工具类-HttpUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/HttpUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/01.Http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%B1%BB-HttpUtil.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/01.Http客户端工具类-HttpUtil.md",key:"v-4d53113a",path:"/pages/HttpUtil/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:135},{level:3,title:"请求普通页面",slug:"请求普通页面",normalizedTitle:"请求普通页面",charIndex:142},{level:3,title:"文件上传",slug:"文件上传",normalizedTitle:"文件上传",charIndex:125},{level:3,title:"下载文件",slug:"下载文件",normalizedTitle:"下载文件",charIndex:1117},{level:3,title:"更多有用的工具方法",slug:"更多有用的工具方法",normalizedTitle:"更多有用的工具方法",charIndex:2057},{level:3,title:"更多请求参数",slug:"更多请求参数",normalizedTitle:"更多请求参数",charIndex:2336},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:2395}],headersStr:"概述 使用 请求普通页面 文件上传 下载文件 更多有用的工具方法 更多请求参数 注意事项",content:'# 概述\n\nHttpUtil是应对简单场景下Http请求的工具类封装，此工具封装了HttpRequest对象常用操作，可以保证在一个方法之内完成Http请求。\n\n此模块基于JDK的HttpUrlConnection封装完成，完整支持https、代理和文件上传。\n\n\n# 使用\n\n\n# 请求普通页面\n\n针对最为常用的GET和POST请求，HttpUtil封装了两个方法，\n\n * HttpUtil.get\n * HttpUtil.post\n\n这两个方法用于请求普通页面，然后返回页面内容的字符串，同时提供一些重载方法用于指定请求参数（指定参数支持File对象，可实现文件上传，当然仅仅针对POST请求）。\n\nGET请求栗子：\n\n// 最简单的HTTP请求，可以自动通过header等信息判断编码，不区分HTTP和HTTPS\nString result1= HttpUtil.get("https://www.baidu.com");\n\n// 当无法识别页面编码的时候，可以自定义请求页面的编码\nString result2= HttpUtil.get("https://www.baidu.com", CharsetUtil.CHARSET_UTF_8);\n\n//可以单独传入http参数，这样参数会自动做URL编码，拼接在URL中\nHashMap<String, Object> paramMap = new HashMap<>();\nparamMap.put("city", "北京");\n\nString result3= HttpUtil.get("https://www.baidu.com", paramMap);\n\n\nPOST请求例子：\n\nHashMap<String, Object> paramMap = new HashMap<>();\nparamMap.put("city", "北京");\n\nString result= HttpUtil.post("https://www.baidu.com", paramMap);\n\n\n\n# 文件上传\n\nHashMap<String, Object> paramMap = new HashMap<>();\n//文件上传只需将参数中的键指定（默认file），值设为文件对象即可，对于使用者来说，文件上传与普通表单提交并无区别\nparamMap.put("file", FileUtil.file("D:\\\\face.jpg"));\n\nString result= HttpUtil.post("https://www.baidu.com", paramMap);\n\n\n\n# 下载文件\n\n因为Hutool-http机制问题，请求页面返回结果是一次性解析为byte[]的，如果请求URL返回结果太大（比如文件下载），那内存会爆掉，因此针对文件下载HttpUtil单独做了封装。文件下载在面对大文件时采用流的方式读写，内存中只是保留一定量的缓存，然后分块写入硬盘，因此大文件情况下不会对内存有压力。\n\nString fileUrl = "http://mirrors.sohu.com/centos/8.4.2105/isos/x86_64/CentOS-8.4.2105-x86_64-dvd1.iso";\n\n//将文件下载后保存在E盘，返回结果为下载文件大小\nlong size = HttpUtil.downloadFile(fileUrl, FileUtil.file("e:/"));\nSystem.out.println("Download size: " + size);\n\n\n当然，如果我们想感知下载进度，还可以使用另一个重载方法回调感知下载进度：\n\n//带进度显示的文件下载\nHttpUtil.downloadFile(fileUrl, FileUtil.file("e:/"), new StreamProgress(){\n\t\n\t@Override\n\tpublic void start() {\n\t\tConsole.log("开始下载。。。。");\n\t}\n\t\n\t@Override\n\tpublic void progress(long progressSize) {\n\t\tConsole.log("已下载：{}", FileUtil.readableFileSize(progressSize));\n\t}\n\t\n\t@Override\n\tpublic void finish() {\n\t\tConsole.log("下载完成！");\n\t}\n});\n\n\nStreamProgress接口实现后可以感知下载过程中的各个阶段。\n\n当然，工具类提供了一个更加抽象的方法：HttpUtil.download，此方法会请求URL，将返回内容写入到指定的OutputStream中。使用这个方法，可以更加灵活的将HTTP内容转换写出，以适应更多场景。\n\n\n# 更多有用的工具方法\n\n * HttpUtil.encodeParams 对URL参数做编码，只编码键和值，提供的值可以是url附带参数，但是不能只是url\n * HttpUtil.toParams和HttpUtil.decodeParams 两个方法是将Map参数转为URL参数字符串和将URL参数字符串转为Map对象\n * HttpUtil.urlWithForm是将URL字符串和Map参数拼接为GET请求所用的完整字符串使用\n * HttpUtil.getMimeType 根据文件扩展名快速获取其MimeType（参数也可以是完整文件路径）\n\n\n# 更多请求参数\n\n如果想设置头信息、超时、代理等信息，请见下一章节《Http客户端-HttpRequest》。\n\n\n# 注意事项\n\n默认的超时时间是-1表示永不超时 这里实际项目一定要进行修改，防止把系统拖死.\n\n/**\n * -1: 含义，永不超时。\n * 如果：设置timeout = 3s(3000 ms), 那一次请求最大超时：就是：6s\n * 官方含义：timeout of zero is interpreted as an infinite timeout. （0的超时被解释为无限超时。）\n * 这里实际项目一定要进行修改，防止把系统拖死.\n * 底层调用：{@link HttpURLConnection#setReadTimeout(int)} 同时设置: 读取超时\n * 底层调用：{@link HttpURLConnection#setConnectTimeout(int)} 同时设置: 连接超时\n */\nprivate static int timeout = -1;\n',normalizedContent:'# 概述\n\nhttputil是应对简单场景下http请求的工具类封装，此工具封装了httprequest对象常用操作，可以保证在一个方法之内完成http请求。\n\n此模块基于jdk的httpurlconnection封装完成，完整支持https、代理和文件上传。\n\n\n# 使用\n\n\n# 请求普通页面\n\n针对最为常用的get和post请求，httputil封装了两个方法，\n\n * httputil.get\n * httputil.post\n\n这两个方法用于请求普通页面，然后返回页面内容的字符串，同时提供一些重载方法用于指定请求参数（指定参数支持file对象，可实现文件上传，当然仅仅针对post请求）。\n\nget请求栗子：\n\n// 最简单的http请求，可以自动通过header等信息判断编码，不区分http和https\nstring result1= httputil.get("https://www.baidu.com");\n\n// 当无法识别页面编码的时候，可以自定义请求页面的编码\nstring result2= httputil.get("https://www.baidu.com", charsetutil.charset_utf_8);\n\n//可以单独传入http参数，这样参数会自动做url编码，拼接在url中\nhashmap<string, object> parammap = new hashmap<>();\nparammap.put("city", "北京");\n\nstring result3= httputil.get("https://www.baidu.com", parammap);\n\n\npost请求例子：\n\nhashmap<string, object> parammap = new hashmap<>();\nparammap.put("city", "北京");\n\nstring result= httputil.post("https://www.baidu.com", parammap);\n\n\n\n# 文件上传\n\nhashmap<string, object> parammap = new hashmap<>();\n//文件上传只需将参数中的键指定（默认file），值设为文件对象即可，对于使用者来说，文件上传与普通表单提交并无区别\nparammap.put("file", fileutil.file("d:\\\\face.jpg"));\n\nstring result= httputil.post("https://www.baidu.com", parammap);\n\n\n\n# 下载文件\n\n因为hutool-http机制问题，请求页面返回结果是一次性解析为byte[]的，如果请求url返回结果太大（比如文件下载），那内存会爆掉，因此针对文件下载httputil单独做了封装。文件下载在面对大文件时采用流的方式读写，内存中只是保留一定量的缓存，然后分块写入硬盘，因此大文件情况下不会对内存有压力。\n\nstring fileurl = "http://mirrors.sohu.com/centos/8.4.2105/isos/x86_64/centos-8.4.2105-x86_64-dvd1.iso";\n\n//将文件下载后保存在e盘，返回结果为下载文件大小\nlong size = httputil.downloadfile(fileurl, fileutil.file("e:/"));\nsystem.out.println("download size: " + size);\n\n\n当然，如果我们想感知下载进度，还可以使用另一个重载方法回调感知下载进度：\n\n//带进度显示的文件下载\nhttputil.downloadfile(fileurl, fileutil.file("e:/"), new streamprogress(){\n\t\n\t@override\n\tpublic void start() {\n\t\tconsole.log("开始下载。。。。");\n\t}\n\t\n\t@override\n\tpublic void progress(long progresssize) {\n\t\tconsole.log("已下载：{}", fileutil.readablefilesize(progresssize));\n\t}\n\t\n\t@override\n\tpublic void finish() {\n\t\tconsole.log("下载完成！");\n\t}\n});\n\n\nstreamprogress接口实现后可以感知下载过程中的各个阶段。\n\n当然，工具类提供了一个更加抽象的方法：httputil.download，此方法会请求url，将返回内容写入到指定的outputstream中。使用这个方法，可以更加灵活的将http内容转换写出，以适应更多场景。\n\n\n# 更多有用的工具方法\n\n * httputil.encodeparams 对url参数做编码，只编码键和值，提供的值可以是url附带参数，但是不能只是url\n * httputil.toparams和httputil.decodeparams 两个方法是将map参数转为url参数字符串和将url参数字符串转为map对象\n * httputil.urlwithform是将url字符串和map参数拼接为get请求所用的完整字符串使用\n * httputil.getmimetype 根据文件扩展名快速获取其mimetype（参数也可以是完整文件路径）\n\n\n# 更多请求参数\n\n如果想设置头信息、超时、代理等信息，请见下一章节《http客户端-httprequest》。\n\n\n# 注意事项\n\n默认的超时时间是-1表示永不超时 这里实际项目一定要进行修改，防止把系统拖死.\n\n/**\n * -1: 含义，永不超时。\n * 如果：设置timeout = 3s(3000 ms), 那一次请求最大超时：就是：6s\n * 官方含义：timeout of zero is interpreted as an infinite timeout. （0的超时被解释为无限超时。）\n * 这里实际项目一定要进行修改，防止把系统拖死.\n * 底层调用：{@link httpurlconnection#setreadtimeout(int)} 同时设置: 读取超时\n * 底层调用：{@link httpurlconnection#setconnecttimeout(int)} 同时设置: 连接超时\n */\nprivate static int timeout = -1;\n',charsets:{cjk:!0},lastUpdated:"2024/08/20, 18:17:21",lastUpdatedTimestamp:1724149041e3},{title:"HTML工具类-HtmlUtil",frontmatter:{title:"HTML工具类-HtmlUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/HtmlUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/02.HTML%E5%B7%A5%E5%85%B7%E7%B1%BB-HtmlUtil.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/02.HTML工具类-HtmlUtil.md",key:"v-be476018",path:"/pages/HtmlUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:149},{level:3,title:"HtmlUtil.escape",slug:"htmlutil-escape",normalizedTitle:"htmlutil.escape",charIndex:156},{level:3,title:"HtmlUtil.unescape",slug:"htmlutil-unescape",normalizedTitle:"htmlutil.unescape",charIndex:442},{level:3,title:"HtmlUtil.removeHtmlTag",slug:"htmlutil-removehtmltag",normalizedTitle:"htmlutil.removehtmltag",charIndex:657},{level:3,title:"HtmlUtil.cleanHtmlTag",slug:"htmlutil-cleanhtmltag",normalizedTitle:"htmlutil.cleanhtmltag",charIndex:824},{level:3,title:"HtmlUtil.unwrapHtmlTag",slug:"htmlutil-unwraphtmltag",normalizedTitle:"htmlutil.unwraphtmltag",charIndex:1064},{level:3,title:"HtmlUtil.removeHtmlAttr",slug:"htmlutil-removehtmlattr",normalizedTitle:"htmlutil.removehtmlattr",charIndex:1230},{level:3,title:"HtmlUtil.removeAllHtmlAttr",slug:"htmlutil-removeallhtmlattr",normalizedTitle:"htmlutil.removeallhtmlattr",charIndex:1460},{level:3,title:"HtmlUtil.filter 过滤HTML文本，防止XSS攻击",slug:"htmlutil-filter-过滤html文本-防止xss攻击",normalizedTitle:"htmlutil.filter 过滤html文本，防止xss攻击",charIndex:1644}],headersStr:"由来 方法 HtmlUtil.escape HtmlUtil.unescape HtmlUtil.removeHtmlTag HtmlUtil.cleanHtmlTag HtmlUtil.unwrapHtmlTag HtmlUtil.removeHtmlAttr HtmlUtil.removeAllHtmlAttr HtmlUtil.filter 过滤HTML文本，防止XSS攻击",content:'# 由来\n\n针对Http请求中返回的Http内容，Hutool使用此工具类来处理一些HTML页面相关的事情。\n\n比如我们在使用爬虫爬取HTML页面后，需要对返回页面的HTML内容做一定处理，比如去掉指定标签（例如广告栏等）、去除JS、去掉样式等等，这些操作都可以使用HtmlUtil完成。\n\n\n# 方法\n\n\n# HtmlUtil.escape\n\n转义HTML特殊字符，包括：\n\n 1. \' 替换为 &#039;\n 2. " 替换为 &quot;\n 3. & 替换为 &amp;\n 4. < 替换为 &lt;\n 5. > 替换为 &gt;\n\nString html = "<html><body>123\'123\'</body></html>";\n// 结果为：&lt;html&gt;&lt;body&gt;123&#039;123&#039;&lt;/body&gt;&lt;/html&gt;\nString escape = HtmlUtil.escape(html);\n\n\n\n# HtmlUtil.unescape\n\n还原被转义的HTML特殊字符\n\nString escape = "&lt;html&gt;&lt;body&gt;123&#039;123&#039;&lt;/body&gt;&lt;/html&gt;";\n// 结果为：<html><body>123\'123\'</body></html>\nString unescape = HtmlUtil.unescape(escape);\n\n\n\n# HtmlUtil.removeHtmlTag\n\n清除指定HTML标签和被标签包围的内容\n\nString str = "pre<img src=\\"xxx/dfdsfds/test.jpg\\">";\n// 结果为：pre\nString result = HtmlUtil.removeHtmlTag(str, "img");\n\n\n\n# HtmlUtil.cleanHtmlTag\n\n清除所有HTML标签，但是保留标签内的内容\n\nString str = "pre<div class=\\"test_div\\">\\r\\n\\t\\tdfdsfdsfdsf\\r\\n</div><div class=\\"test_div\\">BBBB</div>";\n// 结果为：pre\\r\\n\\t\\tdfdsfdsfdsf\\r\\nBBBB\nString result = HtmlUtil.cleanHtmlTag(str);\n\n\n\n# HtmlUtil.unwrapHtmlTag\n\n清除指定HTML标签，不包括内容\n\nString str = "pre<div class=\\"test_div\\">abc</div>";\n// 结果为：preabc\nString result = HtmlUtil.unwrapHtmlTag(str, "div");\n\n\n\n# HtmlUtil.removeHtmlAttr\n\n去除HTML标签中的指定属性，如果多个标签有相同属性，都去除\n\nString html = "<div class=\\"test_div\\"></div><span class=\\"test_div\\"></span>";\n// 结果为：<div></div><span></span>\nString result = HtmlUtil.removeHtmlAttr(html, "class");\n\n\n\n# HtmlUtil.removeAllHtmlAttr\n\n去除指定标签的所有属性\n\nString html = "<div class=\\"test_div\\" width=\\"120\\"></div>";\n// 结果为：<div></div>\nString result = HtmlUtil.removeAllHtmlAttr(html, "div");\n\n\n\n# HtmlUtil.filter 过滤HTML文本，防止XSS攻击\n\nString html = "<alert></alert>";\n// 结果为：""\nString filter = HtmlUtil.filter(html);\n',normalizedContent:'# 由来\n\n针对http请求中返回的http内容，hutool使用此工具类来处理一些html页面相关的事情。\n\n比如我们在使用爬虫爬取html页面后，需要对返回页面的html内容做一定处理，比如去掉指定标签（例如广告栏等）、去除js、去掉样式等等，这些操作都可以使用htmlutil完成。\n\n\n# 方法\n\n\n# htmlutil.escape\n\n转义html特殊字符，包括：\n\n 1. \' 替换为 &#039;\n 2. " 替换为 &quot;\n 3. & 替换为 &amp;\n 4. < 替换为 &lt;\n 5. > 替换为 &gt;\n\nstring html = "<html><body>123\'123\'</body></html>";\n// 结果为：&lt;html&gt;&lt;body&gt;123&#039;123&#039;&lt;/body&gt;&lt;/html&gt;\nstring escape = htmlutil.escape(html);\n\n\n\n# htmlutil.unescape\n\n还原被转义的html特殊字符\n\nstring escape = "&lt;html&gt;&lt;body&gt;123&#039;123&#039;&lt;/body&gt;&lt;/html&gt;";\n// 结果为：<html><body>123\'123\'</body></html>\nstring unescape = htmlutil.unescape(escape);\n\n\n\n# htmlutil.removehtmltag\n\n清除指定html标签和被标签包围的内容\n\nstring str = "pre<img src=\\"xxx/dfdsfds/test.jpg\\">";\n// 结果为：pre\nstring result = htmlutil.removehtmltag(str, "img");\n\n\n\n# htmlutil.cleanhtmltag\n\n清除所有html标签，但是保留标签内的内容\n\nstring str = "pre<div class=\\"test_div\\">\\r\\n\\t\\tdfdsfdsfdsf\\r\\n</div><div class=\\"test_div\\">bbbb</div>";\n// 结果为：pre\\r\\n\\t\\tdfdsfdsfdsf\\r\\nbbbb\nstring result = htmlutil.cleanhtmltag(str);\n\n\n\n# htmlutil.unwraphtmltag\n\n清除指定html标签，不包括内容\n\nstring str = "pre<div class=\\"test_div\\">abc</div>";\n// 结果为：preabc\nstring result = htmlutil.unwraphtmltag(str, "div");\n\n\n\n# htmlutil.removehtmlattr\n\n去除html标签中的指定属性，如果多个标签有相同属性，都去除\n\nstring html = "<div class=\\"test_div\\"></div><span class=\\"test_div\\"></span>";\n// 结果为：<div></div><span></span>\nstring result = htmlutil.removehtmlattr(html, "class");\n\n\n\n# htmlutil.removeallhtmlattr\n\n去除指定标签的所有属性\n\nstring html = "<div class=\\"test_div\\" width=\\"120\\"></div>";\n// 结果为：<div></div>\nstring result = htmlutil.removeallhtmlattr(html, "div");\n\n\n\n# htmlutil.filter 过滤html文本，防止xss攻击\n\nstring html = "<alert></alert>";\n// 结果为：""\nstring filter = htmlutil.filter(html);\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"常用Http状态码-HttpStatus",frontmatter:{title:"常用Http状态码-HttpStatus",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/HttpStatus/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/06.%E5%B8%B8%E7%94%A8Http%E7%8A%B6%E6%80%81%E7%A0%81-HttpStatus.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/06.常用Http状态码-HttpStatus.md",key:"v-348eef76",path:"/pages/HttpStatus/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2}],headersStr:"介绍",content:"# 介绍\n\n针对Http响应，Hutool封装了一个类用于保存Http状态码\n\n此类用于保存一些状态码的别名，例如：\n\n/**\n* HTTP Status-Code 200: OK.\n*/\npublic static final int HTTP_OK = 200;\n",normalizedContent:"# 介绍\n\n针对http响应，hutool封装了一个类用于保存http状态码\n\n此类用于保存一些状态码的别名，例如：\n\n/**\n* http status-code 200: ok.\n*/\npublic static final int http_ok = 200;\n",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Http响应-HttpResponse",frontmatter:{title:"Http响应-HttpResponse",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/HttpResponse/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/03.Http%E5%93%8D%E5%BA%94-HttpResponse.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/03.Http响应-HttpResponse.md",key:"v-255e37bd",path:"/pages/HttpResponse/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:207},{level:3,title:"获取响应状态码",slug:"获取响应状态码",normalizedTitle:"获取响应状态码",charIndex:281},{level:3,title:"获取响应头信息",slug:"获取响应头信息",normalizedTitle:"获取响应头信息",charIndex:377}],headersStr:"介绍 使用 获取响应状态码 获取响应头信息",content:'# 介绍\n\nHttpResponse是HttpRequest执行execute()方法后返回的一个对象，我们可以通过此对象获取服务端返回的：\n\n * Http状态码（getStatus方法）\n * 返回内容编码（contentEncoding方法）\n * 是否Gzip内容（isGzip方法）\n * 返回内容（body、bodyBytes、bodyStream方法）\n * 响应头信息（header方法）\n\n\n# 使用\n\n此对象的使用非常简单，最常用的便是body方法，会返回Http响应内容字符串。如果想获取byte[]则调用bodyBytes即可。\n\n\n# 获取响应状态码\n\nHttpResponse res = HttpRequest.post(url).execute();\nConsole.log(res.getStatus());\n\n\n\n# 获取响应头信息\n\nHttpResponse res = HttpRequest.post(url).execute();\n//预定义的头信息\nConsole.log(res.header(Header.CONTENT_ENCODING));\n//自定义头信息\nConsole.log(res.header("Content-Disposition"));\n',normalizedContent:'# 介绍\n\nhttpresponse是httprequest执行execute()方法后返回的一个对象，我们可以通过此对象获取服务端返回的：\n\n * http状态码（getstatus方法）\n * 返回内容编码（contentencoding方法）\n * 是否gzip内容（isgzip方法）\n * 返回内容（body、bodybytes、bodystream方法）\n * 响应头信息（header方法）\n\n\n# 使用\n\n此对象的使用非常简单，最常用的便是body方法，会返回http响应内容字符串。如果想获取byte[]则调用bodybytes即可。\n\n\n# 获取响应状态码\n\nhttpresponse res = httprequest.post(url).execute();\nconsole.log(res.getstatus());\n\n\n\n# 获取响应头信息\n\nhttpresponse res = httprequest.post(url).execute();\n//预定义的头信息\nconsole.log(res.header(header.content_encoding));\n//自定义头信息\nconsole.log(res.header("content-disposition"));\n',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"UA工具类-UserAgentUtil",frontmatter:{title:"UA工具类-UserAgentUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/UserAgentUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/05.UA%E5%B7%A5%E5%85%B7%E7%B1%BB-UserAgentUtil.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/05.UA工具类-UserAgentUtil.md",key:"v-6c230934",path:"/pages/UserAgentUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:53},{level:3,title:"获取UA信息",slug:"获取ua信息",normalizedTitle:"获取ua信息",charIndex:276},{level:3,title:"判断终端是否为移动终端",slug:"判断终端是否为移动终端",normalizedTitle:"判断终端是否为移动终端",charIndex:570}],headersStr:"由来 使用 获取UA信息 判断终端是否为移动终端",content:'# 由来\n\nUser Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、浏览器及版本、浏览器渲染引擎等。\n\nHutool在4.2.1之后支持User-Agent的解析。\n\n\n# 使用\n\n以桌面浏览器为例，假设你已经获取了用户的UA：\n\nString uaStr = "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1";\n\n\n\n# 获取UA信息\n\n我们可以借助UserAgentUtil.parse方法解析：\n\nUserAgent ua = UserAgentUtil.parse(uaStr);\n\nua.getBrowser().toString();//Chrome\nua.getVersion();//14.0.835.163\nua.getEngine().toString();//Webkit\nua.getEngineVersion();//535.1\nua.getOs().toString();//Windows 7\nua.getPlatform().toString();//Windows\n\n\n\n\n# 判断终端是否为移动终端\n\nua.isMobile();\n',normalizedContent:'# 由来\n\nuser agent中文名为用户代理，简称 ua，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、浏览器及版本、浏览器渲染引擎等。\n\nhutool在4.2.1之后支持user-agent的解析。\n\n\n# 使用\n\n以桌面浏览器为例，假设你已经获取了用户的ua：\n\nstring uastr = "mozilla/5.0 (windows nt 6.1; wow64) applewebkit/535.1 (khtml, like gecko) chrome/14.0.835.163 safari/535.1";\n\n\n\n# 获取ua信息\n\n我们可以借助useragentutil.parse方法解析：\n\nuseragent ua = useragentutil.parse(uastr);\n\nua.getbrowser().tostring();//chrome\nua.getversion();//14.0.835.163\nua.getengine().tostring();//webkit\nua.getengineversion();//535.1\nua.getos().tostring();//windows 7\nua.getplatform().tostring();//windows\n\n\n\n\n# 判断终端是否为移动终端\n\nua.ismobile();\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"案例1-爬取开源中国的开源资讯",frontmatter:{title:"案例1-爬取开源中国的开源资讯",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/http/example/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/07.%E6%A1%88%E4%BE%8B1-%E7%88%AC%E5%8F%96%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%BC%80%E6%BA%90%E8%B5%84%E8%AE%AF.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/07.案例1-爬取开源中国的开源资讯.md",key:"v-4a528fa0",path:"/pages/http/example/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"开始",slug:"开始",normalizedTitle:"开始",charIndex:66},{level:3,title:"分析页面",slug:"分析页面",normalizedTitle:"分析页面",charIndex:73},{level:3,title:"模拟Http请求爬取页面",slug:"模拟http请求爬取页面",normalizedTitle:"模拟http请求爬取页面",charIndex:501},{level:2,title:"结语",slug:"结语",normalizedTitle:"结语",charIndex:1266}],headersStr:"介绍 开始 分析页面 模拟Http请求爬取页面 结语",content:'# 介绍\n\n为了演示Hutool-http的http请求功能，因此这个栗子用红薯家的开源资讯开刀，在此做个简单的Demo。\n\n\n# 开始\n\n\n# 分析页面\n\n 1. 打开红薯家的主页，我们找到最显眼的开源资讯模块，然后点击“更多”，打开“开源资讯”板块。\n\n\n\n 2. 打开F12调试器，点击快捷键F12打开Chrome的调试器，点击“Network”选项卡，然后在页面上点击“全部资讯”。\n\n\n\n\n\n 3. 由于红薯家的列表页是通过下拉翻页的，因此下拉到底部会触发第二页的加载，此时我们下拉到底部，然后观察调试器中是否有新的请求出现。如图，我们发现第二个请求是列表页的第二页。\n\n\n\n 4. 我们打开这个请求地址，可以看到纯纯的内容。红框所指地址为第二页的内容，很明显p参数代表了页码page。\n\n\n\n 5. 我们右键点击后查看源码，可以看到源码。\n\n\n\n 6. 找到标题部分的HTML源码，然后搜索这个包围标题的HTML部分，看是否可以定位标题。\n\n\n\n\n\n至此分析完毕，我们拿到了列表页的地址，也拿到了可以定位标题的相关字符（在后面用正则提取标题用），就可以开始使用Hutool编码了。\n\n\n# 模拟Http请求爬取页面\n\n使用Hutool-http配合ReUtil请求并提取页面内容非常简单，代码如下：\n\n//请求列表页\nString listContent = HttpUtil.get("https://www.oschina.net/action/ajax/get_more_news_list?newsType=&p=2");\n//使用正则获取所有标题\nList<String> titles = ReUtil.findAll("<span class=\\"text-ellipsis\\">(.*?)</span>", listContent, 1);\nfor (String title : titles) {\n\t//打印标题\n\tConsole.log(title);\n}\n\n\n抓取结果为：\n\n其实核心就前两行代码，第一行请求页面内容，第二行正则定位所有标题行并提取标题部分。\n\n这里我解释下正则部分：ReUtil.findAll方法用于查找所有匹配正则表达式的内容部分，第二个参数1表示提取第一个括号（分组）中的内容，0表示提取所有正则匹配到的内容。这个方法可以看下core模块中ReUtil章节了解详情。\n\n<span class=\\"text-ellipsis\\">(.*?)</span>这个正则就是我们上面分析页面源码后得到的正则，其中(.*?)表示我们需要的内容，.表示任意字符，*表示0个或多个，?表示最短匹配，整个正则的意思就是。，以<span class=\\"text-ellipsis\\">开头，</span>结尾的中间所有字符，中间的字符要达到最短。?的作用其实就是将范围限制到最小，不然</span>很可能匹配到后面去了。\n\n关于正则表达式这块可以看下我的博客：正则表达式简明参考\n\n\n# 结语\n\n不得不说，抓取本身并不困难，尤其配合Hutool会让这项工作变得更加简单快速，而其中的难点便是分析页面和定位我们需要的内容。\n\n真正的内容抓取分为四个部分：\n\n * 找到列表页（很多网站都没有一个总的列表页）\n * 请求列表页，获取详情页地址\n * 请求详情页并使用正则匹配我们需要的内容\n * 入库或将内容保存为文件\n\n而且在抓取过程中我们也会遇到各种问题，包括但不限于：\n\n * 封IP\n * 对请求Header有特殊要求\n * 对Cookie有特殊要求\n * 验证码\n\n这些问题都有一些解决办法，具体要在具体的开发中分析解决。\n\n希望大家看到这个栗子有所启发，也为Hutool提供更多更好的意见~',normalizedContent:'# 介绍\n\n为了演示hutool-http的http请求功能，因此这个栗子用红薯家的开源资讯开刀，在此做个简单的demo。\n\n\n# 开始\n\n\n# 分析页面\n\n 1. 打开红薯家的主页，我们找到最显眼的开源资讯模块，然后点击“更多”，打开“开源资讯”板块。\n\n\n\n 2. 打开f12调试器，点击快捷键f12打开chrome的调试器，点击“network”选项卡，然后在页面上点击“全部资讯”。\n\n\n\n\n\n 3. 由于红薯家的列表页是通过下拉翻页的，因此下拉到底部会触发第二页的加载，此时我们下拉到底部，然后观察调试器中是否有新的请求出现。如图，我们发现第二个请求是列表页的第二页。\n\n\n\n 4. 我们打开这个请求地址，可以看到纯纯的内容。红框所指地址为第二页的内容，很明显p参数代表了页码page。\n\n\n\n 5. 我们右键点击后查看源码，可以看到源码。\n\n\n\n 6. 找到标题部分的html源码，然后搜索这个包围标题的html部分，看是否可以定位标题。\n\n\n\n\n\n至此分析完毕，我们拿到了列表页的地址，也拿到了可以定位标题的相关字符（在后面用正则提取标题用），就可以开始使用hutool编码了。\n\n\n# 模拟http请求爬取页面\n\n使用hutool-http配合reutil请求并提取页面内容非常简单，代码如下：\n\n//请求列表页\nstring listcontent = httputil.get("https://www.oschina.net/action/ajax/get_more_news_list?newstype=&p=2");\n//使用正则获取所有标题\nlist<string> titles = reutil.findall("<span class=\\"text-ellipsis\\">(.*?)</span>", listcontent, 1);\nfor (string title : titles) {\n\t//打印标题\n\tconsole.log(title);\n}\n\n\n抓取结果为：\n\n其实核心就前两行代码，第一行请求页面内容，第二行正则定位所有标题行并提取标题部分。\n\n这里我解释下正则部分：reutil.findall方法用于查找所有匹配正则表达式的内容部分，第二个参数1表示提取第一个括号（分组）中的内容，0表示提取所有正则匹配到的内容。这个方法可以看下core模块中reutil章节了解详情。\n\n<span class=\\"text-ellipsis\\">(.*?)</span>这个正则就是我们上面分析页面源码后得到的正则，其中(.*?)表示我们需要的内容，.表示任意字符，*表示0个或多个，?表示最短匹配，整个正则的意思就是。，以<span class=\\"text-ellipsis\\">开头，</span>结尾的中间所有字符，中间的字符要达到最短。?的作用其实就是将范围限制到最小，不然</span>很可能匹配到后面去了。\n\n关于正则表达式这块可以看下我的博客：正则表达式简明参考\n\n\n# 结语\n\n不得不说，抓取本身并不困难，尤其配合hutool会让这项工作变得更加简单快速，而其中的难点便是分析页面和定位我们需要的内容。\n\n真正的内容抓取分为四个部分：\n\n * 找到列表页（很多网站都没有一个总的列表页）\n * 请求列表页，获取详情页地址\n * 请求详情页并使用正则匹配我们需要的内容\n * 入库或将内容保存为文件\n\n而且在抓取过程中我们也会遇到各种问题，包括但不限于：\n\n * 封ip\n * 对请求header有特殊要求\n * 对cookie有特殊要求\n * 验证码\n\n这些问题都有一些解决办法，具体要在具体的开发中分析解决。\n\n希望大家看到这个栗子有所启发，也为hutool提供更多更好的意见~',charsets:{cjk:!0},lastUpdated:"2023/10/20, 18:44:16",lastUpdatedTimestamp:1697798656e3},{title:"常见问题",frontmatter:{title:"常见问题",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/http/faq/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/08.%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/08.常见问题.md",key:"v-0092eada",path:"/pages/http/faq/",headers:[{level:2,title:"Received fatal alert: handshake_failure 错误",slug:"received-fatal-alert-handshake-failure-错误",normalizedTitle:"received fatal alert: handshake_failure 错误",charIndex:2}],headersStr:"Received fatal alert: handshake_failure 错误",content:'# Received fatal alert: handshake_failure 错误\n\n\n\n用户错误如图，场景为使用Hutool-http请求https服务器，原因是JDK中的JCE安全机制导致的问题解决方法如下：\n\n * 方法1：如果你使用的是JDK8，请升级到JDK8的最新版本（例如jdk1.8.0_181）。\n * 方法2：尝试添加以下代码：\n\nSystem.setProperty("https.protocols", "TLSv1.2,TLSv1.1,SSLv3");\n',normalizedContent:'# received fatal alert: handshake_failure 错误\n\n\n\n用户错误如图，场景为使用hutool-http请求https服务器，原因是jdk中的jce安全机制导致的问题解决方法如下：\n\n * 方法1：如果你使用的是jdk8，请升级到jdk8的最新版本（例如jdk1.8.0_181）。\n * 方法2：尝试添加以下代码：\n\nsystem.setproperty("https.protocols", "tlsv1.2,tlsv1.1,sslv3");\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"MongoDB客户端封装-MongoDS",frontmatter:{title:"MongoDB客户端封装-MongoDS",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/MongoDS/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89/09.NoSQL/02.MongoDB%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B0%81%E8%A3%85-MongoDS.html",relativePath:"01.指南/09.数据库（Hutool-db）/09.NoSQL/02.MongoDB客户端封装-MongoDS.md",key:"v-79b77597",path:"/pages/MongoDS/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:27},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:62},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:52},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:211},{level:3,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:62}],headersStr:"介绍 使用 引入依赖 配置 使用",content:'# MongoDB客户端封装-MongoDS\n\n\n# 介绍\n\n针对MongoDB客户端封装。客户端需自行引入依赖。\n\n\n# 使用\n\n\n# 引入依赖\n\n<dependency>\n\t<groupId>org.mongodb</groupId>\n\t<artifactId>mongo-java-driver</artifactId>\n\t<version>3.12.10</version>\n</dependency>\n\n\n\n# 配置\n\n在ClassPath（或者src/main/resources）的config目录下新建mongo.setting\n\n#每个主机答应的连接数（每个主机的连接池大小），当连接池被用光时，会被阻塞住 ，默以为10 --int\nconnectionsPerHost=100\n#线程队列数，它以connectionsPerHost值相乘的结果就是线程队列最大值。如果连接线程排满了队列就会抛出“Out of semaphores to get db”错误 --int\nthreadsAllowedToBlockForConnectionMultiplier=10\n#被阻塞线程从连接池获取连接的最长等待时间（ms） --int\nmaxWaitTime = 120000\n#在建立（打开）套接字连接时的超时时间（ms），默以为0（无穷） --int\nconnectTimeout=0\n#套接字超时时间;该值会被传递给Socket.setSoTimeout(int)。默以为0（无穷） --int\nsocketTimeout=0\n#是否打开长连接. defaults to false --boolean\nsocketKeepAlive=false\n\n#---------------------------------- MongoDB实例连接\n[master]\nhost = 127.0.0.1:27017\n\n[slave]\nhost = 127.0.0.1:27018\n#-----------------------------------------------------\n\n\n\n# 使用\n\n//master slave 组成主从集群\nMongoDatabase db = MongoFactory.getDS("master", "slave").getDb("test");\n',normalizedContent:'# mongodb客户端封装-mongods\n\n\n# 介绍\n\n针对mongodb客户端封装。客户端需自行引入依赖。\n\n\n# 使用\n\n\n# 引入依赖\n\n<dependency>\n\t<groupid>org.mongodb</groupid>\n\t<artifactid>mongo-java-driver</artifactid>\n\t<version>3.12.10</version>\n</dependency>\n\n\n\n# 配置\n\n在classpath（或者src/main/resources）的config目录下新建mongo.setting\n\n#每个主机答应的连接数（每个主机的连接池大小），当连接池被用光时，会被阻塞住 ，默以为10 --int\nconnectionsperhost=100\n#线程队列数，它以connectionsperhost值相乘的结果就是线程队列最大值。如果连接线程排满了队列就会抛出“out of semaphores to get db”错误 --int\nthreadsallowedtoblockforconnectionmultiplier=10\n#被阻塞线程从连接池获取连接的最长等待时间（ms） --int\nmaxwaittime = 120000\n#在建立（打开）套接字连接时的超时时间（ms），默以为0（无穷） --int\nconnecttimeout=0\n#套接字超时时间;该值会被传递给socket.setsotimeout(int)。默以为0（无穷） --int\nsockettimeout=0\n#是否打开长连接. defaults to false --boolean\nsocketkeepalive=false\n\n#---------------------------------- mongodb实例连接\n[master]\nhost = 127.0.0.1:27017\n\n[slave]\nhost = 127.0.0.1:27018\n#-----------------------------------------------------\n\n\n\n# 使用\n\n//master slave 组成主从集群\nmongodatabase db = mongofactory.getds("master", "slave").getdb("test");\n',charsets:{cjk:!0},lastUpdated:"2023/10/24, 14:12:47",lastUpdatedTimestamp:1698127967e3},{title:"简易Http服务器-SimpleServer",frontmatter:{title:"简易Http服务器-SimpleServer",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/SimpleServer/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/09.Server/10.%E7%AE%80%E6%98%93Http%E6%9C%8D%E5%8A%A1%E5%99%A8-SimpleServer.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/09.Server/10.简易Http服务器-SimpleServer.md",key:"v-65e26362",path:"/pages/SimpleServer/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:96},{level:3,title:"简单的文件服务器",slug:"简单的文件服务器",normalizedTitle:"简单的文件服务器",charIndex:581},{level:3,title:"读取请求和返回内容",slug:"读取请求和返回内容",normalizedTitle:"读取请求和返回内容",charIndex:918},{level:3,title:"文件上传",slug:"文件上传",normalizedTitle:"文件上传",charIndex:1449}],headersStr:"由来 使用 简单的文件服务器 读取请求和返回内容 文件上传",content:'# 由来\n\nOracle JDK提供了一个简单的Http服务端类，叫做HttpServer，当然它是sun的私有包，位于com.sun.net.httpserver下，必须引入rt.jar才能使用，Hutool基于此封装了SimpleServer，用于在不引入Tomcat、Jetty等容器的情况下，实现简单的Http请求处理。\n\n> SimpleServer在Hutool-5.3.0后才引入，请升级到最新版本\n\n\n# 使用\n\n 1. 启动一个Http服务非常简单：\n\nHttpUtil.createServer(8888).start();\n\n\n通过浏览器访问 http://localhost:8888/ 即可，当然此时访问任何path都是404。\n\n 2. 处理简单请求：\n\nHttpUtil.createServer(8888)\n    .addAction("/", (req, res)->{\n        res.write("Hello Hutool Server");\n    })\n    .start();\n\n\n此处我们定义了一个简单的action，绑定在"/"路径下，此时我们可以访问，输出“Hello Hutool Server”。\n\n同理，我们通过调用addAction方法，定义不同path的处理规则，实现相应的功能。\n\n\n# 简单的文件服务器\n\nHutool默认提供了简单的文件服务，即定义一个root目录，则请求路径后直接访问目录下的资源，默认请求index.html，类似于Nginx。\n\nHttpUtil.createServer(8888)\n    // 设置默认根目录\n    .setRoot("D:\\\\workspace\\\\site\\\\hutool-site")\n    .start();\n\n\n此时访问http://localhost:8888/即可访问HTML静态页面。\n\n> hutool-site是Hutool主页的源码项目，地址在：https://gitee.com/loolly_admin/hutool-site，下载后配合SimpleServer实现离线文档。\n\n\n# 读取请求和返回内容\n\n有时候我们需要自定义读取请求参数，然后根据参数访问不同的数据，整理返回，此时我们自定义Action即可完成：\n\n 1. 返回JSON数据\n\nHttpUtil.createServer(8888)\n    // 返回JSON数据测试\n    .addAction("/restTest", (request, response) ->\n    \t\tresponse.write("{\\"id\\": 1, \\"msg\\": \\"OK\\"}", ContentType.JSON.toString())\n    ).start();\n\n\n 2. 获取表单数据并返回\n\nHttpUtil.createServer(8888)\n    // http://localhost:8888/formTest?a=1&a=2&b=3\n    .addAction("/formTest", (request, response) ->\n        response.write(request.getParams().toString(), ContentType.TEXT_PLAIN.toString())\n    ).start();\n\n\n\n# 文件上传\n\n除了常规Http服务，Hutool还封装了文件上传操作：\n\nHttpUtil.createServer(8888)\n    .addAction("/file", (request, response) -> {\n        final UploadFile file = request.getMultipart().getFile("file");\n        // 传入目录，默认读取HTTP头中的文件名然后创建文件\n        file.write("d:/test/");\n        response.write("OK!", ContentType.TEXT_PLAIN.toString());\n        }\n    )\n    .start();\n',normalizedContent:'# 由来\n\noracle jdk提供了一个简单的http服务端类，叫做httpserver，当然它是sun的私有包，位于com.sun.net.httpserver下，必须引入rt.jar才能使用，hutool基于此封装了simpleserver，用于在不引入tomcat、jetty等容器的情况下，实现简单的http请求处理。\n\n> simpleserver在hutool-5.3.0后才引入，请升级到最新版本\n\n\n# 使用\n\n 1. 启动一个http服务非常简单：\n\nhttputil.createserver(8888).start();\n\n\n通过浏览器访问 http://localhost:8888/ 即可，当然此时访问任何path都是404。\n\n 2. 处理简单请求：\n\nhttputil.createserver(8888)\n    .addaction("/", (req, res)->{\n        res.write("hello hutool server");\n    })\n    .start();\n\n\n此处我们定义了一个简单的action，绑定在"/"路径下，此时我们可以访问，输出“hello hutool server”。\n\n同理，我们通过调用addaction方法，定义不同path的处理规则，实现相应的功能。\n\n\n# 简单的文件服务器\n\nhutool默认提供了简单的文件服务，即定义一个root目录，则请求路径后直接访问目录下的资源，默认请求index.html，类似于nginx。\n\nhttputil.createserver(8888)\n    // 设置默认根目录\n    .setroot("d:\\\\workspace\\\\site\\\\hutool-site")\n    .start();\n\n\n此时访问http://localhost:8888/即可访问html静态页面。\n\n> hutool-site是hutool主页的源码项目，地址在：https://gitee.com/loolly_admin/hutool-site，下载后配合simpleserver实现离线文档。\n\n\n# 读取请求和返回内容\n\n有时候我们需要自定义读取请求参数，然后根据参数访问不同的数据，整理返回，此时我们自定义action即可完成：\n\n 1. 返回json数据\n\nhttputil.createserver(8888)\n    // 返回json数据测试\n    .addaction("/resttest", (request, response) ->\n    \t\tresponse.write("{\\"id\\": 1, \\"msg\\": \\"ok\\"}", contenttype.json.tostring())\n    ).start();\n\n\n 2. 获取表单数据并返回\n\nhttputil.createserver(8888)\n    // http://localhost:8888/formtest?a=1&a=2&b=3\n    .addaction("/formtest", (request, response) ->\n        response.write(request.getparams().tostring(), contenttype.text_plain.tostring())\n    ).start();\n\n\n\n# 文件上传\n\n除了常规http服务，hutool还封装了文件上传操作：\n\nhttputil.createserver(8888)\n    .addaction("/file", (request, response) -> {\n        final uploadfile file = request.getmultipart().getfile("file");\n        // 传入目录，默认读取http头中的文件名然后创建文件\n        file.write("d:/test/");\n        response.write("ok!", contenttype.text_plain.tostring());\n        }\n    )\n    .start();\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/cron/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/11.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88Hutool-cron%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/11.定时任务（Hutool-cron）/01.概述.md",key:"v-23f50ec4",path:"/pages/cron/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:313}],headersStr:"由来 介绍",content:"# 由来\n\nJava中定时任务使用的最多的我想就是quartz了，但是这个框架太过庞大，而且我也不需要用到这么多东西，使用方法也是比较复杂（官方Demo我实在是无语……）。\n\n用过Linux的crontab的人都知道，使用其定时的表达式可以非常灵活的定义定时任务的时间以及频率（Linux的crontab精确到分，而Quartz的精确到秒，不过对我来说精确到分已经够用了，精确到秒的可以使用Timer可以搞定），然后就是crontab的那个迷人的配置文件，可以把定时任务很清晰的罗列出来，这个我也是比较喜欢的。（记得当时Spring整合Quartz的时候那XML看的我眼都花了……）。于是Hutool-cron诞生。\n\n\n# 介绍\n\nHutool的定时任务模块与Linux的Crontab使用上非常类似，通过一个cron.setting配置文件，简单调用start()方法即可简单使用。\n\n同时还提供了秒匹配和年匹配等Quartz才有的功能，定时任务表达式上也同时兼容Crontab（Cron4j）和Quartz的表达式。",normalizedContent:"# 由来\n\njava中定时任务使用的最多的我想就是quartz了，但是这个框架太过庞大，而且我也不需要用到这么多东西，使用方法也是比较复杂（官方demo我实在是无语……）。\n\n用过linux的crontab的人都知道，使用其定时的表达式可以非常灵活的定义定时任务的时间以及频率（linux的crontab精确到分，而quartz的精确到秒，不过对我来说精确到分已经够用了，精确到秒的可以使用timer可以搞定），然后就是crontab的那个迷人的配置文件，可以把定时任务很清晰的罗列出来，这个我也是比较喜欢的。（记得当时spring整合quartz的时候那xml看的我眼都花了……）。于是hutool-cron诞生。\n\n\n# 介绍\n\nhutool的定时任务模块与linux的crontab使用上非常类似，通过一个cron.setting配置文件，简单调用start()方法即可简单使用。\n\n同时还提供了秒匹配和年匹配等quartz才有的功能，定时任务表达式上也同时兼容crontab（cron4j）和quartz的表达式。",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Soap客户端-SoapClient",frontmatter:{title:"Soap客户端-SoapClient",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/SoapClient/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/11.WebService/12.Soap%E5%AE%A2%E6%88%B7%E7%AB%AF-SoapClient.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/11.WebService/12.Soap客户端-SoapClient.md",key:"v-58438bce",path:"/pages/SoapClient/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:39},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:1082},{level:3,title:"查看生成的请求XML",slug:"查看生成的请求xml",normalizedTitle:"查看生成的请求xml",charIndex:1089},{level:3,title:"多参数或复杂参数",slug:"多参数或复杂参数",normalizedTitle:"多参数或复杂参数",charIndex:1225}],headersStr:"由来 使用 扩展 查看生成的请求XML 多参数或复杂参数",content:'# 由来\n\n在接口对接当中，WebService接口占有着很大份额，而我们为了使用这些接口，不得不引入类似Axis等库来实现接口请求。\n\n现在有了Hutool，就可以在无任何依赖的情况下，实现简便的WebService请求。\n\n\n# 使用\n\n 1. 使用SoapUI解析WSDL地址，找到WebService方法和参数。\n\n我们得到的XML模板为：\n\n<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:web="http://webxml.com.cn/">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:getCountryCityByIp>\n         \x3c!--Optional:--\x3e\n         <web:theIpAddress>?</web:theIpAddress>\n      </web:getCountryCityByIp>\n   </soapenv:Body>\n</soapenv:Envelope>\n\n\n 2. 按照SoapUI中的相应内容构建SOAP请求。\n\n我们知道：\n\n 1. 方法名为：web:getCountryCityByIp\n 2. 参数只有一个，为:web:theIpAddress\n 3. 定义了一个命名空间，前缀为web，URI为http://WebXml.com.cn/\n\n这样我们就能构建相应SOAP请求：\n\n// 新建客户端\nSoapClient client = SoapClient.create("http://www.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx")\n    // 设置要请求的方法，此接口方法前缀为web，传入对应的命名空间\n    .setMethod("web:getCountryCityByIp", "http://webxml.com.cn/")\n    // 设置参数，此处自动添加方法的前缀：web\n    .setParam("theIpAddress", "https://doc.hutool.cn/assets/js/218.21.240.106");\n\n    // 发送请求，参数true表示返回一个格式化后的XML内容\n    // 返回内容为XML字符串，可以配合XmlUtil解析这个响应\n    Console.log(client.send(true));\n\n\n\n# 扩展\n\n\n# 查看生成的请求XML\n\n调用SoapClient对象的getMsgStr方法可以查看生成的XML，以检查是否与SoapUI生成的一致。\n\nSoapClient client = ...;\nConsole.log(client.getMsgStr(true));\n\n\n\n# 多参数或复杂参数\n\n对于请求体是列表参数或多参数的情况，如：\n\n<web:method>\n  <arg0>\n    <fd1>aaa</fd1>\n    <fd2>bbb</fd2>\n  </arg0>\n</web:method>\n\n\n这类请求可以借助addChildElement完成。\n\nSoapClient client = SoapClient.create("https://hutool.cn/WebServices/test.asmx")\n\t\t.setMethod("web:method", "http://hutool.cn/")\n\t\tSOAPElement arg0 = client.getMethodEle().addChildElement("arg0");\n\t\targ0.addChildElement("fdSource").setValue("?");\n\t\targ0.addChildElement("fdTemplated").setValue("?");\n\n\n> 详细的问题解答见：https://gitee.com/dromara/hutool/issues/I4QL1V',normalizedContent:'# 由来\n\n在接口对接当中，webservice接口占有着很大份额，而我们为了使用这些接口，不得不引入类似axis等库来实现接口请求。\n\n现在有了hutool，就可以在无任何依赖的情况下，实现简便的webservice请求。\n\n\n# 使用\n\n 1. 使用soapui解析wsdl地址，找到webservice方法和参数。\n\n我们得到的xml模板为：\n\n<soapenv:envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:web="http://webxml.com.cn/">\n   <soapenv:header/>\n   <soapenv:body>\n      <web:getcountrycitybyip>\n         \x3c!--optional:--\x3e\n         <web:theipaddress>?</web:theipaddress>\n      </web:getcountrycitybyip>\n   </soapenv:body>\n</soapenv:envelope>\n\n\n 2. 按照soapui中的相应内容构建soap请求。\n\n我们知道：\n\n 1. 方法名为：web:getcountrycitybyip\n 2. 参数只有一个，为:web:theipaddress\n 3. 定义了一个命名空间，前缀为web，uri为http://webxml.com.cn/\n\n这样我们就能构建相应soap请求：\n\n// 新建客户端\nsoapclient client = soapclient.create("http://www.webxml.com.cn/webservices/ipaddresssearchwebservice.asmx")\n    // 设置要请求的方法，此接口方法前缀为web，传入对应的命名空间\n    .setmethod("web:getcountrycitybyip", "http://webxml.com.cn/")\n    // 设置参数，此处自动添加方法的前缀：web\n    .setparam("theipaddress", "https://doc.hutool.cn/assets/js/218.21.240.106");\n\n    // 发送请求，参数true表示返回一个格式化后的xml内容\n    // 返回内容为xml字符串，可以配合xmlutil解析这个响应\n    console.log(client.send(true));\n\n\n\n# 扩展\n\n\n# 查看生成的请求xml\n\n调用soapclient对象的getmsgstr方法可以查看生成的xml，以检查是否与soapui生成的一致。\n\nsoapclient client = ...;\nconsole.log(client.getmsgstr(true));\n\n\n\n# 多参数或复杂参数\n\n对于请求体是列表参数或多参数的情况，如：\n\n<web:method>\n  <arg0>\n    <fd1>aaa</fd1>\n    <fd2>bbb</fd2>\n  </arg0>\n</web:method>\n\n\n这类请求可以借助addchildelement完成。\n\nsoapclient client = soapclient.create("https://hutool.cn/webservices/test.asmx")\n\t\t.setmethod("web:method", "http://hutool.cn/")\n\t\tsoapelement arg0 = client.getmethodele().addchildelement("arg0");\n\t\targ0.addchildelement("fdsource").setvalue("?");\n\t\targ0.addchildelement("fdtemplated").setvalue("?");\n\n\n> 详细的问题解答见：https://gitee.com/dromara/hutool/issues/i4ql1v',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Http请求-HttpRequest",frontmatter:{title:"Http请求-HttpRequest",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/HttpRequest/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89/04.Http%E8%AF%B7%E6%B1%82-HttpRequest.html",relativePath:"01.指南/10.HTTP客户端（Hutool-http）/04.Http请求-HttpRequest.md",key:"v-1b2ebac0",path:"/pages/HttpRequest/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:71},{level:3,title:"普通表单",slug:"普通表单",normalizedTitle:"普通表单",charIndex:97},{level:3,title:"Restful请求",slug:"restful请求",normalizedTitle:"restful请求",charIndex:453},{level:3,title:"配置代理",slug:"配置代理",normalizedTitle:"配置代理",charIndex:560},{level:2,title:"其它自定义项",slug:"其它自定义项",normalizedTitle:"其它自定义项",charIndex:1262}],headersStr:"介绍 使用 普通表单 Restful请求 配置代理 其它自定义项",content:'# 介绍\n\n本质上，HttpUtil中的get和post工具方法都是HttpRequest对象的封装，因此如果想更加灵活操作Http请求，可以使用HttpRequest。\n\n\n# 使用\n\n\n# 普通表单\n\n我们以POST请求为例：\n\n//链式构建请求\nString result2 = HttpRequest.post(url)\n\t.header(Header.USER_AGENT, "Hutool http")//头信息，多个头信息多次调用此方法即可\n\t.form(paramMap)//表单内容\n\t.timeout(20000)//超时，毫秒\n\t.execute().body();\nConsole.log(result2);\n\n\n通过链式构建请求，我们可以很方便的指定Http头信息和表单信息，最后调用execute方法即可执行请求，返回HttpResponse对象。HttpResponse包含了服务器响应的一些信息，包括响应的内容和响应的头信息。通过调用body方法即可获取响应内容。\n\n\n# Restful请求\n\nString json = ...;\nString result2 = HttpRequest.post(url)\n\t.body(json)\n\t.execute().body();\n\n\n\n# 配置代理\n\n如果代理无需账号密码，可以直接：\n\nString result2 = HttpRequest.post(url)\n\t.setHttpProxy("127.0.0.1", 9080)\n\t.body(json)\n\t.execute().body();\n\n\n如果需要自定其他类型代理或更多的项目，可以：\n\nString result2 = HttpRequest.post(url)\n\t.setProxy(new Proxy(Proxy.Type.HTTP,\n\t\t\t\tnew InetSocketAddress(host, port))\n\t.body(json)\n\t.execute().body();\n\n\n如果遇到https代理错误Proxy returns "HTTP/1.0 407 Proxy Authentication Required"，可以尝试：\n\nSystem.setProperty("jdk.http.auth.tunneling.disabledSchemes", "");\nAuthenticator.setDefault(\n    new Authenticator() {\n        @Override\n        public PasswordAuthentication getPasswordAuthentication() {\n              return new PasswordAuthentication(authUser, authPassword.toCharArray());\n        }\n    }\n);\n\n\n\n# 其它自定义项\n\n同样，我们通过HttpRequest可以很方便的做以下操作：\n\n * 指定请求头\n * 自定义Cookie（cookie方法）\n * 指定是否keepAlive（keepAlive方法）\n * 指定表单内容（form方法）\n * 指定请求内容，比如rest请求指定JSON请求体（body方法）\n * 超时设置（timeout方法）\n * 指定代理（setProxy方法）\n * 指定SSL协议（setSSLProtocol）\n * 简单验证（basicAuth方法）',normalizedContent:'# 介绍\n\n本质上，httputil中的get和post工具方法都是httprequest对象的封装，因此如果想更加灵活操作http请求，可以使用httprequest。\n\n\n# 使用\n\n\n# 普通表单\n\n我们以post请求为例：\n\n//链式构建请求\nstring result2 = httprequest.post(url)\n\t.header(header.user_agent, "hutool http")//头信息，多个头信息多次调用此方法即可\n\t.form(parammap)//表单内容\n\t.timeout(20000)//超时，毫秒\n\t.execute().body();\nconsole.log(result2);\n\n\n通过链式构建请求，我们可以很方便的指定http头信息和表单信息，最后调用execute方法即可执行请求，返回httpresponse对象。httpresponse包含了服务器响应的一些信息，包括响应的内容和响应的头信息。通过调用body方法即可获取响应内容。\n\n\n# restful请求\n\nstring json = ...;\nstring result2 = httprequest.post(url)\n\t.body(json)\n\t.execute().body();\n\n\n\n# 配置代理\n\n如果代理无需账号密码，可以直接：\n\nstring result2 = httprequest.post(url)\n\t.sethttpproxy("127.0.0.1", 9080)\n\t.body(json)\n\t.execute().body();\n\n\n如果需要自定其他类型代理或更多的项目，可以：\n\nstring result2 = httprequest.post(url)\n\t.setproxy(new proxy(proxy.type.http,\n\t\t\t\tnew inetsocketaddress(host, port))\n\t.body(json)\n\t.execute().body();\n\n\n如果遇到https代理错误proxy returns "http/1.0 407 proxy authentication required"，可以尝试：\n\nsystem.setproperty("jdk.http.auth.tunneling.disabledschemes", "");\nauthenticator.setdefault(\n    new authenticator() {\n        @override\n        public passwordauthentication getpasswordauthentication() {\n              return new passwordauthentication(authuser, authpassword.tochararray());\n        }\n    }\n);\n\n\n\n# 其它自定义项\n\n同样，我们通过httprequest可以很方便的做以下操作：\n\n * 指定请求头\n * 自定义cookie（cookie方法）\n * 指定是否keepalive（keepalive方法）\n * 指定表单内容（form方法）\n * 指定请求内容，比如rest请求指定json请求体（body方法）\n * 超时设置（timeout方法）\n * 指定代理（setproxy方法）\n * 指定ssl协议（setsslprotocol）\n * 简单验证（basicauth方法）',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"全局定时任务-CronUtil",frontmatter:{title:"全局定时任务-CronUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CronUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/11.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88Hutool-cron%EF%BC%89/02.%E5%85%A8%E5%B1%80%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-CronUtil.html",relativePath:"01.指南/11.定时任务（Hutool-cron）/02.全局定时任务-CronUtil.md",key:"v-0cc20b5b",path:"/pages/CronUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:47},{level:3,title:"1、配置文件",slug:"_1、配置文件",normalizedTitle:"1、配置文件",charIndex:54},{level:3,title:"2、启动",slug:"_2、启动",normalizedTitle:"2、启动",charIndex:565},{level:3,title:"3、关闭",slug:"_3、关闭",normalizedTitle:"3、关闭",charIndex:713},{level:2,title:"更多选项",slug:"更多选项",normalizedTitle:"更多选项",charIndex:741},{level:3,title:"秒匹配和年匹配",slug:"秒匹配和年匹配",normalizedTitle:"秒匹配和年匹配",charIndex:750},{level:3,title:"动态添加定时任务",slug:"动态添加定时任务",normalizedTitle:"动态添加定时任务",charIndex:904}],headersStr:"介绍 使用 1、配置文件 2、启动 3、关闭 更多选项 秒匹配和年匹配 动态添加定时任务",content:'# 介绍\n\nCronUtil通过一个全局的定时任务配置文件，实现统一的定时任务调度。\n\n\n# 使用\n\n\n# 1、配置文件\n\n对于Maven项目，首先在src/main/resources/config下放入cron.setting文件（默认是这个路径的这个文件），然后在文件中放入定时规则，规则如下：\n\n# 我是注释\n[com.company.aaa.job]\nTestJob.run = */10 * * * *\nTestJob2.run = */10 * * * *\n\n\n中括号表示分组，也表示需要执行的类或对象方法所在包的名字，这种写法有利于区分不同业务的定时任务。\n\nTestJob.run表示需要执行的类名和方法名（通过反射调用，不支持Spring和任何框架的依赖注入），*/10 * * * *表示定时任务表达式，此处表示每10分钟执行一次，以上配置等同于：\n\ncom.company.aaa.job.TestJob.run = */10 * * * *\ncom.company.aaa.job.TestJob2.run = */10 * * * *\n\n\n> 提示 关于表达式语法，见：https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html\n\n\n# 2、启动\n\nCronUtil.start();\n\n\n如果想让执行的作业和定时任务线程同时结束，可以将定时任务设为守护线程，需要注意的是，此模式下会在调用stop时立即结束所有作业线程，请确保你的作业可以被中断：\n\n//使用deamon模式，\nCronUtil.start(true);\n\n\n\n# 3、关闭\n\nCronUtil.stop();\n\n\n\n# 更多选项\n\n\n# 秒匹配和年匹配\n\n考虑到Quartz表达式的兼容性，且存在对于秒级别精度匹配的需求，Hutool可以通过设置使用秒匹配模式来兼容。\n\n//支持秒级别定时任务\nCronUtil.setMatchSecond(true);\n\n\n此时Hutool可以兼容Quartz表达式（5位表达式、6位表达式都兼容）\n\n\n# 动态添加定时任务\n\n当然，如果你想动态的添加定时任务，使用CronUtil.schedule(String schedulingPattern, Runnable task)方法即可（使用此方法加入的定时任务不会被写入到配置文件）。\n\nCronUtil.schedule("*/2 * * * * *", new Task() {\n\t@Override\n\tpublic void execute() {\n\t\tConsole.log("Task excuted.");\n\t}\n});\n\n// 支持秒级别定时任务\nCronUtil.setMatchSecond(true);\nCronUtil.start();\n',normalizedContent:'# 介绍\n\ncronutil通过一个全局的定时任务配置文件，实现统一的定时任务调度。\n\n\n# 使用\n\n\n# 1、配置文件\n\n对于maven项目，首先在src/main/resources/config下放入cron.setting文件（默认是这个路径的这个文件），然后在文件中放入定时规则，规则如下：\n\n# 我是注释\n[com.company.aaa.job]\ntestjob.run = */10 * * * *\ntestjob2.run = */10 * * * *\n\n\n中括号表示分组，也表示需要执行的类或对象方法所在包的名字，这种写法有利于区分不同业务的定时任务。\n\ntestjob.run表示需要执行的类名和方法名（通过反射调用，不支持spring和任何框架的依赖注入），*/10 * * * *表示定时任务表达式，此处表示每10分钟执行一次，以上配置等同于：\n\ncom.company.aaa.job.testjob.run = */10 * * * *\ncom.company.aaa.job.testjob2.run = */10 * * * *\n\n\n> 提示 关于表达式语法，见：https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html\n\n\n# 2、启动\n\ncronutil.start();\n\n\n如果想让执行的作业和定时任务线程同时结束，可以将定时任务设为守护线程，需要注意的是，此模式下会在调用stop时立即结束所有作业线程，请确保你的作业可以被中断：\n\n//使用deamon模式，\ncronutil.start(true);\n\n\n\n# 3、关闭\n\ncronutil.stop();\n\n\n\n# 更多选项\n\n\n# 秒匹配和年匹配\n\n考虑到quartz表达式的兼容性，且存在对于秒级别精度匹配的需求，hutool可以通过设置使用秒匹配模式来兼容。\n\n//支持秒级别定时任务\ncronutil.setmatchsecond(true);\n\n\n此时hutool可以兼容quartz表达式（5位表达式、6位表达式都兼容）\n\n\n# 动态添加定时任务\n\n当然，如果你想动态的添加定时任务，使用cronutil.schedule(string schedulingpattern, runnable task)方法即可（使用此方法加入的定时任务不会被写入到配置文件）。\n\ncronutil.schedule("*/2 * * * * *", new task() {\n\t@override\n\tpublic void execute() {\n\t\tconsole.log("task excuted.");\n\t}\n});\n\n// 支持秒级别定时任务\ncronutil.setmatchsecond(true);\ncronutil.start();\n',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/extra/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/12.扩展（Hutool-extra）/01.概述.md",key:"v-7243a964",path:"/pages/extra/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:94},{level:3,title:"模板引擎封装工具类",slug:"模板引擎封装工具类",normalizedTitle:"模板引擎封装工具类",charIndex:111},{level:3,title:"Servlet封装",slug:"servlet封装",normalizedTitle:"servlet封装",charIndex:125},{level:3,title:"Jsch库封装（SSH和Sftp）",slug:"jsch库封装-ssh和sftp",normalizedTitle:"jsch库封装（ssh和sftp）",charIndex:139},{level:3,title:"Apache Commons Net封装（FTP部分）",slug:"apache-commons-net封装-ftp部分",normalizedTitle:"apache commons net封装（ftp部分）",charIndex:161},{level:3,title:"邮件封装",slug:"邮件封装",normalizedTitle:"邮件封装",charIndex:193},{level:3,title:"Zxing封装（二维码）",slug:"zxing封装-二维码",normalizedTitle:"zxing封装（二维码）",charIndex:202}],headersStr:"由来 介绍 模板引擎封装工具类 Servlet封装 Jsch库封装（SSH和Sftp） Apache Commons Net封装（FTP部分） 邮件封装 Zxing封装（二维码）",content:"# 由来\n\n由于Hutool的原则是不依赖于其它配置文件，但是很多时候我们需要针对第三方非常棒的库做一些工具类化的支持，因此Hutoo-extra包主要用于支持第三方库的工具类。\n\n\n# 介绍\n\n现阶段扩展包括：\n\n\n# 模板引擎封装工具类\n\n\n# Servlet封装\n\n\n# Jsch库封装（SSH和Sftp）\n\n\n# Apache Commons Net封装（FTP部分）\n\n\n# 邮件封装\n\n\n# Zxing封装（二维码）",normalizedContent:"# 由来\n\n由于hutool的原则是不依赖于其它配置文件，但是很多时候我们需要针对第三方非常棒的库做一些工具类化的支持，因此hutoo-extra包主要用于支持第三方库的工具类。\n\n\n# 介绍\n\n现阶段扩展包括：\n\n\n# 模板引擎封装工具类\n\n\n# servlet封装\n\n\n# jsch库封装（ssh和sftp）\n\n\n# apache commons net封装（ftp部分）\n\n\n# 邮件封装\n\n\n# zxing封装（二维码）",charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"Servlet工具-ServletUtil",frontmatter:{title:"Servlet工具-ServletUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ServletUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/02.Servlet%E5%B7%A5%E5%85%B7-ServletUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/02.Servlet工具-ServletUtil.md",key:"v-5b368820",path:"/pages/ServletUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:92},{level:3,title:"加入依赖",slug:"加入依赖",normalizedTitle:"加入依赖",charIndex:236},{level:3,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:217}],headersStr:"由来 使用 加入依赖 方法",content:"# 由来\n\n最早Servlet相关的工具并不在Hutool的封装考虑范围内，但是后来很多人提出需要一个Servlet Cookie工具，于是我决定建立ServletUtil，这样工具的使用范围就不仅限于Cookie，还包括参数等等。\n\n其实最早的Servlet封装来自于作者的一个MVC框架：Hulu，这个MVC框架对Servlet做了一层封装，使请求处理更加便捷。于是Hutool将Hulu中Request类和Response类中的方法封装于此。\n\n\n# 使用\n\n\n# 加入依赖\n\n<dependency>\n\t<groupId>javax.servlet</groupId>\n\t<artifactId>javax.servlet-api</artifactId>\n\t<version>${servlet-api.version}</version>\n\t\x3c!-- 此包一般在Servlet容器中都有提供 --\x3e\n\t<scope>provided</scope>\n</dependency>\n\n\n\n# 方法\n\n * getParamMap 获得所有请求参数\n * fillBean 将请求参数转为Bean\n * getClientIP 获取客户端IP，支持从Nginx头部信息获取，也可以自定义头部信息获取位置\n * getHeader、getHeaderIgnoreCase 获得请求header中的信息\n * isIE 客户浏览器是否为IE\n * isMultipart 是否为Multipart类型表单，此类型表单用于文件上传\n * getCookie 获得指定的Cookie\n * readCookieMap 将cookie封装到Map里面\n * addCookie 设定返回给客户端的Cookie\n * write 返回数据给客户端\n * setHeader 设置响应的Header",normalizedContent:"# 由来\n\n最早servlet相关的工具并不在hutool的封装考虑范围内，但是后来很多人提出需要一个servlet cookie工具，于是我决定建立servletutil，这样工具的使用范围就不仅限于cookie，还包括参数等等。\n\n其实最早的servlet封装来自于作者的一个mvc框架：hulu，这个mvc框架对servlet做了一层封装，使请求处理更加便捷。于是hutool将hulu中request类和response类中的方法封装于此。\n\n\n# 使用\n\n\n# 加入依赖\n\n<dependency>\n\t<groupid>javax.servlet</groupid>\n\t<artifactid>javax.servlet-api</artifactid>\n\t<version>${servlet-api.version}</version>\n\t\x3c!-- 此包一般在servlet容器中都有提供 --\x3e\n\t<scope>provided</scope>\n</dependency>\n\n\n\n# 方法\n\n * getparammap 获得所有请求参数\n * fillbean 将请求参数转为bean\n * getclientip 获取客户端ip，支持从nginx头部信息获取，也可以自定义头部信息获取位置\n * getheader、getheaderignorecase 获得请求header中的信息\n * isie 客户浏览器是否为ie\n * ismultipart 是否为multipart类型表单，此类型表单用于文件上传\n * getcookie 获得指定的cookie\n * readcookiemap 将cookie封装到map里面\n * addcookie 设定返回给客户端的cookie\n * write 返回数据给客户端\n * setheader 设置响应的header",charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"Cglib工具-CglibUtil",frontmatter:{title:"Cglib工具-CglibUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CglibUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/05.cglib/01.Cglib%E5%B7%A5%E5%85%B7-CglibUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/05.cglib/01.Cglib工具-CglibUtil.md",key:"v-f70ddca6",path:"/pages/CglibUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:145},{level:3,title:"引入Cglib",slug:"引入cglib",normalizedTitle:"引入cglib",charIndex:152},{level:3,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:145},{level:2,title:"关于性能",slug:"关于性能",normalizedTitle:"关于性能",charIndex:872}],headersStr:"介绍 使用 引入Cglib 使用 关于性能",content:'# 介绍\n\nCGLib (Code Generation Library) 是一个强大的,高性能,高质量的Code生成类库，通过此库可以完成动态代理、Bean拷贝等操作。\n\nHutool在5.4.1之后加入对Cglib的封装——CglibUtil，用于解决Bean拷贝的性能问题。\n\n\n# 使用\n\n\n# 引入Cglib\n\n<dependency>\n\t<groupId>cglib</groupId>\n\t<artifactId>cglib</artifactId>\n\t<version>${cglib.version}</version>\n\t<scope>compile</scope>\n</dependency>\n\n\n\n# 使用\n\n 1. Bean拷贝\n\n首先我们定义两个Bean：\n\n@Data\npublic class SampleBean {\n\tprivate String value;\n}\n@Data\npublic class OtherSampleBean {\n\tprivate String value;\n}\n\n\n> @Data是Lombok的注解，请自行补充get和set方法，或者引入Lombok依赖\n\nSampleBean bean = new SampleBean();\nbean.setValue("Hello world");\n\nOtherSampleBean otherBean = new OtherSampleBean();\n\nCglibUtil.copy(bean, otherBean);\n\n// 值为"Hello world"\notherBean.getValue();\n\n\n当然，目标对象也可以省略，你可以传入一个class，让Hutool自动帮你实例化它：\n\nOtherSampleBean otherBean2 = CglibUtil.copy(bean, OtherSampleBean.class);\n\n// 值为"Hello world"\notherBean.getValue();\n\n\n\n# 关于性能\n\nCglib的性能是目前公认最好的，其时间主要耗费在BeanCopier创建上，因此，Hutool根据传入Class不同，缓存了BeanCopier对象，使性能达到最好。',normalizedContent:'# 介绍\n\ncglib (code generation library) 是一个强大的,高性能,高质量的code生成类库，通过此库可以完成动态代理、bean拷贝等操作。\n\nhutool在5.4.1之后加入对cglib的封装——cglibutil，用于解决bean拷贝的性能问题。\n\n\n# 使用\n\n\n# 引入cglib\n\n<dependency>\n\t<groupid>cglib</groupid>\n\t<artifactid>cglib</artifactid>\n\t<version>${cglib.version}</version>\n\t<scope>compile</scope>\n</dependency>\n\n\n\n# 使用\n\n 1. bean拷贝\n\n首先我们定义两个bean：\n\n@data\npublic class samplebean {\n\tprivate string value;\n}\n@data\npublic class othersamplebean {\n\tprivate string value;\n}\n\n\n> @data是lombok的注解，请自行补充get和set方法，或者引入lombok依赖\n\nsamplebean bean = new samplebean();\nbean.setvalue("hello world");\n\nothersamplebean otherbean = new othersamplebean();\n\ncglibutil.copy(bean, otherbean);\n\n// 值为"hello world"\notherbean.getvalue();\n\n\n当然，目标对象也可以省略，你可以传入一个class，让hutool自动帮你实例化它：\n\nothersamplebean otherbean2 = cglibutil.copy(bean, othersamplebean.class);\n\n// 值为"hello world"\notherbean.getvalue();\n\n\n\n# 关于性能\n\ncglib的性能是目前公认最好的，其时间主要耗费在beancopier创建上，因此，hutool根据传入class不同，缓存了beancopier对象，使性能达到最好。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Emoji工具-EmojiUtil",frontmatter:{title:"Emoji工具-EmojiUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/EmojiUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/06.emoji/01.Emoji%E5%B7%A5%E5%85%B7-EmojiUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/06.emoji/01.Emoji工具-EmojiUtil.md",key:"v-cf8973a6",path:"/pages/EmojiUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:149},{level:3,title:"加入依赖",slug:"加入依赖",normalizedTitle:"加入依赖",charIndex:156},{level:3,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:149}],headersStr:"由来 使用 加入依赖 使用",content:'# 由来\n\n考虑到MySQL等数据库中普通的UTF8编码并不支持Emoji（只有utf8mb4支持），因此对于数据中的Emoji字符进行处理（转换、清除）变成一项必要工作。因此Hutool基于emoji-java库提供了Emoji工具实现。\n\n此工具在Hutoo-4.2.1之后版本可用。\n\n\n# 使用\n\n\n# 加入依赖\n\n<dependency>\n\t<groupId>com.vdurmont</groupId>\n\t<artifactId>emoji-java</artifactId>\n\t<version>4.0.0</version>\n</dependency>\n\n\n\n# 使用\n\n 1. 转义Emoji字符\n\nString alias = EmojiUtil.toAlias("😄");//:smile:\n\n\n 2. 将转义的别名转为Emoji字符\n\nString emoji = EmojiUtil.toUnicode(":smile:");//😄\n\n\n 3. 将字符串中的Unicode Emoji字符转换为HTML表现形式\n\nString alias = EmojiUtil.toHtml("😄");//&#128102;\n',normalizedContent:'# 由来\n\n考虑到mysql等数据库中普通的utf8编码并不支持emoji（只有utf8mb4支持），因此对于数据中的emoji字符进行处理（转换、清除）变成一项必要工作。因此hutool基于emoji-java库提供了emoji工具实现。\n\n此工具在hutoo-4.2.1之后版本可用。\n\n\n# 使用\n\n\n# 加入依赖\n\n<dependency>\n\t<groupid>com.vdurmont</groupid>\n\t<artifactid>emoji-java</artifactid>\n\t<version>4.0.0</version>\n</dependency>\n\n\n\n# 使用\n\n 1. 转义emoji字符\n\nstring alias = emojiutil.toalias("😄");//:smile:\n\n\n 2. 将转义的别名转为emoji字符\n\nstring emoji = emojiutil.tounicode(":smile:");//😄\n\n\n 3. 将字符串中的unicode emoji字符转换为html表现形式\n\nstring alias = emojiutil.tohtml("😄");//&#128102;\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"FTP客户端封装-Ftp",frontmatter:{title:"FTP客户端封装-Ftp",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Ftp/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/07.FTP/01.FTP%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B0%81%E8%A3%85-Ftp.html",relativePath:"01.指南/12.扩展（Hutool-extra）/07.FTP/01.FTP客户端封装-Ftp.md",key:"v-2a36dce3",path:"/pages/Ftp/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:45},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:52},{level:3,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:45},{level:3,title:"主动模式与被动模式",slug:"主动模式与被动模式",normalizedTitle:"主动模式与被动模式",charIndex:458}],headersStr:"介绍 使用 引入依赖 使用 主动模式与被动模式",content:'# 介绍\n\nFTP客户端封装，此客户端基于Apache Commons Net。\n\n\n# 使用\n\n\n# 引入依赖\n\n<dependency>\n\t<groupId>commons-net</groupId>\n\t<artifactId>commons-net</artifactId>\n\t<version>${net.version}</version>\n</dependency>\n\n\n\n# 使用\n\n//匿名登录（无需帐号密码的FTP服务器）\nFtp ftp = new Ftp("172.0.0.1");\n//进入远程目录\nftp.cd("/opt/upload");\n//上传本地文件\nftp.upload("/opt/upload", FileUtil.file("e:/test.jpg"));\n//下载远程文件\nftp.download("/opt/upload", "test.jpg"/*tpa=https://doc.hutool.cn/assets/js/test.jpg*/, FileUtil.file("e:/test2.jpg"));\n\n//关闭连接\nftp.close();\n\n\n\n# 主动模式与被动模式\n\n * PORT（主动模式）\n\n> FTP客户端连接到FTP服务器的21端口，发送用户名和密码登录，登录成功后要list列表或者读取数据时，客户端随机开放一个端口（1024以上），发送 PORT命令到FTP服务器，告诉服务器客户端采用主动模式并开放端口；FTP服务器收到PORT主动模式命令和端口号后，通过服务器的20端口和客户端开放的端口连接，发送数据。\n\n * PASV（被动模式）\n\n> FTP客户端连接到FTP服务器的21端口，发送用户名和密码登录，登录成功后要list列表或者读取数据时，发送PASV命令到FTP服务器， 服务器在本地随机开放一个端口（1024以上），然后把开放的端口告诉客户端， 客户端再连接到服务器开放的端口进行数据传输。\n\n更多介绍见：https://www.cnblogs.com/huhaoshida/p/5412615.html\n\nFtp中默认是主动模式，需要切换则：\n\nFtp ftp = new Ftp("172.0.0.1");\n\n//切换为被动模式\nftp.setMode(FtpMode.Passive);\n',normalizedContent:'# 介绍\n\nftp客户端封装，此客户端基于apache commons net。\n\n\n# 使用\n\n\n# 引入依赖\n\n<dependency>\n\t<groupid>commons-net</groupid>\n\t<artifactid>commons-net</artifactid>\n\t<version>${net.version}</version>\n</dependency>\n\n\n\n# 使用\n\n//匿名登录（无需帐号密码的ftp服务器）\nftp ftp = new ftp("172.0.0.1");\n//进入远程目录\nftp.cd("/opt/upload");\n//上传本地文件\nftp.upload("/opt/upload", fileutil.file("e:/test.jpg"));\n//下载远程文件\nftp.download("/opt/upload", "test.jpg"/*tpa=https://doc.hutool.cn/assets/js/test.jpg*/, fileutil.file("e:/test2.jpg"));\n\n//关闭连接\nftp.close();\n\n\n\n# 主动模式与被动模式\n\n * port（主动模式）\n\n> ftp客户端连接到ftp服务器的21端口，发送用户名和密码登录，登录成功后要list列表或者读取数据时，客户端随机开放一个端口（1024以上），发送 port命令到ftp服务器，告诉服务器客户端采用主动模式并开放端口；ftp服务器收到port主动模式命令和端口号后，通过服务器的20端口和客户端开放的端口连接，发送数据。\n\n * pasv（被动模式）\n\n> ftp客户端连接到ftp服务器的21端口，发送用户名和密码登录，登录成功后要list列表或者读取数据时，发送pasv命令到ftp服务器， 服务器在本地随机开放一个端口（1024以上），然后把开放的端口告诉客户端， 客户端再连接到服务器开放的端口进行数据传输。\n\n更多介绍见：https://www.cnblogs.com/huhaoshida/p/5412615.html\n\nftp中默认是主动模式，需要切换则：\n\nftp ftp = new ftp("172.0.0.1");\n\n//切换为被动模式\nftp.setmode(ftpmode.passive);\n',charsets:{cjk:!0},lastUpdated:"2024/09/20, 17:14:14",lastUpdatedTimestamp:1726823654e3},{title:"简易FTP服务器-SimpleFtpServer",frontmatter:{title:"简易FTP服务器-SimpleFtpServer",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/SimpleFtpServer/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/07.FTP/02.%E7%AE%80%E6%98%93FTP%E6%9C%8D%E5%8A%A1%E5%99%A8-SimpleFtpServer.html",relativePath:"01.指南/12.扩展（Hutool-extra）/07.FTP/02.简易FTP服务器-SimpleFtpServer.md",key:"v-a93f2dbe",path:"/pages/SimpleFtpServer/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:113},{level:3,title:"引入FtpServer",slug:"引入ftpserver",normalizedTitle:"引入ftpserver",charIndex:128},{level:3,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:113}],headersStr:"介绍 使用 引入FtpServer 使用",content:'# 介绍\n\nHutool基于 [Apache FtpServer]（http://mina.apache.org/ftpserver-project/）封装了一个简易的FTP服务端组件，主要用于在一些测试场景或小并发应用场景下使用。\n\n\n# 使用\n\n\n# 引入FtpServer\n\n<dependency>\n\t<groupId>org.apache.ftpserver</groupId>\n\t<artifactId>ftpserver-core</artifactId>\n\t<version>1.1.1</version>\n</dependency>\n\n\n\n# 使用\n\n * 开启匿名FTP服务：\n\nSimpleFtpServer\n\t.create()\n\t// 此目录必须存在\n\t.addAnonymous("d:/test/ftp/")\n\t.start();\n\n\n此时就可以通过资源管理器访问：\n\nftp://localhost\n\n\n * 自定义用户\n\nBaseUser user = new BaseUser();\nuser.setName("username");\nuser.setPassword("123");\nuser.setHomeDirectory("d:/test/user/");\n\nSimpleFtpServer\n\t.create()\n\t.addUser(user)\n\t.start();\n',normalizedContent:'# 介绍\n\nhutool基于 [apache ftpserver]（http://mina.apache.org/ftpserver-project/）封装了一个简易的ftp服务端组件，主要用于在一些测试场景或小并发应用场景下使用。\n\n\n# 使用\n\n\n# 引入ftpserver\n\n<dependency>\n\t<groupid>org.apache.ftpserver</groupid>\n\t<artifactid>ftpserver-core</artifactid>\n\t<version>1.1.1</version>\n</dependency>\n\n\n\n# 使用\n\n * 开启匿名ftp服务：\n\nsimpleftpserver\n\t.create()\n\t// 此目录必须存在\n\t.addanonymous("d:/test/ftp/")\n\t.start();\n\n\n此时就可以通过资源管理器访问：\n\nftp://localhost\n\n\n * 自定义用户\n\nbaseuser user = new baseuser();\nuser.setname("username");\nuser.setpassword("123");\nuser.sethomedirectory("d:/test/user/");\n\nsimpleftpserver\n\t.create()\n\t.adduser(user)\n\t.start();\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"SFTP封装-Sftp",frontmatter:{title:"SFTP封装-Sftp",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Sftp/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/08.Jsch%E5%B0%81%E8%A3%85/00.SFTP%E5%B0%81%E8%A3%85-Sftp.html",relativePath:"01.指南/12.扩展（Hutool-extra）/08.Jsch封装/00.SFTP封装-Sftp.md",key:"v-3519994e",path:"/pages/Sftp/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:111},{level:3,title:"引入jsch",slug:"引入jsch",normalizedTitle:"引入jsch",charIndex:224},{level:3,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:111}],headersStr:"介绍 使用 引入jsch 使用",content:'# 介绍\n\nSFTP是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的加密方法。\n\nSFTP 为 SSH的一部份，是一种传输文件到服务器的安全方式。SFTP是使用加密传输认证信息和数据，所以，使用SFTP是非常安全的。\n\n但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。\n\n\n# 使用\n\n\n# 引入jsch\n\n<dependency>\n\t<groupId>com.jcraft</groupId>\n\t<artifactId>jsch</artifactId>\n\t<version>${jsch.version}</version>\n</dependency>\n\n\n\n# 使用\n\nSftp sftp= JschUtil.createSftp("172.0.0.1", 22, "root", "123456");\n//进入远程目录\nsftp.cd("/opt/upload");\n//上传本地文件\nsftp.put("e:/test.jpg", "/opt/upload");\n//下载远程文件\nsftp.get("../../opt/upload/test.jpg"/*tpa=https://doc.hutool.cn/opt/upload/test.jpg*/, "e:/test2.jpg");\n\n//关闭连接\nsftp.close();\n',normalizedContent:'# 介绍\n\nsftp是secure file transfer protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的加密方法。\n\nsftp 为 ssh的一部份，是一种传输文件到服务器的安全方式。sftp是使用加密传输认证信息和数据，所以，使用sftp是非常安全的。\n\n但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的ftp要低得多，如果您对网络安全性要求更高时，可以使用sftp代替ftp。\n\n\n# 使用\n\n\n# 引入jsch\n\n<dependency>\n\t<groupid>com.jcraft</groupid>\n\t<artifactid>jsch</artifactid>\n\t<version>${jsch.version}</version>\n</dependency>\n\n\n\n# 使用\n\nsftp sftp= jschutil.createsftp("172.0.0.1", 22, "root", "123456");\n//进入远程目录\nsftp.cd("/opt/upload");\n//上传本地文件\nsftp.put("e:/test.jpg", "/opt/upload");\n//下载远程文件\nsftp.get("../../opt/upload/test.jpg"/*tpa=https://doc.hutool.cn/opt/upload/test.jpg*/, "e:/test2.jpg");\n\n//关闭连接\nsftp.close();\n',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"Jsch工具-JschUtil",frontmatter:{title:"Jsch工具-JschUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/JschUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/08.Jsch%E5%B0%81%E8%A3%85/01.Jsch%E5%B7%A5%E5%85%B7-JschUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/08.Jsch封装/01.Jsch工具-JschUtil.md",key:"v-c06c8f68",path:"/pages/JschUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:102},{level:3,title:"引入jsch",slug:"引入jsch",normalizedTitle:"引入jsch",charIndex:132},{level:3,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:102},{level:3,title:"ssh连接到远程主机",slug:"ssh连接到远程主机",normalizedTitle:"ssh连接到远程主机",charIndex:329},{level:3,title:"端口映射",slug:"端口映射",normalizedTitle:"端口映射",charIndex:461},{level:3,title:"其它方法",slug:"其它方法",normalizedTitle:"其它方法",charIndex:715}],headersStr:"由来 使用 引入jsch 使用 ssh连接到远程主机 端口映射 其它方法",content:'# 由来\n\n此工具最早来自于我的早期项目：Common-tools，当时是为了解决在存在堡垒机（跳板机）环境时无法穿透堡垒机访问内部主机端口问题，于是辗转找到了jsch库。为了更加便捷的、且容易理解的方式使用此库，因此有了JschUtil。\n\n\n# 使用\n\n\n# 引入jsch\n\n<dependency>\n\t<groupId>com.jcraft</groupId>\n\t<artifactId>jsch</artifactId>\n\t<version>${jsch.version}</version>\n</dependency>\n\n\n> 说明 截止本文档撰写完毕，jsch的最新版为0.1.55，理论上应引入的版本应大于或等于此版本。\n\n\n# 使用\n\n\n# ssh连接到远程主机\n\n//新建会话，此会话用于ssh连接到跳板机（堡垒机），此处为10.1.1.1:22\nSession session = JschUtil.getSession("10.1.1.1", 22, "test", "123456");\n\n\n\n# 端口映射\n\n//新建会话，此会话用于ssh连接到跳板机（堡垒机），此处为10.1.1.1:22\nSession session = JschUtil.getSession("10.1.1.1", 22, "test", "123456");\n\n// 将堡垒机保护的内网8080端口映射到localhost，我们就可以通过访问http://localhost:8080/访问内网服务了\nJschUtil.bindPort(session, "https://doc.hutool.cn/assets/js/172.20.12.123", 8080, 8080);\n\n\n\n# 其它方法\n\n * generateLocalPort 生成一个本地端口（从10001开始尝试，找到一个未被使用的本地端口）\n * unBindPort 解绑端口映射\n * openAndBindPortToLocal 快捷方法，将连接到跳板机和绑定远程主机端口到本地使用一个方法搞定\n * close 关闭SSH会话',normalizedContent:'# 由来\n\n此工具最早来自于我的早期项目：common-tools，当时是为了解决在存在堡垒机（跳板机）环境时无法穿透堡垒机访问内部主机端口问题，于是辗转找到了jsch库。为了更加便捷的、且容易理解的方式使用此库，因此有了jschutil。\n\n\n# 使用\n\n\n# 引入jsch\n\n<dependency>\n\t<groupid>com.jcraft</groupid>\n\t<artifactid>jsch</artifactid>\n\t<version>${jsch.version}</version>\n</dependency>\n\n\n> 说明 截止本文档撰写完毕，jsch的最新版为0.1.55，理论上应引入的版本应大于或等于此版本。\n\n\n# 使用\n\n\n# ssh连接到远程主机\n\n//新建会话，此会话用于ssh连接到跳板机（堡垒机），此处为10.1.1.1:22\nsession session = jschutil.getsession("10.1.1.1", 22, "test", "123456");\n\n\n\n# 端口映射\n\n//新建会话，此会话用于ssh连接到跳板机（堡垒机），此处为10.1.1.1:22\nsession session = jschutil.getsession("10.1.1.1", 22, "test", "123456");\n\n// 将堡垒机保护的内网8080端口映射到localhost，我们就可以通过访问http://localhost:8080/访问内网服务了\njschutil.bindport(session, "https://doc.hutool.cn/assets/js/172.20.12.123", 8080, 8080);\n\n\n\n# 其它方法\n\n * generatelocalport 生成一个本地端口（从10001开始尝试，找到一个未被使用的本地端口）\n * unbindport 解绑端口映射\n * openandbindporttolocal 快捷方法，将连接到跳板机和绑定远程主机端口到本地使用一个方法搞定\n * close 关闭ssh会话',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"二维码工具-QrCodeUtil",frontmatter:{title:"二维码工具-QrCodeUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/QrCodeUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/03.%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B7%A5%E5%85%B7-QrCodeUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/03.二维码工具-QrCodeUtil.md",key:"v-12c3508d",path:"/pages/QrCodeUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:121},{level:3,title:"引入zxing",slug:"引入zxing",normalizedTitle:"引入zxing",charIndex:128},{level:3,title:"生成二维码",slug:"生成二维码",normalizedTitle:"生成二维码",charIndex:364},{level:3,title:"自定义参数（since 4.1.2）",slug:"自定义参数-since-4-1-2",normalizedTitle:"自定义参数（since 4.1.2）",charIndex:550},{level:3,title:"识别二维码",slug:"识别二维码",normalizedTitle:"识别二维码",charIndex:1500},{level:3,title:"生成SVG矢量图二维码（since 5.8.6）",slug:"生成svg矢量图二维码-since-5-8-6",normalizedTitle:"生成svg矢量图二维码（since 5.8.6）",charIndex:1612},{level:3,title:"生成Ascii Art字符画二维码（sincec 5.8.6）",slug:"生成ascii-art字符画二维码-sincec-5-8-6",normalizedTitle:"生成ascii art字符画二维码（sincec 5.8.6）",charIndex:1934}],headersStr:"由来 使用 引入zxing 生成二维码 自定义参数（since 4.1.2） 识别二维码 生成SVG矢量图二维码（since 5.8.6） 生成Ascii Art字符画二维码（sincec 5.8.6）",content:'# 由来\n\n由于大家对二维码的需求较多，对于二维码的生成和解析我认为应该作为简单的工具存在于Hutool中。考虑到自行实现的难度，因此Hutool针对被广泛接受的zxing库进行封装。而由于涉及第三方包，因此归类到extra模块中。\n\n\n# 使用\n\n\n# 引入zxing\n\n考虑到Hutool的非强制依赖性，因此zxing需要用户自行引入：\n\n<dependency>\n\t<groupId>com.google.zxing</groupId>\n\t<artifactId>core</artifactId>\n\t<version>${zxing.version}</version>\n</dependency>\n\n\n> 说明 zxing-3.5.1是此文档编写时的最新版本，理论上你引入的版本应与此版本一致或比这个版本新。\n\n\n# 生成二维码\n\n在此我们将Hutool主页的url生成为二维码，微信扫一扫可以看到H5主页哦：\n\n// 生成指定url对应的二维码到文件，宽和高都是300像素\nQrCodeUtil.generate("https://hutool.cn/", 300, 300, FileUtil.file("d:/qrcode.jpg"));\n\n\n效果qrcode.jpg：\n\n\n\n\n# 自定义参数（since 4.1.2）\n\n 1. 基本参数设定\n\n通过QrConfig可以自定义二维码的生成参数，例如长、宽、二维码的颜色、背景颜色、边距等参数，使用方法如下：\n\nQrConfig config = new QrConfig(300, 300);\n// 设置边距，即二维码和背景之间的边距\nconfig.setMargin(3);\n// 设置前景色，即二维码颜色（青色）\nconfig.setForeColor(Color.CYAN.getRGB());\n// 设置背景色（灰色）\nconfig.setBackColor(Color.GRAY.getRGB());\n\n// 生成二维码到文件，也可以到流\nQrCodeUtil.generate("http://hutool.cn/", config, FileUtil.file("e:/qrcode.jpg"));\n\n\n效果qrcode.jpg:\n\n\n\n 2. 附带logo小图标\n\nQrCodeUtil.generate(//\n\t"http://hutool.cn/", //二维码内容\n\tQrConfig.create().setImg("e:/logo_small.jpg"), //附带logo\n\tFileUtil.file("e:/qrcodeWithLogo.jpg")//写出到的文件\n);\n\n\n效果如图：\n\n\n\n 3. 调整纠错级别\n\n很多时候，二维码无法识别，这时就要调整纠错级别。纠错级别使用zxing的ErrorCorrectionLevel枚举封装，包括：L、M、Q、H几个参数，由低到高。低级别的像素块更大，可以远距离识别，但是遮挡就会造成无法识别。高级别则相反，像素块小，允许遮挡一定范围，但是像素块更密集。\n\nQrConfig config = new QrConfig();\n// 高纠错级别\nconfig.setErrorCorrection(ErrorCorrectionLevel.H);\nQrCodeUtil.generate("https://hutool.cn/", config, FileUtil.file("e:/qrcodeCustom.jpg"));\n\n\n效果如图：\n\n\n\n\n# 识别二维码\n\n// decode -> "http://hutool.cn/"\nString decode = QrCodeUtil.decode(FileUtil.file("d:/qrcode.jpg"));\n\n\n\n# 生成SVG矢量图二维码（since 5.8.6）\n\nQrConfig qrConfig = QrConfig.create().setImg("d:/test/logo.png")\n\t\t\t\t.setForeColor(Color.blue)\n\t\t\t\t.setBackColor(Color.pink)\n\t\t\t\t.setRatio(8)\n\t\t\t\t.setErrorCorrection(ErrorCorrectionLevel.M)\n\t\t\t\t.setMargin(1);\n\t\tString svg = QrCodeUtil.generateAsSvg("https://hutool.cn/", qrConfig);\n\n\n效果如图：\n\n\n\n\n# 生成Ascii Art字符画二维码（sincec 5.8.6）\n\nQrConfig qrConfig = QrConfig.create()\n\t\t\t\t.setForeColor(Color.BLUE)\n\t\t\t\t.setBackColor(Color.MAGENTA)\n\t\t\t\t.setWidth(0)\n\t\t\t\t.setHeight(0).setMargin(1);\n\t\tString asciiArt = QrCodeUtil.generateAsAsciiArt("https://hutool.cn/",qrConfig);\n\n\n生成的二维码字符画文本：\n\n[38;5;21;48;5;201m█▀▀▀▀▀▀▀█▀█▀█▀█▀█▀█▀▀▀▀▀▀▀█[0;39m\n[38;5;21;48;5;201m█ █▀▀▀█ █▀▄▀▄ ▄▀ ▀█ █▀▀▀█ █[0;39m\n[38;5;21;48;5;201m█ █   █ █▀█▄█▄▄▀▄ █ █   █ █[0;39m\n[38;5;21;48;5;201m█ ▀▀▀▀▀ █▀█ █ ▄▀▄▀█ ▀▀▀▀▀ █[0;39m\n[38;5;21;48;5;201m██▀██▀█▀██▄▄▄▀█ ▄▀▀██▀█▀█▀█[0;39m\n[38;5;21;48;5;201m█▄▀▀  ▀▀ ▀▄▀█ ▀▀▀█████▀ ▀ █[0;39m\n[38;5;21;48;5;201m█ ▄▄▀ ▄▀███▀ █▄█▄▀  ▀▄▄█▄▀█[0;39m\n[38;5;21;48;5;201m██▀ ▀▀█▀█▄ ▀▄▀█▄██▄▀ ▀▀▄███[0;39m\n[38;5;21;48;5;201m█ ▄▄▄▄█▀█▀  ▀█▀ ▀▀▀ ▀   ▄ █[0;39m\n[38;5;21;48;5;201m█▀▀▀▀▀▀▀██▀  █▄ ▀ █▀█ █ █▄█[0;39m\n[38;5;21;48;5;201m█ █▀▀▀█ █▀▀█▄▄▀█▄ ▀▀▀  █▀▀█[0;39m\n[38;5;21;48;5;201m█ █   █ ███▄█▀█▄█▀█▄▄▀█▄▄▄█[0;39m\n[38;5;21;48;5;201m█ ▀▀▀▀▀ █▄▄█   ▀█▀▄  ██▀▀ █[0;39m\n[38;5;21;48;5;201m▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀[0;39m\n\n\n打印到控制台的效果：\n\n',normalizedContent:'# 由来\n\n由于大家对二维码的需求较多，对于二维码的生成和解析我认为应该作为简单的工具存在于hutool中。考虑到自行实现的难度，因此hutool针对被广泛接受的zxing库进行封装。而由于涉及第三方包，因此归类到extra模块中。\n\n\n# 使用\n\n\n# 引入zxing\n\n考虑到hutool的非强制依赖性，因此zxing需要用户自行引入：\n\n<dependency>\n\t<groupid>com.google.zxing</groupid>\n\t<artifactid>core</artifactid>\n\t<version>${zxing.version}</version>\n</dependency>\n\n\n> 说明 zxing-3.5.1是此文档编写时的最新版本，理论上你引入的版本应与此版本一致或比这个版本新。\n\n\n# 生成二维码\n\n在此我们将hutool主页的url生成为二维码，微信扫一扫可以看到h5主页哦：\n\n// 生成指定url对应的二维码到文件，宽和高都是300像素\nqrcodeutil.generate("https://hutool.cn/", 300, 300, fileutil.file("d:/qrcode.jpg"));\n\n\n效果qrcode.jpg：\n\n\n\n\n# 自定义参数（since 4.1.2）\n\n 1. 基本参数设定\n\n通过qrconfig可以自定义二维码的生成参数，例如长、宽、二维码的颜色、背景颜色、边距等参数，使用方法如下：\n\nqrconfig config = new qrconfig(300, 300);\n// 设置边距，即二维码和背景之间的边距\nconfig.setmargin(3);\n// 设置前景色，即二维码颜色（青色）\nconfig.setforecolor(color.cyan.getrgb());\n// 设置背景色（灰色）\nconfig.setbackcolor(color.gray.getrgb());\n\n// 生成二维码到文件，也可以到流\nqrcodeutil.generate("http://hutool.cn/", config, fileutil.file("e:/qrcode.jpg"));\n\n\n效果qrcode.jpg:\n\n\n\n 2. 附带logo小图标\n\nqrcodeutil.generate(//\n\t"http://hutool.cn/", //二维码内容\n\tqrconfig.create().setimg("e:/logo_small.jpg"), //附带logo\n\tfileutil.file("e:/qrcodewithlogo.jpg")//写出到的文件\n);\n\n\n效果如图：\n\n\n\n 3. 调整纠错级别\n\n很多时候，二维码无法识别，这时就要调整纠错级别。纠错级别使用zxing的errorcorrectionlevel枚举封装，包括：l、m、q、h几个参数，由低到高。低级别的像素块更大，可以远距离识别，但是遮挡就会造成无法识别。高级别则相反，像素块小，允许遮挡一定范围，但是像素块更密集。\n\nqrconfig config = new qrconfig();\n// 高纠错级别\nconfig.seterrorcorrection(errorcorrectionlevel.h);\nqrcodeutil.generate("https://hutool.cn/", config, fileutil.file("e:/qrcodecustom.jpg"));\n\n\n效果如图：\n\n\n\n\n# 识别二维码\n\n// decode -> "http://hutool.cn/"\nstring decode = qrcodeutil.decode(fileutil.file("d:/qrcode.jpg"));\n\n\n\n# 生成svg矢量图二维码（since 5.8.6）\n\nqrconfig qrconfig = qrconfig.create().setimg("d:/test/logo.png")\n\t\t\t\t.setforecolor(color.blue)\n\t\t\t\t.setbackcolor(color.pink)\n\t\t\t\t.setratio(8)\n\t\t\t\t.seterrorcorrection(errorcorrectionlevel.m)\n\t\t\t\t.setmargin(1);\n\t\tstring svg = qrcodeutil.generateassvg("https://hutool.cn/", qrconfig);\n\n\n效果如图：\n\n\n\n\n# 生成ascii art字符画二维码（sincec 5.8.6）\n\nqrconfig qrconfig = qrconfig.create()\n\t\t\t\t.setforecolor(color.blue)\n\t\t\t\t.setbackcolor(color.magenta)\n\t\t\t\t.setwidth(0)\n\t\t\t\t.setheight(0).setmargin(1);\n\t\tstring asciiart = qrcodeutil.generateasasciiart("https://hutool.cn/",qrconfig);\n\n\n生成的二维码字符画文本：\n\n[38;5;21;48;5;201m█▀▀▀▀▀▀▀█▀█▀█▀█▀█▀█▀▀▀▀▀▀▀█[0;39m\n[38;5;21;48;5;201m█ █▀▀▀█ █▀▄▀▄ ▄▀ ▀█ █▀▀▀█ █[0;39m\n[38;5;21;48;5;201m█ █   █ █▀█▄█▄▄▀▄ █ █   █ █[0;39m\n[38;5;21;48;5;201m█ ▀▀▀▀▀ █▀█ █ ▄▀▄▀█ ▀▀▀▀▀ █[0;39m\n[38;5;21;48;5;201m██▀██▀█▀██▄▄▄▀█ ▄▀▀██▀█▀█▀█[0;39m\n[38;5;21;48;5;201m█▄▀▀  ▀▀ ▀▄▀█ ▀▀▀█████▀ ▀ █[0;39m\n[38;5;21;48;5;201m█ ▄▄▀ ▄▀███▀ █▄█▄▀  ▀▄▄█▄▀█[0;39m\n[38;5;21;48;5;201m██▀ ▀▀█▀█▄ ▀▄▀█▄██▄▀ ▀▀▄███[0;39m\n[38;5;21;48;5;201m█ ▄▄▄▄█▀█▀  ▀█▀ ▀▀▀ ▀   ▄ █[0;39m\n[38;5;21;48;5;201m█▀▀▀▀▀▀▀██▀  █▄ ▀ █▀█ █ █▄█[0;39m\n[38;5;21;48;5;201m█ █▀▀▀█ █▀▀█▄▄▀█▄ ▀▀▀  █▀▀█[0;39m\n[38;5;21;48;5;201m█ █   █ ███▄█▀█▄█▀█▄▄▀█▄▄▄█[0;39m\n[38;5;21;48;5;201m█ ▀▀▀▀▀ █▄▄█   ▀█▀▄  ██▀▀ █[0;39m\n[38;5;21;48;5;201m▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀[0;39m\n\n\n打印到控制台的效果：\n\n',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"中文分词封装-TokenizerUtil",frontmatter:{title:"中文分词封装-TokenizerUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/TokenizerUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/10.%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/01.%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%B0%81%E8%A3%85-TokenizerUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/10.中文分词/01.中文分词封装-TokenizerUtil.md",key:"v-8467c352",path:"/pages/TokenizerUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:287},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:35},{level:3,title:"解析文本并分词",slug:"解析文本并分词",normalizedTitle:"解析文本并分词",charIndex:575},{level:3,title:"自定义模板引擎",slug:"自定义模板引擎",normalizedTitle:"自定义模板引擎",charIndex:924}],headersStr:"介绍 原理 使用 解析文本并分词 自定义模板引擎",content:'# 介绍\n\n现阶段，应用于搜索引擎和自然语言处理的中文分词库五花八门，使用方式各不统一，虽然有适配于Lucene和Elasticsearch的插件，但是我们想在多个库之间选择更换时，依旧有学习时间。\n\nHutool针对常见中文分词库做了统一接口封装，即定义一套规范，隔离各个库的差异，做到一段代码，随意更换。\n\nHutool现在封装的引擎有：\n\n * Ansj\n * HanLP\n * IKAnalyzer\n * Jcseg\n * Jieba\n * mmseg4j\n * Word\n * Smartcn\n\n> 注意 此工具和模块从Hutool-4.4.0开始支持。\n\n\n# 原理\n\n类似于Java日志门面的思想，Hutool将分词引擎的渲染抽象为三个概念：\n\n * TokenizerEngine 分词引擎，用于封装分词库对象\n * Result 分词结果接口定义，用于抽象对文本分词的结果，实现了Iterator和Iterable接口，用于遍历分词\n * Word 表示分词中的一个词，既分词后的单词，可以获取单词文本、起始位置和结束位置等信息\n\n通过实现这三个接口，用户便可抛开分词库的差异，实现多文本分词。\n\nHutool同时会通过TokenizerFactory根据用户引入的分词库的jar来自动选择用哪个库实现分词。\n\n\n# 使用\n\n\n# 解析文本并分词\n\n//自动根据用户引入的分词库的jar来自动选择使用的引擎\nTokenizerEngine engine = TokenizerUtil.createEngine();\n\n//解析文本\nString text = "这两个方法的区别在于返回值";\nResult result = engine.parse(text);\n//输出：这 两个 方法 的 区别 在于 返回 值\nString resultStr = CollUtil.join((Iterator<Word>)result, " ");\n\n\n当你引入Ansj，会自动路由到Ansj的库去实现分词，引入HanLP则会路由到HanLP，依此类推。\n\n也就是说，使用Hutool之后，无论你用任何一种分词库，代码不变。\n\n\n# 自定义模板引擎\n\n此处以HanLP为例：\n\nTokenizerEngine engine = new HanLPEngine();\n\n//解析文本\nString text = "这两个方法的区别在于返回值";\nResult result = engine.parse(text);\n//输出：这 两个 方法 的 区别 在于 返回 值\nString resultStr = CollUtil.join((Iterator<Word>)result, " ");\n',normalizedContent:'# 介绍\n\n现阶段，应用于搜索引擎和自然语言处理的中文分词库五花八门，使用方式各不统一，虽然有适配于lucene和elasticsearch的插件，但是我们想在多个库之间选择更换时，依旧有学习时间。\n\nhutool针对常见中文分词库做了统一接口封装，即定义一套规范，隔离各个库的差异，做到一段代码，随意更换。\n\nhutool现在封装的引擎有：\n\n * ansj\n * hanlp\n * ikanalyzer\n * jcseg\n * jieba\n * mmseg4j\n * word\n * smartcn\n\n> 注意 此工具和模块从hutool-4.4.0开始支持。\n\n\n# 原理\n\n类似于java日志门面的思想，hutool将分词引擎的渲染抽象为三个概念：\n\n * tokenizerengine 分词引擎，用于封装分词库对象\n * result 分词结果接口定义，用于抽象对文本分词的结果，实现了iterator和iterable接口，用于遍历分词\n * word 表示分词中的一个词，既分词后的单词，可以获取单词文本、起始位置和结束位置等信息\n\n通过实现这三个接口，用户便可抛开分词库的差异，实现多文本分词。\n\nhutool同时会通过tokenizerfactory根据用户引入的分词库的jar来自动选择用哪个库实现分词。\n\n\n# 使用\n\n\n# 解析文本并分词\n\n//自动根据用户引入的分词库的jar来自动选择使用的引擎\ntokenizerengine engine = tokenizerutil.createengine();\n\n//解析文本\nstring text = "这两个方法的区别在于返回值";\nresult result = engine.parse(text);\n//输出：这 两个 方法 的 区别 在于 返回 值\nstring resultstr = collutil.join((iterator<word>)result, " ");\n\n\n当你引入ansj，会自动路由到ansj的库去实现分词，引入hanlp则会路由到hanlp，依此类推。\n\n也就是说，使用hutool之后，无论你用任何一种分词库，代码不变。\n\n\n# 自定义模板引擎\n\n此处以hanlp为例：\n\ntokenizerengine engine = new hanlpengine();\n\n//解析文本\nstring text = "这两个方法的区别在于返回值";\nresult result = engine.parse(text);\n//输出：这 两个 方法 的 区别 在于 返回 值\nstring resultstr = collutil.join((iterator<word>)result, " ");\n',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"邮件工具-MailUtil",frontmatter:{title:"邮件工具-MailUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/MailUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/04.%E9%82%AE%E4%BB%B6%E5%B7%A5%E5%85%B7-MailUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/04.邮件工具-MailUtil.md",key:"v-1bec1f01",path:"/pages/MailUtil/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:36},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:99},{level:3,title:"邮件服务器配置",slug:"邮件服务器配置",normalizedTitle:"邮件服务器配置",charIndex:337},{level:2,title:"发送邮件",slug:"发送邮件",normalizedTitle:"发送邮件",charIndex:12},{level:3,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:1635}],headersStr:"概述 使用 引入依赖 邮件服务器配置 发送邮件 其它",content:'# 概述\n\n在Java中发送邮件主要依靠javax.mail包，但是由于使用比较繁琐，因此Hutool针对其做了封装。由于依赖第三方包，因此将此工具类归类到extra模块中。\n\n\n# 使用\n\n\n# 引入依赖\n\nHutool对所有第三方都是可选依赖，因此在使用MailUtil时需要自行引入第三方依赖。\n\n<dependency>\n\t<groupId>com.sun.mail</groupId>\n\t<artifactId>javax.mail</artifactId>\n\t<version>${mail.version}</version>\n</dependency>\n\n\n> 说明 com.sun.mail是javax.mail升级后的版本，新版本包名做了变更。\n\n\n# 邮件服务器配置\n\n在classpath（在标准Maven项目中为src/main/resources）的config目录下新建mail.setting文件，最小配置内容如下，在此配置下，smtp服务器和用户名都将通过from参数识别：\n\n# 发件人（必须正确，否则发送失败）\nfrom = hutool@yeah.net\n# 密码（注意，某些邮箱需要为SMTP服务单独设置密码，详情查看相关帮助）\npass = q1w2e3\n\n\n有时候一些非标准邮箱服务器（例如企业邮箱服务器）的smtp地址等信息并不与发件人后缀一致，端口也可能不同，此时Hutool可以提供完整的配置文件：\n\n完整配置\n\n# 邮件服务器的SMTP地址，可选，默认为smtp.<发件人邮箱后缀>\nhost = smtp.yeah.net\n# 邮件服务器的SMTP端口，可选，默认25\nport = 25\n# 发件人（必须正确，否则发送失败）\nfrom = hutool@yeah.net\n# 用户名，默认为发件人邮箱前缀\nuser = hutool\n# 密码（注意，某些邮箱需要为SMTP服务单独设置授权码，详情查看相关帮助）\npass = q1w2e3\n\n\n> 注意\n> 邮件服务器必须支持并打开SMTP协议，详细请查看相关帮助说明\n> 配置文件的样例中提供的是我专门为测试邮件功能注册的yeah.net邮箱，帐号密码公开，供Hutool用户测试使用。\n\n\n# 发送邮件\n\n 1. 发送普通文本邮件，最后一个参数可选是否添加多个附件：\n\nMailUtil.send("https://doc.hutool.cn/assets/js/hutool@foxmail.com", "测试", "邮件来自Hutool测试", false);\n\n\n 2. 发送HTML格式的邮件并附带附件，最后一个参数可选是否添加多个附件：\n\nMailUtil.send("https://doc.hutool.cn/assets/js/hutool@foxmail.com", "测试", "<h1>邮件来自Hutool测试</h1>", true, FileUtil.file("d:/aaa.xml"));\n\n\n 3. 群发邮件，可选HTML或普通文本，可选多个附件：\n\nArrayList<String> tos = CollUtil.newArrayList(\n\t"https://doc.hutool.cn/assets/js/person1@bbb.com", \n\t"https://doc.hutool.cn/assets/js/person2@bbb.com", \n\t"https://doc.hutool.cn/assets/js/person3@bbb.com", \n\t"https://doc.hutool.cn/assets/js/person4@bbb.com");\n\nMailUtil.send(tos, "测试", "邮件来自Hutool群发测试", false);\n\n\n发送邮件非常简单，只需一个方法即可搞定其中按照参数顺序说明如下：\n\n 1. tos: 对方的邮箱地址，可以是单个，也可以是多个（Collection表示）\n 2. subject：标题\n 3. content：邮件正文，可以是文本，也可以是HTML内容\n 4. isHtml： 是否为HTML，如果是，那参数3识别为HTML内容\n 5. files： 可选：附件，可以为多个或没有，将File对象加在最后一个可变参数中即可\n\n\n# 其它\n\n 1. 自定义邮件服务器\n\n除了使用配置文件定义全局账号以外，MailUtil.send方法同时提供重载方法可以传入一个MailAccount对象，这个对象为一个普通Bean，记录了邮件服务器信息。\n\nMailAccount account = new MailAccount();\naccount.setHost("https://doc.hutool.cn/assets/js/smtp.yeah.net");\naccount.setPort("25");\naccount.setAuth(true);\naccount.setFrom("https://doc.hutool.cn/assets/js/hutool@yeah.net");\naccount.setUser("hutool");\naccount.setPass("q1w2e3");\n\nMailUtil.send(account, CollUtil.newArrayList("https://doc.hutool.cn/assets/js/hutool@foxmail.com"), "测试", "邮件来自Hutool测试", false);\n\n\n 2. 使用SSL加密方式发送邮件 在使用QQ或Gmail邮箱时，需要强制开启SSL支持，此时我们只需修改配置文件即可：\n\n# 发件人（必须正确，否则发送失败），“小磊”可以任意变更，<>内的地址必须唯一，以下方式也对\n# from = hutool@yeah.net\nfrom = 小磊<hutool@yeah.net>\n# 密码（注意，某些邮箱需要为SMTP服务单独设置密码，详情查看相关帮助）\npass = q1w2e3\n# 使用SSL安全连接\nsslEnable = true\n\n\n在原先极简配置下只需加入sslEnable即可完成SSL连接，当然，这是最简单的配置，很多参数根据已有参数已设置为默认。\n\n完整的配置文件如下：\n\n# 邮件服务器的SMTP地址\nhost = smtp.yeah.net\n# 邮件服务器的SMTP端口\nport = 465\n# 发件人（必须正确，否则发送失败）\nfrom = hutool@yeah.net\n# 用户名（注意：如果使用foxmail邮箱，此处user为qq号）\nuser = hutool\n# 密码（注意，某些邮箱需要为SMTP服务单独设置密码，详情查看相关帮助）\npass = q1w2e3\n#使用 STARTTLS安全连接，STARTTLS是对纯文本通信协议的扩展。\nstarttlsEnable = true\n\n# 使用SSL安全连接\nsslEnable = true\n# 指定实现javax.net.SocketFactory接口的类的名称,这个类将被用于创建SMTP的套接字\nsocketFactoryClass = javax.net.ssl.SSLSocketFactory\n# 如果设置为true,未能创建一个套接字使用指定的套接字工厂类将导致使用java.net.Socket创建的套接字类, 默认值为true\nsocketFactoryFallback = true\n# 指定的端口连接到使用的套接字工厂。如果没有设置,将使用默认端口465\nsocketFactoryPort = 465\n\n# SMTP超时时长，单位毫秒，缺省值不超时\ntimeout = 0\n# Socket连接超时值，单位毫秒，缺省值不超时\nconnectionTimeout = 0\n\n\n 3. 针对QQ邮箱和Foxmail邮箱的说明\n\n(1) QQ邮箱中SMTP密码是单独生成的授权码，而非你的QQ密码，至于怎么生成，见腾讯的帮助说明：什么是授权码，它又是如何设置？\n\n使用帮助引导生成授权码后，配置如下即可：\n\npass = 你生成的授权码\n\n\n(2) Foxmail邮箱本质上也是QQ邮箱的一种别名，你可以在你的QQ邮箱中设置一个foxmail邮箱，不过配置上有所区别。在Hutool中user属性默认提取你邮箱@前面的部分，但是对于foxmail邮箱是无效的，需要单独配置为与之绑定的qq号码或者XXXX@qq.com的XXXX。即：\n\nhost = smtp.qq.com\nfrom = XXXX@foxmail.com\nuser = foxmail邮箱对应的QQ号码或者qq邮箱@前面部分\n...\n\n\n(3) 阿里云邮箱的user是邮箱的完整地址，即xxx@aliyun.com\n\n 4. 针对QQ邮箱（foxmail）PKIX path building failed错误（since 5.6.4）\n\n部分用户反馈发送邮件时会遇到错误：\n\ncn.hutool.extra.mail.MailException: MessagingException: Could not connect to SMTP host: smtp.qq.com, port: 465\n...\nCaused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\n\n这个错误可能是需要SSL验证造成的，我们可以手动跳过这个验证：\n\nMailAccount mailAccount = new MailAccount();\nmailAccount.setAuth(true);\nmailAccount.setSslEnable(true);\n...\nMailSSLSocketFactory sf = new MailSSLSocketFactory();\nsf.setTrustAllHosts(true);\nmailAccount.setCustomProperty("mail.smtp.ssl.socketFactory", sf);\n\nMail mail = Mail.create(mailAccount)\n    .setTos("https://doc.hutool.cn/assets/js/xx@xx.com")\n\t.setTitle("邮箱验证")\n\t.setContent("您的验证码是：<h3>2333</h3>")\n\t.setHtml(true)\n\t.send();\n',normalizedContent:'# 概述\n\n在java中发送邮件主要依靠javax.mail包，但是由于使用比较繁琐，因此hutool针对其做了封装。由于依赖第三方包，因此将此工具类归类到extra模块中。\n\n\n# 使用\n\n\n# 引入依赖\n\nhutool对所有第三方都是可选依赖，因此在使用mailutil时需要自行引入第三方依赖。\n\n<dependency>\n\t<groupid>com.sun.mail</groupid>\n\t<artifactid>javax.mail</artifactid>\n\t<version>${mail.version}</version>\n</dependency>\n\n\n> 说明 com.sun.mail是javax.mail升级后的版本，新版本包名做了变更。\n\n\n# 邮件服务器配置\n\n在classpath（在标准maven项目中为src/main/resources）的config目录下新建mail.setting文件，最小配置内容如下，在此配置下，smtp服务器和用户名都将通过from参数识别：\n\n# 发件人（必须正确，否则发送失败）\nfrom = hutool@yeah.net\n# 密码（注意，某些邮箱需要为smtp服务单独设置密码，详情查看相关帮助）\npass = q1w2e3\n\n\n有时候一些非标准邮箱服务器（例如企业邮箱服务器）的smtp地址等信息并不与发件人后缀一致，端口也可能不同，此时hutool可以提供完整的配置文件：\n\n完整配置\n\n# 邮件服务器的smtp地址，可选，默认为smtp.<发件人邮箱后缀>\nhost = smtp.yeah.net\n# 邮件服务器的smtp端口，可选，默认25\nport = 25\n# 发件人（必须正确，否则发送失败）\nfrom = hutool@yeah.net\n# 用户名，默认为发件人邮箱前缀\nuser = hutool\n# 密码（注意，某些邮箱需要为smtp服务单独设置授权码，详情查看相关帮助）\npass = q1w2e3\n\n\n> 注意\n> 邮件服务器必须支持并打开smtp协议，详细请查看相关帮助说明\n> 配置文件的样例中提供的是我专门为测试邮件功能注册的yeah.net邮箱，帐号密码公开，供hutool用户测试使用。\n\n\n# 发送邮件\n\n 1. 发送普通文本邮件，最后一个参数可选是否添加多个附件：\n\nmailutil.send("https://doc.hutool.cn/assets/js/hutool@foxmail.com", "测试", "邮件来自hutool测试", false);\n\n\n 2. 发送html格式的邮件并附带附件，最后一个参数可选是否添加多个附件：\n\nmailutil.send("https://doc.hutool.cn/assets/js/hutool@foxmail.com", "测试", "<h1>邮件来自hutool测试</h1>", true, fileutil.file("d:/aaa.xml"));\n\n\n 3. 群发邮件，可选html或普通文本，可选多个附件：\n\narraylist<string> tos = collutil.newarraylist(\n\t"https://doc.hutool.cn/assets/js/person1@bbb.com", \n\t"https://doc.hutool.cn/assets/js/person2@bbb.com", \n\t"https://doc.hutool.cn/assets/js/person3@bbb.com", \n\t"https://doc.hutool.cn/assets/js/person4@bbb.com");\n\nmailutil.send(tos, "测试", "邮件来自hutool群发测试", false);\n\n\n发送邮件非常简单，只需一个方法即可搞定其中按照参数顺序说明如下：\n\n 1. tos: 对方的邮箱地址，可以是单个，也可以是多个（collection表示）\n 2. subject：标题\n 3. content：邮件正文，可以是文本，也可以是html内容\n 4. ishtml： 是否为html，如果是，那参数3识别为html内容\n 5. files： 可选：附件，可以为多个或没有，将file对象加在最后一个可变参数中即可\n\n\n# 其它\n\n 1. 自定义邮件服务器\n\n除了使用配置文件定义全局账号以外，mailutil.send方法同时提供重载方法可以传入一个mailaccount对象，这个对象为一个普通bean，记录了邮件服务器信息。\n\nmailaccount account = new mailaccount();\naccount.sethost("https://doc.hutool.cn/assets/js/smtp.yeah.net");\naccount.setport("25");\naccount.setauth(true);\naccount.setfrom("https://doc.hutool.cn/assets/js/hutool@yeah.net");\naccount.setuser("hutool");\naccount.setpass("q1w2e3");\n\nmailutil.send(account, collutil.newarraylist("https://doc.hutool.cn/assets/js/hutool@foxmail.com"), "测试", "邮件来自hutool测试", false);\n\n\n 2. 使用ssl加密方式发送邮件 在使用qq或gmail邮箱时，需要强制开启ssl支持，此时我们只需修改配置文件即可：\n\n# 发件人（必须正确，否则发送失败），“小磊”可以任意变更，<>内的地址必须唯一，以下方式也对\n# from = hutool@yeah.net\nfrom = 小磊<hutool@yeah.net>\n# 密码（注意，某些邮箱需要为smtp服务单独设置密码，详情查看相关帮助）\npass = q1w2e3\n# 使用ssl安全连接\nsslenable = true\n\n\n在原先极简配置下只需加入sslenable即可完成ssl连接，当然，这是最简单的配置，很多参数根据已有参数已设置为默认。\n\n完整的配置文件如下：\n\n# 邮件服务器的smtp地址\nhost = smtp.yeah.net\n# 邮件服务器的smtp端口\nport = 465\n# 发件人（必须正确，否则发送失败）\nfrom = hutool@yeah.net\n# 用户名（注意：如果使用foxmail邮箱，此处user为qq号）\nuser = hutool\n# 密码（注意，某些邮箱需要为smtp服务单独设置密码，详情查看相关帮助）\npass = q1w2e3\n#使用 starttls安全连接，starttls是对纯文本通信协议的扩展。\nstarttlsenable = true\n\n# 使用ssl安全连接\nsslenable = true\n# 指定实现javax.net.socketfactory接口的类的名称,这个类将被用于创建smtp的套接字\nsocketfactoryclass = javax.net.ssl.sslsocketfactory\n# 如果设置为true,未能创建一个套接字使用指定的套接字工厂类将导致使用java.net.socket创建的套接字类, 默认值为true\nsocketfactoryfallback = true\n# 指定的端口连接到使用的套接字工厂。如果没有设置,将使用默认端口465\nsocketfactoryport = 465\n\n# smtp超时时长，单位毫秒，缺省值不超时\ntimeout = 0\n# socket连接超时值，单位毫秒，缺省值不超时\nconnectiontimeout = 0\n\n\n 3. 针对qq邮箱和foxmail邮箱的说明\n\n(1) qq邮箱中smtp密码是单独生成的授权码，而非你的qq密码，至于怎么生成，见腾讯的帮助说明：什么是授权码，它又是如何设置？\n\n使用帮助引导生成授权码后，配置如下即可：\n\npass = 你生成的授权码\n\n\n(2) foxmail邮箱本质上也是qq邮箱的一种别名，你可以在你的qq邮箱中设置一个foxmail邮箱，不过配置上有所区别。在hutool中user属性默认提取你邮箱@前面的部分，但是对于foxmail邮箱是无效的，需要单独配置为与之绑定的qq号码或者xxxx@qq.com的xxxx。即：\n\nhost = smtp.qq.com\nfrom = xxxx@foxmail.com\nuser = foxmail邮箱对应的qq号码或者qq邮箱@前面部分\n...\n\n\n(3) 阿里云邮箱的user是邮箱的完整地址，即xxx@aliyun.com\n\n 4. 针对qq邮箱（foxmail）pkix path building failed错误（since 5.6.4）\n\n部分用户反馈发送邮件时会遇到错误：\n\ncn.hutool.extra.mail.mailexception: messagingexception: could not connect to smtp host: smtp.qq.com, port: 465\n...\ncaused by: javax.net.ssl.sslhandshakeexception: sun.security.validator.validatorexception: pkix path building failed: sun.security.provider.certpath.suncertpathbuilderexception: unable to find valid certification path to requested target\n\n\n这个错误可能是需要ssl验证造成的，我们可以手动跳过这个验证：\n\nmailaccount mailaccount = new mailaccount();\nmailaccount.setauth(true);\nmailaccount.setsslenable(true);\n...\nmailsslsocketfactory sf = new mailsslsocketfactory();\nsf.settrustallhosts(true);\nmailaccount.setcustomproperty("mail.smtp.ssl.socketfactory", sf);\n\nmail mail = mail.create(mailaccount)\n    .settos("https://doc.hutool.cn/assets/js/xx@xx.com")\n\t.settitle("邮箱验证")\n\t.setcontent("您的验证码是：<h3>2333</h3>")\n\t.sethtml(true)\n\t.send();\n',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"压缩封装-CompressUtil",frontmatter:{title:"压缩封装-CompressUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/CompressUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/11.%E5%8E%8B%E7%BC%A9/01.%E5%8E%8B%E7%BC%A9%E5%B0%81%E8%A3%85-CompressUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/11.压缩/01.压缩封装-CompressUtil.md",key:"v-d10ed3b6",path:"/pages/CompressUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:388},{level:3,title:"压缩文件",slug:"压缩文件",normalizedTitle:"压缩文件",charIndex:379},{level:3,title:"解压文件",slug:"解压文件",normalizedTitle:"解压文件",charIndex:1198}],headersStr:"介绍 使用 压缩文件 解压文件",content:'# 介绍\n\n虽然Hutool基于JDK提供了ZipUtil用于压缩或解压ZIP相关文件，但是对于7zip、tar等格式的压缩依旧无法处理，于是基于commons-compress做了进一步封装：CompressUtil。\n\n此工具支持的格式有：\n\n对于流式压缩支持：\n\n * GZIP\n * BZIP2\n * XZ\n * PACK200\n * SNAPPY_FRAMED\n * LZ4_BLOCK\n * LZ4_FRAMED\n * ZSTANDARD\n * DEFLATE\n\n对于归档文件支持：\n\n * AR\n * CPIO\n * JAR\n * TAR\n * ZIP\n * 7z\n\n对于归档文件，Hutool提供了两个通用接口：\n\n * Archiver 数据归档，提供打包工作，如增加文件到压缩包等\n * Extractor 归档数据解包，用于解压或者提取压缩文件\n\n\n# 使用\n\n首先引入commons-compress\n\n<dependency>\n\t<groupId>org.apache.commons</groupId>\n\t<artifactId>commons-compress</artifactId>\n\t<version>1.24</version>\n</dependency>\n\n\n\n# 压缩文件\n\n我们以7Zip为例：\n\nfinal File file = FileUtil.file("d:/test/compress/test.7z");\nCompressUtil.createArchiver(CharsetUtil.CHARSET_UTF_8, ArchiveStreamFactory.SEVEN_Z, file)\n\t.add(FileUtil.file("d:/test/someFiles"));\n\t.finish()\n\t.close();\n\n\n其中ArchiveStreamFactory.SEVEN_Z就是自定义的压缩格式，可以自行选择\n\nadd方法支持文件和目录，多个文件/目录多次调用add方法即可。\n\n有时候我们不想把目录下所有的文件放到压缩包，这时候可以使用add方法的第二个参数Filter，此接口用于过滤不需要加入的文件。\n\nCompressUtil.createArchiver(CharsetUtil.CHARSET_UTF_8, ArchiveStreamFactory.SEVEN_Z, zipFile)\n\t.add(FileUtil.file("d:/Java/apache-maven-3.6.3"), (file)->{\n\t\tif("invalid".equals(file.getName())){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t})\n\t.finish().close();\n\n\n\n# 解压文件\n\n我们以7Zip为例：\n\nExtractor extractor = \tCompressUtil.createExtractor(\n\t\tCharsetUtil.defaultCharset(),\n\t\tFileUtil.file("d:/test/compress/test.7z"));\n\nextractor.extract(FileUtil.file("d:/test/compress/test2/"));\n',normalizedContent:'# 介绍\n\n虽然hutool基于jdk提供了ziputil用于压缩或解压zip相关文件，但是对于7zip、tar等格式的压缩依旧无法处理，于是基于commons-compress做了进一步封装：compressutil。\n\n此工具支持的格式有：\n\n对于流式压缩支持：\n\n * gzip\n * bzip2\n * xz\n * pack200\n * snappy_framed\n * lz4_block\n * lz4_framed\n * zstandard\n * deflate\n\n对于归档文件支持：\n\n * ar\n * cpio\n * jar\n * tar\n * zip\n * 7z\n\n对于归档文件，hutool提供了两个通用接口：\n\n * archiver 数据归档，提供打包工作，如增加文件到压缩包等\n * extractor 归档数据解包，用于解压或者提取压缩文件\n\n\n# 使用\n\n首先引入commons-compress\n\n<dependency>\n\t<groupid>org.apache.commons</groupid>\n\t<artifactid>commons-compress</artifactid>\n\t<version>1.24</version>\n</dependency>\n\n\n\n# 压缩文件\n\n我们以7zip为例：\n\nfinal file file = fileutil.file("d:/test/compress/test.7z");\ncompressutil.createarchiver(charsetutil.charset_utf_8, archivestreamfactory.seven_z, file)\n\t.add(fileutil.file("d:/test/somefiles"));\n\t.finish()\n\t.close();\n\n\n其中archivestreamfactory.seven_z就是自定义的压缩格式，可以自行选择\n\nadd方法支持文件和目录，多个文件/目录多次调用add方法即可。\n\n有时候我们不想把目录下所有的文件放到压缩包，这时候可以使用add方法的第二个参数filter，此接口用于过滤不需要加入的文件。\n\ncompressutil.createarchiver(charsetutil.charset_utf_8, archivestreamfactory.seven_z, zipfile)\n\t.add(fileutil.file("d:/java/apache-maven-3.6.3"), (file)->{\n\t\tif("invalid".equals(file.getname())){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t})\n\t.finish().close();\n\n\n\n# 解压文件\n\n我们以7zip为例：\n\nextractor extractor = \tcompressutil.createextractor(\n\t\tcharsetutil.defaultcharset(),\n\t\tfileutil.file("d:/test/compress/test.7z"));\n\nextractor.extract(fileutil.file("d:/test/compress/test2/"));\n',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"拼音工具-PinyinUtil",frontmatter:{title:"拼音工具-PinyinUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/PinyinUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/12.%E6%8B%BC%E9%9F%B3/01.%E6%8B%BC%E9%9F%B3%E5%B7%A5%E5%85%B7-PinyinUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/12.拼音/01.拼音工具-PinyinUtil.md",key:"v-59892333",path:"/pages/PinyinUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:205},{level:3,title:"引入库",slug:"引入库",normalizedTitle:"引入库",charIndex:212},{level:3,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:205}],headersStr:"介绍 使用 引入库 使用",content:'# 介绍\n\n拼音工具类在旧版本的Hutool中在core包中，但是发现自己实现相关功能需要庞大的字典，放在core包中便是累赘。\n\n于是为了方便，Hutool封装了拼音的门面，用于兼容以下拼音库:\n\n 1. TinyPinyin\n 2. JPinyin\n 3. Pinyin4j\n\n和其它门面模块类似，采用SPI方式识别所用的库。例如你想用Pinyin4j，只需引入jar，Hutool即可自动识别。\n\n\n# 使用\n\n\n# 引入库\n\n以下为Hutool支持的拼音库的pom坐标，你可以选择任意一个引入项目中，如果引入多个，Hutool会按照以上顺序选择第一个使用。\n\n<dependency>\n\t<groupId>io.github.biezhi</groupId>\n\t<artifactId>TinyPinyin</artifactId>\n\t<version>2.0.3.RELEASE</version>\n</dependency>\n\n\n<dependency>\n\t<groupId>com.belerweb</groupId>\n\t<artifactId>pinyin4j</artifactId>\n\t<version>2.5.1</version>\n</dependency>\n\n\n<dependency>\n\t<groupId>com.github.stuxuhai</groupId>\n\t<artifactId>jpinyin</artifactId>\n\t<version>1.1.8</version>\n</dependency>\n\n\n\n# 使用\n\n 1. 获取拼音\n\n// "ni hao"\nString pinyin = PinyinUtil.getPinyin("你好", " ");\n\n\n这里定义的分隔符为空格，你也可以按照需求自定义分隔符，亦或者使用""代表无分隔符。\n\n 2. 获取拼音首字母\n\n// "h, s, d, y, g"\nString result = PinyinUtil.getFirstLetter("H是第一个", ", ");\n\n\n 3. 自定义拼音库（拼音引擎）\n\nPinyin4jEngine engine = new Pinyin4jEngine();\n\n// "ni hao h"\nString pinyin = engine.getPinyin("你好h", " ");\n',normalizedContent:'# 介绍\n\n拼音工具类在旧版本的hutool中在core包中，但是发现自己实现相关功能需要庞大的字典，放在core包中便是累赘。\n\n于是为了方便，hutool封装了拼音的门面，用于兼容以下拼音库:\n\n 1. tinypinyin\n 2. jpinyin\n 3. pinyin4j\n\n和其它门面模块类似，采用spi方式识别所用的库。例如你想用pinyin4j，只需引入jar，hutool即可自动识别。\n\n\n# 使用\n\n\n# 引入库\n\n以下为hutool支持的拼音库的pom坐标，你可以选择任意一个引入项目中，如果引入多个，hutool会按照以上顺序选择第一个使用。\n\n<dependency>\n\t<groupid>io.github.biezhi</groupid>\n\t<artifactid>tinypinyin</artifactid>\n\t<version>2.0.3.release</version>\n</dependency>\n\n\n<dependency>\n\t<groupid>com.belerweb</groupid>\n\t<artifactid>pinyin4j</artifactid>\n\t<version>2.5.1</version>\n</dependency>\n\n\n<dependency>\n\t<groupid>com.github.stuxuhai</groupid>\n\t<artifactid>jpinyin</artifactid>\n\t<version>1.1.8</version>\n</dependency>\n\n\n\n# 使用\n\n 1. 获取拼音\n\n// "ni hao"\nstring pinyin = pinyinutil.getpinyin("你好", " ");\n\n\n这里定义的分隔符为空格，你也可以按照需求自定义分隔符，亦或者使用""代表无分隔符。\n\n 2. 获取拼音首字母\n\n// "h, s, d, y, g"\nstring result = pinyinutil.getfirstletter("h是第一个", ", ");\n\n\n 3. 自定义拼音库（拼音引擎）\n\npinyin4jengine engine = new pinyin4jengine();\n\n// "ni hao h"\nstring pinyin = engine.getpinyin("你好h", " ");\n',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"表达式引擎封装-ExpressionUtil",frontmatter:{title:"表达式引擎封装-ExpressionUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ExpressionUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/13.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E/01.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E%E5%B0%81%E8%A3%85-ExpressionUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/13.表达式引擎/01.表达式引擎封装-ExpressionUtil.md",key:"v-7ef938c3",path:"/pages/ExpressionUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:164},{level:3,title:"执行表达式",slug:"执行表达式",normalizedTitle:"执行表达式",charIndex:357},{level:3,title:"自定义引擎执行",slug:"自定义引擎执行",normalizedTitle:"自定义引擎执行",charIndex:528},{level:3,title:"创建自定义引擎",slug:"创建自定义引擎",normalizedTitle:"创建自定义引擎",charIndex:768}],headersStr:"介绍 使用 执行表达式 自定义引擎执行 创建自定义引擎",content:'# 介绍\n\n与模板引擎类似，Hutool针对较为流行的表达式计算引擎封装为门面模式，提供统一的API，去除差异。 现有的引擎实现有：\n\n * Aviator\n * Apache Jexl3\n * MVEL\n * JfireEL\n * Rhino\n * Spring Expression Language (SpEL)\n\n\n# 使用\n\n首先引入我们需要的模板引擎，引入后，Hutool借助SPI机制可自动识别使用，我们以Aviator为例：\n\n<dependency>\n\t<groupId>com.googlecode.aviator</groupId>\n\t<artifactId>aviator</artifactId>\n\t<version>5.3.3</version>\n</dependency>\n\n\n\n# 执行表达式\n\nfinal Dict dict = Dict.create()\n\t\t.set("a", 100.3)\n\t\t.set("b", 45)\n\t\t.set("c", -199.100);\n\n// -143.8\nfinal Object eval = ExpressionUtil.eval("a-(b-c)", dict);\n\n\n\n# 自定义引擎执行\n\n如果项目中引入多个引擎，我们想选择某个引擎执行，则可以：\n\nExpressionEngine engine = new JexlEngine();\n\nfinal Dict dict = Dict.create()\n\t\t.set("a", 100.3)\n\t\t.set("b", 45)\n\t\t.set("c", -199.100);\n\n// -143.8\nfinal Object eval = engine.eval("a-(b-c)", dict);\n\n\n\n# 创建自定义引擎\n\n引擎的核心就是实现ExpressionEngine接口，此接口只有一个方法：eval。\n\n我们实现此接口后，在项目的META-INF/services/下创建spi文件cn.hutool.extra.expression.ExpressionEngine：\n\ncom.yourProject.XXXXEngine\n\n\n这样就可以直接调用ExpressionUtil.eval执行表达式了。',normalizedContent:'# 介绍\n\n与模板引擎类似，hutool针对较为流行的表达式计算引擎封装为门面模式，提供统一的api，去除差异。 现有的引擎实现有：\n\n * aviator\n * apache jexl3\n * mvel\n * jfireel\n * rhino\n * spring expression language (spel)\n\n\n# 使用\n\n首先引入我们需要的模板引擎，引入后，hutool借助spi机制可自动识别使用，我们以aviator为例：\n\n<dependency>\n\t<groupid>com.googlecode.aviator</groupid>\n\t<artifactid>aviator</artifactid>\n\t<version>5.3.3</version>\n</dependency>\n\n\n\n# 执行表达式\n\nfinal dict dict = dict.create()\n\t\t.set("a", 100.3)\n\t\t.set("b", 45)\n\t\t.set("c", -199.100);\n\n// -143.8\nfinal object eval = expressionutil.eval("a-(b-c)", dict);\n\n\n\n# 自定义引擎执行\n\n如果项目中引入多个引擎，我们想选择某个引擎执行，则可以：\n\nexpressionengine engine = new jexlengine();\n\nfinal dict dict = dict.create()\n\t\t.set("a", 100.3)\n\t\t.set("b", 45)\n\t\t.set("c", -199.100);\n\n// -143.8\nfinal object eval = engine.eval("a-(b-c)", dict);\n\n\n\n# 创建自定义引擎\n\n引擎的核心就是实现expressionengine接口，此接口只有一个方法：eval。\n\n我们实现此接口后，在项目的meta-inf/services/下创建spi文件cn.hutool.extra.expression.expressionengine：\n\ncom.yourproject.xxxxengine\n\n\n这样就可以直接调用expressionutil.eval执行表达式了。',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/bloomFilter/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/13.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%EF%BC%88Hutool-bloomFilter%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/13.布隆过滤（Hutool-bloomFilter）/01.概述.md",key:"v-ea1b2768",path:"/pages/bloomFilter/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:334}],headersStr:"介绍 使用",content:'# 介绍\n\n布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。\n\n布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。\n\n参考：https://www.cnblogs.com/z941030/p/9218356.html\n\n\n# 使用\n\n// 初始化\nBitMapBloomFilter filter = new BitMapBloomFilter(10);\nfilter.add("123");\nfilter.add("abc");\nfilter.add("ddd");\n\n// 查找\nfilter.contains("abc")\n',normalizedContent:'# 介绍\n\n布隆过滤器（英语：bloom filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。\n\n布隆过滤器的原理是，当一个元素被加入集合时，通过k个散列函数将这个元素映射成一个位数组中的k个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。\n\n参考：https://www.cnblogs.com/z941030/p/9218356.html\n\n\n# 使用\n\n// 初始化\nbitmapbloomfilter filter = new bitmapbloomfilter(10);\nfilter.add("123");\nfilter.add("abc");\nfilter.add("ddd");\n\n// 查找\nfilter.contains("abc")\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"模板引擎封装-TemplateUtil",frontmatter:{title:"模板引擎封装-TemplateUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/TemplateUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/14.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/01.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%B0%81%E8%A3%85-TemplateUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/14.模板引擎/01.模板引擎封装-TemplateUtil.md",key:"v-b429df4a",path:"/pages/TemplateUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:227},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:83},{level:3,title:"从字符串模板渲染内容",slug:"从字符串模板渲染内容",normalizedTitle:"从字符串模板渲染内容",charIndex:436},{level:3,title:"从classpath查找模板渲染",slug:"从classpath查找模板渲染",normalizedTitle:"从classpath查找模板渲染",charIndex:851},{level:3,title:"其它方式查找模板",slug:"其它方式查找模板",normalizedTitle:"其它方式查找模板",charIndex:1159}],headersStr:"介绍 原理 使用 从字符串模板渲染内容 从classpath查找模板渲染 其它方式查找模板",content:'# 介绍\n\n随着前后端分离的流行，JSP技术和模板引擎慢慢变得不再那么重要，但是在某些场景中（例如邮件模板、页面静态化等）依旧无可替代，但是各种模板引擎语法大相径庭，使用方式也不尽相同，学习成本很高。Hutool旨在封装各个引擎的共性，使用户只关注模板语法即可，减少学习成本。\n\nHutool现在封装的引擎有：\n\n * Beetl\n * Enjoy\n * Rythm\n * FreeMarker\n * Velocity\n * Thymeleaf\n\n\n# 原理\n\n类似于Java日志门面的思想，Hutool将模板引擎的渲染抽象为两个概念：\n\n * TemplateEngine 模板引擎，用于封装模板对象，配置各种配置\n * Template 模板对象，用于配合参数渲染产生内容\n\n通过实现这两个接口，用户便可抛开模板实现，从而渲染模板。Hutool同时会通过TemplateFactory根据用户引入的模板引擎库的jar来自动选择用哪个引擎来渲染。\n\n\n# 使用\n\n\n# 从字符串模板渲染内容\n\n//自动根据用户引入的模板引擎库的jar来自动选择使用的引擎\n//TemplateConfig为模板引擎的选项，可选内容有字符编码、模板路径、模板加载方式等，默认通过模板字符串渲染\nTemplateEngine engine = TemplateUtil.createEngine(new TemplateConfig());\n\n//假设我们引入的是Beetl引擎，则：\nTemplate template = engine.getTemplate("Hello ${name}");\n//Dict本质上为Map，此处可用Map\nString result = template.render(Dict.create().set("name", "Hutool"));\n//输出：Hello Hutool\n\n\n也就是说，使用Hutool之后，无论你用任何一种模板引擎，代码不变（只变更模板内容）。\n\n\n# 从classpath查找模板渲染\n\n只需修改TemplateConfig配置文件内容即可更换（这里以Velocity为例）：\n\nTemplateEngine engine = TemplateUtil.createEngine(new TemplateConfig("templates", ResourceMode.CLASSPATH));\nTemplate template = engine.getTemplate("https://doc.hutool.cn/assets/js/velocity_test.vtl");\nString result = template.render(Dict.create().set("name", "Hutool"));\n\n\n\n# 其它方式查找模板\n\n查找模板的方式由ResourceMode定义，包括：\n\n * CLASSPATH 从ClassPath加载模板\n * FILE 从File本地目录加载模板\n * WEB_ROOT 从WebRoot目录加载模板\n * STRING 从模板文本加载模板\n * COMPOSITE 复合加载模板（分别从File、ClassPath、Web-root、String方式尝试查找模板）',normalizedContent:'# 介绍\n\n随着前后端分离的流行，jsp技术和模板引擎慢慢变得不再那么重要，但是在某些场景中（例如邮件模板、页面静态化等）依旧无可替代，但是各种模板引擎语法大相径庭，使用方式也不尽相同，学习成本很高。hutool旨在封装各个引擎的共性，使用户只关注模板语法即可，减少学习成本。\n\nhutool现在封装的引擎有：\n\n * beetl\n * enjoy\n * rythm\n * freemarker\n * velocity\n * thymeleaf\n\n\n# 原理\n\n类似于java日志门面的思想，hutool将模板引擎的渲染抽象为两个概念：\n\n * templateengine 模板引擎，用于封装模板对象，配置各种配置\n * template 模板对象，用于配合参数渲染产生内容\n\n通过实现这两个接口，用户便可抛开模板实现，从而渲染模板。hutool同时会通过templatefactory根据用户引入的模板引擎库的jar来自动选择用哪个引擎来渲染。\n\n\n# 使用\n\n\n# 从字符串模板渲染内容\n\n//自动根据用户引入的模板引擎库的jar来自动选择使用的引擎\n//templateconfig为模板引擎的选项，可选内容有字符编码、模板路径、模板加载方式等，默认通过模板字符串渲染\ntemplateengine engine = templateutil.createengine(new templateconfig());\n\n//假设我们引入的是beetl引擎，则：\ntemplate template = engine.gettemplate("hello ${name}");\n//dict本质上为map，此处可用map\nstring result = template.render(dict.create().set("name", "hutool"));\n//输出：hello hutool\n\n\n也就是说，使用hutool之后，无论你用任何一种模板引擎，代码不变（只变更模板内容）。\n\n\n# 从classpath查找模板渲染\n\n只需修改templateconfig配置文件内容即可更换（这里以velocity为例）：\n\ntemplateengine engine = templateutil.createengine(new templateconfig("templates", resourcemode.classpath));\ntemplate template = engine.gettemplate("https://doc.hutool.cn/assets/js/velocity_test.vtl");\nstring result = template.render(dict.create().set("name", "hutool"));\n\n\n\n# 其它方式查找模板\n\n查找模板的方式由resourcemode定义，包括：\n\n * classpath 从classpath加载模板\n * file 从file本地目录加载模板\n * web_root 从webroot目录加载模板\n * string 从模板文本加载模板\n * composite 复合加载模板（分别从file、classpath、web-root、string方式尝试查找模板）',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/aop/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/14.%E5%88%87%E9%9D%A2%EF%BC%88Hutool-aop%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/14.切面（Hutool-aop）/01.概述.md",key:"v-7af52ea7",path:"/pages/aop/",headers:[{level:2,title:"Hutool-aop概述",slug:"hutool-aop概述",normalizedTitle:"hutool-aop概述",charIndex:2}],headersStr:"Hutool-aop概述",content:"# Hutool-aop概述\n\nAOP模块主要针对JDK中动态代理进行封装，抽象动态代理为切面类Aspect，通过ProxyUtil代理工具类将切面对象与被代理对象融合，产生一个代理对象，从而可以针对每个方法执行前后做通用的功能。\n\n在aop模块中，默认实现以下两个切面对象：\n\n 1. SimpleAspect 简单切面对象，不做任何操作，继承此对象重写需要的方法即可，不必实现所有方法\n 2. TimeIntervalAspect 执行时间切面对象，用于简单计算方法执行时间，然后通过日志打印方法执行时间\n\n> 由于AOP模块封装JDK的代理，故被代理对象必须实现接口。",normalizedContent:"# hutool-aop概述\n\naop模块主要针对jdk中动态代理进行封装，抽象动态代理为切面类aspect，通过proxyutil代理工具类将切面对象与被代理对象融合，产生一个代理对象，从而可以针对每个方法执行前后做通用的功能。\n\n在aop模块中，默认实现以下两个切面对象：\n\n 1. simpleaspect 简单切面对象，不做任何操作，继承此对象重写需要的方法即可，不必实现所有方法\n 2. timeintervalaspect 执行时间切面对象，用于简单计算方法执行时间，然后通过日志打印方法执行时间\n\n> 由于aop模块封装jdk的代理，故被代理对象必须实现接口。",charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"切面代理工具-ProxyUtil",frontmatter:{title:"切面代理工具-ProxyUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ProxyUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/14.%E5%88%87%E9%9D%A2%EF%BC%88Hutool-aop%EF%BC%89/02.%E5%88%87%E9%9D%A2%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7-ProxyUtil.html",relativePath:"01.指南/14.切面（Hutool-aop）/02.切面代理工具-ProxyUtil.md",key:"v-9e8c3118",path:"/pages/ProxyUtil/",headers:[{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:2},{level:3,title:"使用JDK的动态代理实现切面",slug:"使用jdk的动态代理实现切面",normalizedTitle:"使用jdk的动态代理实现切面",charIndex:9},{level:3,title:"使用Cglib实现切面",slug:"使用cglib实现切面",normalizedTitle:"使用cglib实现切面",charIndex:1053},{level:2,title:"其它方法",slug:"其它方法",normalizedTitle:"其它方法",charIndex:1516},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:1622}],headersStr:"使用 使用JDK的动态代理实现切面 使用Cglib实现切面 其它方法 原理",content:'# 使用\n\n\n# 使用JDK的动态代理实现切面\n\n 1. 我们定义一个接口：\n\npublic interface Animal{\n\tvoid eat();\n}\n\n\n 2. 定义一个实现类：\n\npublic class Cat implements Animal{\n\n\t@Override\n\tpublic void eat() {\n\t\tConsole.log("猫吃鱼");\n\t}\n\t\n}\n\n\n 3. 我们使用TimeIntervalAspect这个切面代理上述对象，来统计猫吃鱼的执行时间：\n\nAnimal cat = ProxyUtil.proxy(new Cat(), TimeIntervalAspect.class);\ncat.eat();\n\n\nTimeIntervalAspect位于cn.hutool.aop.aspects包，继承自SimpleAspect，代码如下：\n\npublic class TimeIntervalAspect extends SimpleAspect{\n\t//TimeInterval为Hutool实现的一个计时器\n\tprivate TimeInterval interval = new TimeInterval();\n\n\t@Override\n\tpublic boolean before(Object target, Method method, Object[] args) {\n\t\tinterval.start();\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic boolean after(Object target, Method method, Object[] args) {\n\t\tConsole.log("Method [{}.{}] execute spend [{}]ms", target.getClass().getName(), method.getName(), interval.intervalMs());\n\t\treturn true;\n\t}\n}\n\n\n执行结果为：\n\n猫吃鱼\nMethod [cn.hutool.aop.test.AopTest$Cat.eat] execute spend [16]ms\n\n\n> 在调用proxy方法后，IDE自动补全返回对象为Cat，因为JDK机制的原因，我们的返回值必须是被代理类实现的接口，因此需要手动将返回值改为Animal，否则会报类型转换失败。\n\n\n# 使用Cglib实现切面\n\n使用Cglib的好处是无需定义接口即可对对象直接实现切面，使用方式完全一致：\n\n 1. 引入Cglib依赖\n\n<dependency>\n\t<groupId>cglib</groupId>\n\t<artifactId>cglib</artifactId>\n\t<version>${cglib.version}</version>\n</dependency>\n\n\n 2. 定义一个无接口类（此类有无接口都可以）\n\npublic class Dog {\n\tpublic String eat() {\n\t\tConsole.log("狗吃肉");\n\t}\n}\n\n\nDog dog = ProxyUtil.proxy(new Dog(), TimeIntervalAspect.class);\nString result = dog.eat();\n\n\n执行结果为：\n\n狗吃肉\nMethod [cn.hutool.aop.test.AopTest$Dog.eat] execute spend [13]ms\n\n\n\n# 其它方法\n\nProxyUtil中还提供了一些便捷的Proxy方法封装，例如newProxyInstance封装了Proxy.newProxyInstance方法，提供泛型返回值，并提供更多参数类型支持。\n\n\n# 原理\n\n动态代理对象的创建原理是假设创建的代理对象名为$Proxy0：\n\n 1. 根据传入的interfaces动态生成一个类，实现interfaces中的接口\n 2. 通过传入的classloder将刚生成的类加载到jvm中。即load$Proxy0类\n 3. 调用$Proxy0的$Proxy0(InvocationHandler)构造函数 创建$Proxy0的对象，并且用interfaces参数遍历其所有接口的方法，并生成实现方法，这些实现方法的实现本质上是通过反射调用被代理对象的方法。\n 4. 将$Proxy0的实例返回给客户端。\n 5. 当调用代理类的相应方法时，相当于调用InvocationHandler.invoke(Object, Method, Object [])方法。',normalizedContent:'# 使用\n\n\n# 使用jdk的动态代理实现切面\n\n 1. 我们定义一个接口：\n\npublic interface animal{\n\tvoid eat();\n}\n\n\n 2. 定义一个实现类：\n\npublic class cat implements animal{\n\n\t@override\n\tpublic void eat() {\n\t\tconsole.log("猫吃鱼");\n\t}\n\t\n}\n\n\n 3. 我们使用timeintervalaspect这个切面代理上述对象，来统计猫吃鱼的执行时间：\n\nanimal cat = proxyutil.proxy(new cat(), timeintervalaspect.class);\ncat.eat();\n\n\ntimeintervalaspect位于cn.hutool.aop.aspects包，继承自simpleaspect，代码如下：\n\npublic class timeintervalaspect extends simpleaspect{\n\t//timeinterval为hutool实现的一个计时器\n\tprivate timeinterval interval = new timeinterval();\n\n\t@override\n\tpublic boolean before(object target, method method, object[] args) {\n\t\tinterval.start();\n\t\treturn true;\n\t}\n\t\n\t@override\n\tpublic boolean after(object target, method method, object[] args) {\n\t\tconsole.log("method [{}.{}] execute spend [{}]ms", target.getclass().getname(), method.getname(), interval.intervalms());\n\t\treturn true;\n\t}\n}\n\n\n执行结果为：\n\n猫吃鱼\nmethod [cn.hutool.aop.test.aoptest$cat.eat] execute spend [16]ms\n\n\n> 在调用proxy方法后，ide自动补全返回对象为cat，因为jdk机制的原因，我们的返回值必须是被代理类实现的接口，因此需要手动将返回值改为animal，否则会报类型转换失败。\n\n\n# 使用cglib实现切面\n\n使用cglib的好处是无需定义接口即可对对象直接实现切面，使用方式完全一致：\n\n 1. 引入cglib依赖\n\n<dependency>\n\t<groupid>cglib</groupid>\n\t<artifactid>cglib</artifactid>\n\t<version>${cglib.version}</version>\n</dependency>\n\n\n 2. 定义一个无接口类（此类有无接口都可以）\n\npublic class dog {\n\tpublic string eat() {\n\t\tconsole.log("狗吃肉");\n\t}\n}\n\n\ndog dog = proxyutil.proxy(new dog(), timeintervalaspect.class);\nstring result = dog.eat();\n\n\n执行结果为：\n\n狗吃肉\nmethod [cn.hutool.aop.test.aoptest$dog.eat] execute spend [13]ms\n\n\n\n# 其它方法\n\nproxyutil中还提供了一些便捷的proxy方法封装，例如newproxyinstance封装了proxy.newproxyinstance方法，提供泛型返回值，并提供更多参数类型支持。\n\n\n# 原理\n\n动态代理对象的创建原理是假设创建的代理对象名为$proxy0：\n\n 1. 根据传入的interfaces动态生成一个类，实现interfaces中的接口\n 2. 通过传入的classloder将刚生成的类加载到jvm中。即load$proxy0类\n 3. 调用$proxy0的$proxy0(invocationhandler)构造函数 创建$proxy0的对象，并且用interfaces参数遍历其所有接口的方法，并生成实现方法，这些实现方法的实现本质上是通过反射调用被代理对象的方法。\n 4. 将$proxy0的实例返回给客户端。\n 5. 当调用代理类的相应方法时，相当于调用invocationhandler.invoke(object, method, object [])方法。',charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"Script工具-ScriptUtil",frontmatter:{title:"Script工具-ScriptUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ScriptUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/15.%E8%84%9A%E6%9C%AC%EF%BC%88Hutool-script%EF%BC%89/02.Script%E5%B7%A5%E5%85%B7-ScriptUtil.html",relativePath:"01.指南/15.脚本（Hutool-script）/02.Script工具-ScriptUtil.md",key:"v-239deada",path:"/pages/ScriptUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:26},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:51}],headersStr:"介绍 使用",content:"# Script工具-ScriptUtil\n\n\n# 介绍\n\n针对Script执行的工具化封装\n\n\n# 使用\n\n 1. ScriptUtil.eval 执行Javascript脚本，参数为脚本字符串。\n\n栗子：\n\nScriptUtil.eval(\"print('Script test!');\");\n\n\n 2. ScriptUtil.compile 编译脚本，返回一个CompiledScript对象\n\n栗子：\n\nCompiledScript script = ScriptUtil.compile(\"print('Script test!');\");\ntry {\n\tscript.eval();\n} catch (ScriptException e) {\n\tthrow new ScriptRuntimeException(e);\n}\n",normalizedContent:"# script工具-scriptutil\n\n\n# 介绍\n\n针对script执行的工具化封装\n\n\n# 使用\n\n 1. scriptutil.eval 执行javascript脚本，参数为脚本字符串。\n\n栗子：\n\nscriptutil.eval(\"print('script test!');\");\n\n\n 2. scriptutil.compile 编译脚本，返回一个compiledscript对象\n\n栗子：\n\ncompiledscript script = scriptutil.compile(\"print('script test!');\");\ntry {\n\tscript.eval();\n} catch (scriptexception e) {\n\tthrow new scriptruntimeexception(e);\n}\n",charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/script/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/15.%E8%84%9A%E6%9C%AC%EF%BC%88Hutool-script%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/15.脚本（Hutool-script）/01.概述.md",key:"v-5e64f3d6",path:"/pages/script/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:9}],headersStr:"介绍",content:"# 概述\n\n\n# 介绍\n\nscript模块主要针对Java的javax.script的封装，可以运行Javascript脚本。\n\n此模块非常简单。主要功能集中在ScriptUtil这个工具类中。",normalizedContent:"# 概述\n\n\n# 介绍\n\nscript模块主要针对java的javax.script的封装，可以运行javascript脚本。\n\n此模块非常简单。主要功能集中在scriptutil这个工具类中。",charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"Excel生成-ExcelWriter",frontmatter:{title:"Excel生成-ExcelWriter",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ExcelWriter/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/16.Office%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C%EF%BC%88Hutool-poi%EF%BC%89/03.Excel%E7%94%9F%E6%88%90-ExcelWriter.html",relativePath:"01.指南/16.Office文档操作（Hutool-poi）/03.Excel生成-ExcelWriter.md",key:"v-ff92bc58",path:"/pages/ExcelWriter/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:49},{level:2,title:"使用例子",slug:"使用例子",normalizedTitle:"使用例子",charIndex:277},{level:3,title:"1. 将行列对象写出到Excel",slug:"_1-将行列对象写出到excel",normalizedTitle:"1. 将行列对象写出到excel",charIndex:286},{level:3,title:"2. 写出Map数据",slug:"_2-写出map数据",normalizedTitle:"2. 写出map数据",charIndex:1192},{level:3,title:"3. 写出Bean数据",slug:"_3-写出bean数据",normalizedTitle:"3. 写出bean数据",charIndex:1886},{level:3,title:"4. 自定义Bean的key别名（排序标题）",slug:"_4-自定义bean的key别名-排序标题",normalizedTitle:"4. 自定义bean的key别名（排序标题）",charIndex:3212},{level:3,title:"5. 写出到流",slug:"_5-写出到流",normalizedTitle:"5. 写出到流",charIndex:4117},{level:3,title:"6. 写出到客户端下载（写出到Servlet）",slug:"_6-写出到客户端下载-写出到servlet",normalizedTitle:"6. 写出到客户端下载（写出到servlet）",charIndex:4396},{level:2,title:"自定义Excel",slug:"自定义excel",normalizedTitle:"自定义excel",charIndex:5859},{level:3,title:"1. 设置单元格背景色",slug:"_1-设置单元格背景色",normalizedTitle:"1. 设置单元格背景色",charIndex:5872},{level:3,title:"2. 自定义字体",slug:"_2-自定义字体",normalizedTitle:"2. 自定义字体",charIndex:6043},{level:3,title:"3. 写出多个sheet",slug:"_3-写出多个sheet",normalizedTitle:"3. 写出多个sheet",charIndex:6261},{level:3,title:"4. 更详细的定义样式",slug:"_4-更详细的定义样式",normalizedTitle:"4. 更详细的定义样式",charIndex:6423},{level:3,title:"5. 自定义写出的值",slug:"_5-自定义写出的值",normalizedTitle:"5. 自定义写出的值",charIndex:6813}],headersStr:"由来 原理 使用例子 1. 将行列对象写出到Excel 2. 写出Map数据 3. 写出Bean数据 4. 自定义Bean的key别名（排序标题） 5. 写出到流 6. 写出到客户端下载（写出到Servlet） 自定义Excel 1. 设置单元格背景色 2. 自定义字体 3. 写出多个sheet 4. 更详细的定义样式 5. 自定义写出的值",content:'# 由来\n\nExcel有读取也便有写出，Hutool针对将数据写出到Excel做了封装。\n\n\n# 原理\n\nHutool将Excel写出封装为ExcelWriter，原理为包装了Workbook对象，每次调用merge（合并单元格）或者write（写出数据）方法后只是将数据写入到Workbook，并不写出文件，只有调用flush或者close方法后才会真正写出文件。\n\n由于机制原因，在写出结束后需要关闭ExcelWriter对象，调用close方法即可关闭，此时才会释放Workbook对象资源，否则带有数据的Workbook一直会常驻内存。\n\n\n# 使用例子\n\n\n# 1. 将行列对象写出到Excel\n\n我们先定义一个嵌套的List，List的元素也是一个List，内层的一个List代表一行数据，每行都有4个单元格，最终list对象代表多行数据。\n\nList<String> row1 = CollUtil.newArrayList("aa", "bb", "cc", "dd");\nList<String> row2 = CollUtil.newArrayList("aa1", "bb1", "cc1", "dd1");\nList<String> row3 = CollUtil.newArrayList("aa2", "bb2", "cc2", "dd2");\nList<String> row4 = CollUtil.newArrayList("aa3", "bb3", "cc3", "dd3");\nList<String> row5 = CollUtil.newArrayList("aa4", "bb4", "cc4", "dd4");\n\nList<List<String>> rows = CollUtil.newArrayList(row1, row2, row3, row4, row5);\n\n\n然后我们创建ExcelWriter对象后写出数据：\n\n//通过工具类创建writer\nExcelWriter writer = ExcelUtil.getWriter("d:/writeTest.xlsx");\n//通过构造方法创建writer\n//ExcelWriter writer = new ExcelWriter("d:/writeTest.xls");\n\n//跳过当前行，既第一行，非必须，在此演示用\nwriter.passCurrentRow();\n\n//合并单元格后的标题行，使用默认标题样式\nwriter.merge(row1.size() - 1, "测试标题");\n//一次性写出内容，强制输出标题\nwriter.write(rows, true);\n//关闭writer，释放内存\nwriter.close();\n\n\n效果：\n\n\n\n\n# 2. 写出Map数据\n\n构造数据：\n\nMap<String, Object> row1 = new LinkedHashMap<>();\nrow1.put("姓名", "张三");\nrow1.put("年龄", 23);\nrow1.put("成绩", 88.32);\nrow1.put("是否合格", true);\nrow1.put("考试日期", DateUtil.date());\n\nMap<String, Object> row2 = new LinkedHashMap<>();\nrow2.put("姓名", "李四");\nrow2.put("年龄", 33);\nrow2.put("成绩", 59.50);\nrow2.put("是否合格", false);\nrow2.put("考试日期", DateUtil.date());\n\nArrayList<Map<String, Object>> rows = CollUtil.newArrayList(row1, row2);\n\n\n写出数据：\n\n// 通过工具类创建writer\nExcelWriter writer = ExcelUtil.getWriter("d:/writeMapTest.xlsx");\n// 合并单元格后的标题行，使用默认标题样式\nwriter.merge(row1.size() - 1, "一班成绩单");\n// 一次性写出内容，使用默认样式，强制输出标题\nwriter.write(rows, true);\n// 关闭writer，释放内存\nwriter.close();\n\n\n效果：\n\n\n\n\n# 3. 写出Bean数据\n\n定义Bean:\n\npublic class TestBean {\n\tprivate String name;\n\tprivate int age;\n\tprivate double score;\n\tprivate boolean isPass;\n\tprivate Date examDate;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic double getScore() {\n\t\treturn score;\n\t}\n\n\tpublic void setScore(double score) {\n\t\tthis.score = score;\n\t}\n\n\tpublic boolean isPass() {\n\t\treturn isPass;\n\t}\n\n\tpublic void setPass(boolean isPass) {\n\t\tthis.isPass = isPass;\n\t}\n\n\tpublic Date getExamDate() {\n\t\treturn examDate;\n\t}\n\n\tpublic void setExamDate(Date examDate) {\n\t\tthis.examDate = examDate;\n\t}\n}\n\n\n构造数据：\n\nTestBean bean1 = new TestBean();\nbean1.setName("张三");\nbean1.setAge(22);\nbean1.setPass(true);\nbean1.setScore(66.30);\nbean1.setExamDate(DateUtil.date());\n\nTestBean bean2 = new TestBean();\nbean2.setName("李四");\nbean2.setAge(28);\nbean2.setPass(false);\nbean2.setScore(38.50);\nbean2.setExamDate(DateUtil.date());\n\nList<TestBean> rows = CollUtil.newArrayList(bean1, bean2);\n\n\n写出数据：\n\n// 通过工具类创建writer\nExcelWriter writer = ExcelUtil.getWriter("d:/writeBeanTest.xlsx");\n// 合并单元格后的标题行，使用默认标题样式\nwriter.merge(4, "一班成绩单");\n// 一次性写出内容，使用默认样式，强制输出标题\nwriter.write(rows, true);\n// 关闭writer，释放内存\nwriter.close();\n\n\n效果：\n\n\n\n\n# 4. 自定义Bean的key别名（排序标题）\n\n在写出Bean的时候，我们可以调用ExcelWriter对象的addHeaderAlias方法自定义Bean中key的别名，这样就可以写出自定义标题了（例如中文）。\n\n写出数据：\n\n// 通过工具类创建writer\nExcelWriter writer = ExcelUtil.getWriter("d:/writeBeanTest.xlsx");\n\n//自定义标题别名\nwriter.addHeaderAlias("name", "姓名");\nwriter.addHeaderAlias("age", "年龄");\nwriter.addHeaderAlias("score", "分数");\nwriter.addHeaderAlias("isPass", "是否通过");\nwriter.addHeaderAlias("examDate", "考试时间");\n\n// 默认的，未添加alias的属性也会写出，如果想只写出加了别名的字段，可以调用此方法排除之\nwriter.setOnlyAlias(true);\n\n// 合并单元格后的标题行，使用默认标题样式\nwriter.merge(4, "一班成绩单");\n// 一次性写出内容，使用默认样式，强制输出标题\nwriter.write(rows, true);\n// 关闭writer，释放内存\nwriter.close();\n\n\n同时支持别名注解的。可以在字段上加@Alias注解。\n\n@Alias(value = "姓名")\nprivate String name;\n\n\n效果：\n\n\n\n> 提示（since 4.1.5）\n> 默认情况下Excel中写出Bean字段不能保证顺序，此时可以使用addHeaderAlias方法设置标题别名，Bean的写出顺序就会按照标题别名的加入顺序排序。\n> 如果不需要设置标题但是想要排序字段，请调用writer.addHeaderAlias("age", "age")设置一个相同的别名就可以不更换标题。\n> 未设置标题别名的字段不参与排序，会默认排在前面。\n\n\n# 5. 写出到流\n\n// 通过工具类创建writer，默认创建xls格式\nExcelWriter writer = ExcelUtil.getWriter();\n//创建xlsx格式的\n//ExcelWriter writer = ExcelUtil.getWriter(true);\n// 一次性写出内容，使用默认样式，强制输出标题\nwriter.write(rows, true);\n//out为OutputStream，需要写出到的目标流\nwriter.flush(out);\n// 关闭writer，释放内存\nwriter.close();\n\n\n\n# 6. 写出到客户端下载（写出到Servlet）\n\n 1. 写出xls\n\n// 通过工具类创建writer，默认创建xls格式\nExcelWriter writer = ExcelUtil.getWriter();\n// 一次性写出内容，使用默认样式，强制输出标题\nwriter.write(rows, true);\n//out为OutputStream，需要写出到的目标流\n\n//response为HttpServletResponse对象\nresponse.setContentType("application/vnd.ms-excel;charset=utf-8"); \n//test.xls是弹出下载对话框的文件名，不能为中文，中文请自行编码\nresponse.setHeader("Content-Disposition","https://doc.hutool.cn/assets/js/attachment;filename=test.xls"); \nServletOutputStream out=response.getOutputStream(); \n\nwriter.flush(out, true);\n// 关闭writer，释放内存\nwriter.close();\n//此处记得关闭输出Servlet流\nIoUtil.close(out);\n\n\n 2. 写出xlsx\n\nExcelWriter writer = ExcelUtil.getWriter(true);\nwriter.write(rows, true);\n\nresponse.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8"); \nresponse.setHeader("Content-Disposition","https://doc.hutool.cn/assets/js/attachment;filename=test.xlsx"); \nServletOutputStream out=response.getOutputStream(); \n\nwriter.flush(out, true);\nwriter.close();\nIoUtil.close(out);\n\n\n> 注意\n> ExcelUtil.getWriter()默认创建xls格式的Excel，因此写出到客户端也需要自定义文件名为XXX.xls，否则会出现文件损坏的提示。\n> 若想生成xlsx格式，请使用ExcelUtil.getWriter(true)创建。\n\n 3. 下载提示文件损坏问题解决\n\n有用户反馈按照代码生成的Excel下载后提示文件损坏，无法打开，经过排查，可能是几个问题：\n\n * （1）writer和out流没有正确关闭，请在代码末尾的finally块增加关闭。\n * （2）扩展名不匹配。getWriter默认生成xls，Content-Disposition中也应该是xls，只有getWriter(true)时才可以使用xlsx\n * （3）Maven项目中Excel保存于ClassPath中（src/main/resources下）宏替换导致被破坏，解决办法是添加filtering（参考：springboot下载Excel模板，Excel表损坏问题\n * （4）Excel打开提示文件损坏，WPS可以打开。这是Excel的安全性控制导致的，解决办法见：springboot下载excel（解决文件损坏问题）\n\n\n# 自定义Excel\n\n\n# 1. 设置单元格背景色\n\nExcelWriter writer = ...;\n\n// 定义单元格背景色\nStyleSet style = writer.getStyleSet();\n// 第二个参数表示是否也设置头部单元格背景\nstyle.setBackgroundColor(IndexedColors.RED, false);\n\n\n\n# 2. 自定义字体\n\nExcelWriter writer = ...;\n//设置内容字体\nFont font = writer.createFont();\nfont.setBold(true);\nfont.setColor(Font.COLOR_RED); \nfont.setItalic(true); \n//第二个参数表示是否忽略头部样式\nwriter.getStyleSet().setFont(font, true);\n\n\n\n# 3. 写出多个sheet\n\n//初始化时定义表名\nExcelWriter writer = new ExcelWriter("d:/aaa.xls", "表1");\n//切换sheet，此时从第0行开始写\nwriter.setSheet("表2");\n...\nwriter.setSheet("表3");\n...\n\n\n\n# 4. 更详细的定义样式\n\n在Excel中，由于样式对象个数有限制，因此Hutool根据样式种类分为4个样式对象，使相同类型的单元格可以共享样式对象。样式按照类别存在于StyleSet中，其中包括：\n\n * headCellStyle 头部样式\n * cellStyle 普通单元格样式\n * cellStyleForNumber 数字单元格样式\n * cellStyleForDate 日期单元格样式\n\n其中cellStyleForNumber cellStyleForDate用于控制数字和日期的显示方式。\n\n因此我们可以使用以下方式获取CellStyle对象自定义指定种类的样式：\n\nStyleSet style = writer.getStyleSet();\nCellStyle cellStyle = style.getHeadCellStyle();\n...\n\n\n\n# 5. 自定义写出的值\n\n你可以实现CellSetter接口来自定义写出到单元格的值，此接口只有一个方法：setValue(Cell cell)，通过暴露Cell对象使得用户可以自定义输出单元格内容，甚至是样式。\n\n// 此处使用lambda自定义写出内容\nList<Object> row = ListUtil.of((CellSetter) cell -> cell.setCellValue("自定义内容"));\n\nExcelWriter writer = ExcelUtil.getWriter("https://doc.hutool.cn/test/test.xlsx");\nwriter.writeRow(row);\nwriter.close();\n\n\n> 注意\n> 某些特殊的字符串会导致Excel自动转义，如_xXXXX_这种格式的字符串会被当做unicode转义符，会被反转义。\n> 此时可以使用Hutool内置的EscapeStrCellSetter\n\nList<Object> row = ListUtil.of(new EscapeStrCellSetter("_x5116_"));\n\nExcelWriter writer = ExcelUtil.getWriter("https://doc.hutool.cn/test/test.xlsx");\nwriter.writeRow(row);\nwriter.close();\n\n\n此问题的详细说明见：单元格包含"_x”导致字符串转码',normalizedContent:'# 由来\n\nexcel有读取也便有写出，hutool针对将数据写出到excel做了封装。\n\n\n# 原理\n\nhutool将excel写出封装为excelwriter，原理为包装了workbook对象，每次调用merge（合并单元格）或者write（写出数据）方法后只是将数据写入到workbook，并不写出文件，只有调用flush或者close方法后才会真正写出文件。\n\n由于机制原因，在写出结束后需要关闭excelwriter对象，调用close方法即可关闭，此时才会释放workbook对象资源，否则带有数据的workbook一直会常驻内存。\n\n\n# 使用例子\n\n\n# 1. 将行列对象写出到excel\n\n我们先定义一个嵌套的list，list的元素也是一个list，内层的一个list代表一行数据，每行都有4个单元格，最终list对象代表多行数据。\n\nlist<string> row1 = collutil.newarraylist("aa", "bb", "cc", "dd");\nlist<string> row2 = collutil.newarraylist("aa1", "bb1", "cc1", "dd1");\nlist<string> row3 = collutil.newarraylist("aa2", "bb2", "cc2", "dd2");\nlist<string> row4 = collutil.newarraylist("aa3", "bb3", "cc3", "dd3");\nlist<string> row5 = collutil.newarraylist("aa4", "bb4", "cc4", "dd4");\n\nlist<list<string>> rows = collutil.newarraylist(row1, row2, row3, row4, row5);\n\n\n然后我们创建excelwriter对象后写出数据：\n\n//通过工具类创建writer\nexcelwriter writer = excelutil.getwriter("d:/writetest.xlsx");\n//通过构造方法创建writer\n//excelwriter writer = new excelwriter("d:/writetest.xls");\n\n//跳过当前行，既第一行，非必须，在此演示用\nwriter.passcurrentrow();\n\n//合并单元格后的标题行，使用默认标题样式\nwriter.merge(row1.size() - 1, "测试标题");\n//一次性写出内容，强制输出标题\nwriter.write(rows, true);\n//关闭writer，释放内存\nwriter.close();\n\n\n效果：\n\n\n\n\n# 2. 写出map数据\n\n构造数据：\n\nmap<string, object> row1 = new linkedhashmap<>();\nrow1.put("姓名", "张三");\nrow1.put("年龄", 23);\nrow1.put("成绩", 88.32);\nrow1.put("是否合格", true);\nrow1.put("考试日期", dateutil.date());\n\nmap<string, object> row2 = new linkedhashmap<>();\nrow2.put("姓名", "李四");\nrow2.put("年龄", 33);\nrow2.put("成绩", 59.50);\nrow2.put("是否合格", false);\nrow2.put("考试日期", dateutil.date());\n\narraylist<map<string, object>> rows = collutil.newarraylist(row1, row2);\n\n\n写出数据：\n\n// 通过工具类创建writer\nexcelwriter writer = excelutil.getwriter("d:/writemaptest.xlsx");\n// 合并单元格后的标题行，使用默认标题样式\nwriter.merge(row1.size() - 1, "一班成绩单");\n// 一次性写出内容，使用默认样式，强制输出标题\nwriter.write(rows, true);\n// 关闭writer，释放内存\nwriter.close();\n\n\n效果：\n\n\n\n\n# 3. 写出bean数据\n\n定义bean:\n\npublic class testbean {\n\tprivate string name;\n\tprivate int age;\n\tprivate double score;\n\tprivate boolean ispass;\n\tprivate date examdate;\n\n\tpublic string getname() {\n\t\treturn name;\n\t}\n\n\tpublic void setname(string name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getage() {\n\t\treturn age;\n\t}\n\n\tpublic void setage(int age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic double getscore() {\n\t\treturn score;\n\t}\n\n\tpublic void setscore(double score) {\n\t\tthis.score = score;\n\t}\n\n\tpublic boolean ispass() {\n\t\treturn ispass;\n\t}\n\n\tpublic void setpass(boolean ispass) {\n\t\tthis.ispass = ispass;\n\t}\n\n\tpublic date getexamdate() {\n\t\treturn examdate;\n\t}\n\n\tpublic void setexamdate(date examdate) {\n\t\tthis.examdate = examdate;\n\t}\n}\n\n\n构造数据：\n\ntestbean bean1 = new testbean();\nbean1.setname("张三");\nbean1.setage(22);\nbean1.setpass(true);\nbean1.setscore(66.30);\nbean1.setexamdate(dateutil.date());\n\ntestbean bean2 = new testbean();\nbean2.setname("李四");\nbean2.setage(28);\nbean2.setpass(false);\nbean2.setscore(38.50);\nbean2.setexamdate(dateutil.date());\n\nlist<testbean> rows = collutil.newarraylist(bean1, bean2);\n\n\n写出数据：\n\n// 通过工具类创建writer\nexcelwriter writer = excelutil.getwriter("d:/writebeantest.xlsx");\n// 合并单元格后的标题行，使用默认标题样式\nwriter.merge(4, "一班成绩单");\n// 一次性写出内容，使用默认样式，强制输出标题\nwriter.write(rows, true);\n// 关闭writer，释放内存\nwriter.close();\n\n\n效果：\n\n\n\n\n# 4. 自定义bean的key别名（排序标题）\n\n在写出bean的时候，我们可以调用excelwriter对象的addheaderalias方法自定义bean中key的别名，这样就可以写出自定义标题了（例如中文）。\n\n写出数据：\n\n// 通过工具类创建writer\nexcelwriter writer = excelutil.getwriter("d:/writebeantest.xlsx");\n\n//自定义标题别名\nwriter.addheaderalias("name", "姓名");\nwriter.addheaderalias("age", "年龄");\nwriter.addheaderalias("score", "分数");\nwriter.addheaderalias("ispass", "是否通过");\nwriter.addheaderalias("examdate", "考试时间");\n\n// 默认的，未添加alias的属性也会写出，如果想只写出加了别名的字段，可以调用此方法排除之\nwriter.setonlyalias(true);\n\n// 合并单元格后的标题行，使用默认标题样式\nwriter.merge(4, "一班成绩单");\n// 一次性写出内容，使用默认样式，强制输出标题\nwriter.write(rows, true);\n// 关闭writer，释放内存\nwriter.close();\n\n\n同时支持别名注解的。可以在字段上加@alias注解。\n\n@alias(value = "姓名")\nprivate string name;\n\n\n效果：\n\n\n\n> 提示（since 4.1.5）\n> 默认情况下excel中写出bean字段不能保证顺序，此时可以使用addheaderalias方法设置标题别名，bean的写出顺序就会按照标题别名的加入顺序排序。\n> 如果不需要设置标题但是想要排序字段，请调用writer.addheaderalias("age", "age")设置一个相同的别名就可以不更换标题。\n> 未设置标题别名的字段不参与排序，会默认排在前面。\n\n\n# 5. 写出到流\n\n// 通过工具类创建writer，默认创建xls格式\nexcelwriter writer = excelutil.getwriter();\n//创建xlsx格式的\n//excelwriter writer = excelutil.getwriter(true);\n// 一次性写出内容，使用默认样式，强制输出标题\nwriter.write(rows, true);\n//out为outputstream，需要写出到的目标流\nwriter.flush(out);\n// 关闭writer，释放内存\nwriter.close();\n\n\n\n# 6. 写出到客户端下载（写出到servlet）\n\n 1. 写出xls\n\n// 通过工具类创建writer，默认创建xls格式\nexcelwriter writer = excelutil.getwriter();\n// 一次性写出内容，使用默认样式，强制输出标题\nwriter.write(rows, true);\n//out为outputstream，需要写出到的目标流\n\n//response为httpservletresponse对象\nresponse.setcontenttype("application/vnd.ms-excel;charset=utf-8"); \n//test.xls是弹出下载对话框的文件名，不能为中文，中文请自行编码\nresponse.setheader("content-disposition","https://doc.hutool.cn/assets/js/attachment;filename=test.xls"); \nservletoutputstream out=response.getoutputstream(); \n\nwriter.flush(out, true);\n// 关闭writer，释放内存\nwriter.close();\n//此处记得关闭输出servlet流\nioutil.close(out);\n\n\n 2. 写出xlsx\n\nexcelwriter writer = excelutil.getwriter(true);\nwriter.write(rows, true);\n\nresponse.setcontenttype("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8"); \nresponse.setheader("content-disposition","https://doc.hutool.cn/assets/js/attachment;filename=test.xlsx"); \nservletoutputstream out=response.getoutputstream(); \n\nwriter.flush(out, true);\nwriter.close();\nioutil.close(out);\n\n\n> 注意\n> excelutil.getwriter()默认创建xls格式的excel，因此写出到客户端也需要自定义文件名为xxx.xls，否则会出现文件损坏的提示。\n> 若想生成xlsx格式，请使用excelutil.getwriter(true)创建。\n\n 3. 下载提示文件损坏问题解决\n\n有用户反馈按照代码生成的excel下载后提示文件损坏，无法打开，经过排查，可能是几个问题：\n\n * （1）writer和out流没有正确关闭，请在代码末尾的finally块增加关闭。\n * （2）扩展名不匹配。getwriter默认生成xls，content-disposition中也应该是xls，只有getwriter(true)时才可以使用xlsx\n * （3）maven项目中excel保存于classpath中（src/main/resources下）宏替换导致被破坏，解决办法是添加filtering（参考：springboot下载excel模板，excel表损坏问题\n * （4）excel打开提示文件损坏，wps可以打开。这是excel的安全性控制导致的，解决办法见：springboot下载excel（解决文件损坏问题）\n\n\n# 自定义excel\n\n\n# 1. 设置单元格背景色\n\nexcelwriter writer = ...;\n\n// 定义单元格背景色\nstyleset style = writer.getstyleset();\n// 第二个参数表示是否也设置头部单元格背景\nstyle.setbackgroundcolor(indexedcolors.red, false);\n\n\n\n# 2. 自定义字体\n\nexcelwriter writer = ...;\n//设置内容字体\nfont font = writer.createfont();\nfont.setbold(true);\nfont.setcolor(font.color_red); \nfont.setitalic(true); \n//第二个参数表示是否忽略头部样式\nwriter.getstyleset().setfont(font, true);\n\n\n\n# 3. 写出多个sheet\n\n//初始化时定义表名\nexcelwriter writer = new excelwriter("d:/aaa.xls", "表1");\n//切换sheet，此时从第0行开始写\nwriter.setsheet("表2");\n...\nwriter.setsheet("表3");\n...\n\n\n\n# 4. 更详细的定义样式\n\n在excel中，由于样式对象个数有限制，因此hutool根据样式种类分为4个样式对象，使相同类型的单元格可以共享样式对象。样式按照类别存在于styleset中，其中包括：\n\n * headcellstyle 头部样式\n * cellstyle 普通单元格样式\n * cellstylefornumber 数字单元格样式\n * cellstylefordate 日期单元格样式\n\n其中cellstylefornumber cellstylefordate用于控制数字和日期的显示方式。\n\n因此我们可以使用以下方式获取cellstyle对象自定义指定种类的样式：\n\nstyleset style = writer.getstyleset();\ncellstyle cellstyle = style.getheadcellstyle();\n...\n\n\n\n# 5. 自定义写出的值\n\n你可以实现cellsetter接口来自定义写出到单元格的值，此接口只有一个方法：setvalue(cell cell)，通过暴露cell对象使得用户可以自定义输出单元格内容，甚至是样式。\n\n// 此处使用lambda自定义写出内容\nlist<object> row = listutil.of((cellsetter) cell -> cell.setcellvalue("自定义内容"));\n\nexcelwriter writer = excelutil.getwriter("https://doc.hutool.cn/test/test.xlsx");\nwriter.writerow(row);\nwriter.close();\n\n\n> 注意\n> 某些特殊的字符串会导致excel自动转义，如_xxxxx_这种格式的字符串会被当做unicode转义符，会被反转义。\n> 此时可以使用hutool内置的escapestrcellsetter\n\nlist<object> row = listutil.of(new escapestrcellsetter("_x5116_"));\n\nexcelwriter writer = excelutil.getwriter("https://doc.hutool.cn/test/test.xlsx");\nwriter.writerow(row);\nwriter.close();\n\n\n此问题的详细说明见：单元格包含"_x”导致字符串转码',charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"Excel大数据生成-BigExcelWriter",frontmatter:{title:"Excel大数据生成-BigExcelWriter",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/BigExcelWriter/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/16.Office%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C%EF%BC%88Hutool-poi%EF%BC%89/04.Excel%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90-BigExcelWriter.html",relativePath:"01.指南/16.Office文档操作（Hutool-poi）/04.Excel大数据生成-BigExcelWriter.md",key:"v-a71be36a",path:"/pages/BigExcelWriter/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:56}],headersStr:"介绍 使用",content:'# 介绍\n\n对于大量数据输出，采用ExcelWriter容易引起内存溢出，因此有了BigExcelWriter，使用方法与ExcelWriter完全一致。\n\n\n# 使用\n\nList<?> row1 = CollUtil.newArrayList("aa", "bb", "cc", "dd", DateUtil.date(), 3.22676575765);\nList<?> row2 = CollUtil.newArrayList("aa1", "bb1", "cc1", "dd1", DateUtil.date(), 250.7676);\nList<?> row3 = CollUtil.newArrayList("aa2", "bb2", "cc2", "dd2", DateUtil.date(), 0.111);\nList<?> row4 = CollUtil.newArrayList("aa3", "bb3", "cc3", "dd3", DateUtil.date(), 35);\nList<?> row5 = CollUtil.newArrayList("aa4", "bb4", "cc4", "dd4", DateUtil.date(), 28.00);\n\nList<List<?>> rows = CollUtil.newArrayList(row1, row2, row3, row4, row5);\n\nBigExcelWriter writer= ExcelUtil.getBigWriter("e:/xxx.xlsx");\n// 一次性写出内容，使用默认样式\nwriter.write(rows);\n// 关闭writer，释放内存\nwriter.close();\n',normalizedContent:'# 介绍\n\n对于大量数据输出，采用excelwriter容易引起内存溢出，因此有了bigexcelwriter，使用方法与excelwriter完全一致。\n\n\n# 使用\n\nlist<?> row1 = collutil.newarraylist("aa", "bb", "cc", "dd", dateutil.date(), 3.22676575765);\nlist<?> row2 = collutil.newarraylist("aa1", "bb1", "cc1", "dd1", dateutil.date(), 250.7676);\nlist<?> row3 = collutil.newarraylist("aa2", "bb2", "cc2", "dd2", dateutil.date(), 0.111);\nlist<?> row4 = collutil.newarraylist("aa3", "bb3", "cc3", "dd3", dateutil.date(), 35);\nlist<?> row5 = collutil.newarraylist("aa4", "bb4", "cc4", "dd4", dateutil.date(), 28.00);\n\nlist<list<?>> rows = collutil.newarraylist(row1, row2, row3, row4, row5);\n\nbigexcelwriter writer= excelutil.getbigwriter("e:/xxx.xlsx");\n// 一次性写出内容，使用默认样式\nwriter.write(rows);\n// 关闭writer，释放内存\nwriter.close();\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/poi/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/16.Office%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C%EF%BC%88Hutool-poi%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/16.Office文档操作（Hutool-poi）/01.概述.md",key:"v-5f57ddce",path:"/pages/poi/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:117},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:60},{level:3,title:"引入POI依赖",slug:"引入poi依赖",normalizedTitle:"引入poi依赖",charIndex:282},{level:3,title:"常见问题",slug:"常见问题",normalizedTitle:"常见问题",charIndex:1031}],headersStr:"由来 介绍 使用 引入POI依赖 常见问题",content:"# 由来\n\nJava针对MS Office的操作的库屈指可数，比较有名的就是Apache的POI库。这个库异常强大，但是使用起来也并不容易。Hutool针对POI封装一些常用工具，使Java操作Excel等文件变得异常简单。\n\n\n# 介绍\n\nHutool-poi是针对Apache POI的封装，因此需要用户自行引入POI库,Hutool默认不引入。到目前为止，Hutool-poi支持：\n\n * Excel文件（xls, xlsx）的读取（ExcelReader）\n * Excel文件（xls，xlsx）的写出（ExcelWriter）\n\n\n# 使用\n\n\n# 引入POI依赖\n\n推荐引入poi-ooxml，这个包会自动关联引入poi包，且可以很好的支持Office2007+的文档格式\n\n<dependency>\n    <groupId>org.apache.poi</groupId>\n    <artifactId>poi-ooxml</artifactId>\n    <version>${poi.version}</version>\n</dependency>\n\n\n如果需要使用Sax方式读取Excel，需要引入以下依赖（POI-4.x以上这个非必须）：\n\n<dependency>\n    <groupId>xerces</groupId>\n    <artifactId>xercesImpl</artifactId>\n    <version>${xerces.version}</version>\n</dependency>\n\n\n> 说明\n> hutool-4.x的poi-ooxml 版本需高于 3.17（别问我3.8版本为啥不行，因为3.17 > 3.8 ）\n> hutool-5.x的poi-ooxml 版本需高于 4.1.2\n> hutool-5.6.x支持poi-ooxml 版本高于 5.0.0\n> xercesImpl版本高于2.12.0（非必须）\n\n引入后即可使用Hutool的方法操作Office文件了，Hutool提供的类有：\n\n * ExcelUtil Excel工具类，读取的快捷方法都被封装于此\n * ExcelReader Excel读取器，Excel读取的封装，可以直接构造后使用。\n * ExcelWriter Excel生成并写出器，Excel写出的封装（写出到流或者文件），可以直接构造后使用。\n\n\n# 常见问题\n\n部分用户使用POI模块时会提示：\n\nYou need to add dependency of 'poi-ooxml' to your project, and version >= 4.1.2\n\n一般以下几个原因：\n\n 1. 没有引入POI相关jar或引入版本太低\n 2. 引入了多个版本的POI，导致包冲突了\n 3. 没有引入关联依赖，这个具体要看下堆栈中的Cause By",normalizedContent:"# 由来\n\njava针对ms office的操作的库屈指可数，比较有名的就是apache的poi库。这个库异常强大，但是使用起来也并不容易。hutool针对poi封装一些常用工具，使java操作excel等文件变得异常简单。\n\n\n# 介绍\n\nhutool-poi是针对apache poi的封装，因此需要用户自行引入poi库,hutool默认不引入。到目前为止，hutool-poi支持：\n\n * excel文件（xls, xlsx）的读取（excelreader）\n * excel文件（xls，xlsx）的写出（excelwriter）\n\n\n# 使用\n\n\n# 引入poi依赖\n\n推荐引入poi-ooxml，这个包会自动关联引入poi包，且可以很好的支持office2007+的文档格式\n\n<dependency>\n    <groupid>org.apache.poi</groupid>\n    <artifactid>poi-ooxml</artifactid>\n    <version>${poi.version}</version>\n</dependency>\n\n\n如果需要使用sax方式读取excel，需要引入以下依赖（poi-4.x以上这个非必须）：\n\n<dependency>\n    <groupid>xerces</groupid>\n    <artifactid>xercesimpl</artifactid>\n    <version>${xerces.version}</version>\n</dependency>\n\n\n> 说明\n> hutool-4.x的poi-ooxml 版本需高于 3.17（别问我3.8版本为啥不行，因为3.17 > 3.8 ）\n> hutool-5.x的poi-ooxml 版本需高于 4.1.2\n> hutool-5.6.x支持poi-ooxml 版本高于 5.0.0\n> xercesimpl版本高于2.12.0（非必须）\n\n引入后即可使用hutool的方法操作office文件了，hutool提供的类有：\n\n * excelutil excel工具类，读取的快捷方法都被封装于此\n * excelreader excel读取器，excel读取的封装，可以直接构造后使用。\n * excelwriter excel生成并写出器，excel写出的封装（写出到流或者文件），可以直接构造后使用。\n\n\n# 常见问题\n\n部分用户使用poi模块时会提示：\n\nyou need to add dependency of 'poi-ooxml' to your project, and version >= 4.1.2\n\n一般以下几个原因：\n\n 1. 没有引入poi相关jar或引入版本太低\n 2. 引入了多个版本的poi，导致包冲突了\n 3. 没有引入关联依赖，这个具体要看下堆栈中的cause by",charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"Spring工具-SpringUtil",frontmatter:{title:"Spring工具-SpringUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/SpringUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89/09.Spring/01.Spring%E5%B7%A5%E5%85%B7-SpringUtil.html",relativePath:"01.指南/12.扩展（Hutool-extra）/09.Spring/01.Spring工具-SpringUtil.md",key:"v-42fa0b81",path:"/pages/SpringUtil/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:6},{level:3,title:"注册SpringUtil",slug:"注册springutil",normalizedTitle:"注册springutil",charIndex:124},{level:3,title:"获取指定Bean",slug:"获取指定bean",normalizedTitle:"获取指定bean",charIndex:327}],headersStr:"由来 使用 注册SpringUtil 获取指定Bean",content:'# 由来\n\n使用Spring Boot时，通过依赖注入获取bean是非常方便的，但是在工具化的应用场景下，想要动态获取bean就变得非常困难，于是Hutool封装了Spring中Bean获取的工具类——SpringUtil。\n\n\n# 使用\n\n\n# 注册SpringUtil\n\n 1. 使用ComponentScan注册类\n\n// 扫描cn.hutool.extra.spring包下所有类并注册之\n@ComponentScan(basePackages={"cn.hutool.extra.spring"})\n\n\n 2. 使用Import导入\n\n@Import(cn.hutool.extra.spring.SpringUtil.class)\n\n\n\n# 获取指定Bean\n\n 1. 定义一个Bean\n\n@Data\npublic static class Demo2{\n\tprivate long id;\n\tprivate String name;\n\n\t@Bean(name="testDemo")\n\tpublic Demo2 generateDemo() {\n\t\tDemo2 demo = new Demo2();\n\t\tdemo.setId(12345);\n\t\tdemo.setName("test");\n\t\treturn demo;\n\t}\n}\n\n\n 2. 获取Bean\n\nfinal Demo2 testDemo = SpringUtil.getBean("testDemo");\n',normalizedContent:'# 由来\n\n使用spring boot时，通过依赖注入获取bean是非常方便的，但是在工具化的应用场景下，想要动态获取bean就变得非常困难，于是hutool封装了spring中bean获取的工具类——springutil。\n\n\n# 使用\n\n\n# 注册springutil\n\n 1. 使用componentscan注册类\n\n// 扫描cn.hutool.extra.spring包下所有类并注册之\n@componentscan(basepackages={"cn.hutool.extra.spring"})\n\n\n 2. 使用import导入\n\n@import(cn.hutool.extra.spring.springutil.class)\n\n\n\n# 获取指定bean\n\n 1. 定义一个bean\n\n@data\npublic static class demo2{\n\tprivate long id;\n\tprivate string name;\n\n\t@bean(name="testdemo")\n\tpublic demo2 generatedemo() {\n\t\tdemo2 demo = new demo2();\n\t\tdemo.setid(12345);\n\t\tdemo.setname("test");\n\t\treturn demo;\n\t}\n}\n\n\n 2. 获取bean\n\nfinal demo2 testdemo = springutil.getbean("testdemo");\n',charsets:{cjk:!0},lastUpdated:"2023/10/25, 14:44:30",lastUpdatedTimestamp:169821627e4},{title:"Excel工具-ExcelUtil",frontmatter:{title:"Excel工具-ExcelUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ExcelUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/16.Office%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C%EF%BC%88Hutool-poi%EF%BC%89/02.Excel%E5%B7%A5%E5%85%B7-ExcelUtil.html",relativePath:"01.指南/16.Office文档操作（Hutool-poi）/02.Excel工具-ExcelUtil.md",key:"v-42809042",path:"/pages/ExcelUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:22},{level:2,title:"后续",slug:"后续",normalizedTitle:"后续",charIndex:761}],headersStr:"介绍 使用 后续",content:'# 介绍\n\nExcel操作工具封装\n\n\n# 使用\n\n 1. 从文件中读取Excel为ExcelReader\n\nExcelReader reader = ExcelUtil.getReader(FileUtil.file("https://doc.hutool.cn/assets/js/test.xlsx"));\n\n\n 2. 从流中读取Excel为ExcelReader（比如从ClassPath中读取Excel文件）\n\nExcelReader reader = ExcelUtil.getReader(ResourceUtil.getStream("https://doc.hutool.cn/assets/js/aaa.xlsx"));\n\n\n 3. 读取指定的sheet\n\nExcelReader reader;\n\n//通过sheet编号获取\nreader = ExcelUtil.getReader(FileUtil.file("https://doc.hutool.cn/assets/js/test.xlsx"), 0);\n//通过sheet名获取\nreader = ExcelUtil.getReader(FileUtil.file("https://doc.hutool.cn/assets/js/test.xlsx"), "sheet1");\n\n\n 4. 读取大数据量的Excel\n\nprivate RowHandler createRowHandler() {\n\treturn new RowHandler() {\n\t\t@Override\n\t\tpublic void handle(int sheetIndex, int rowIndex, List<Object> rowlist) {\n\t\t\tConsole.log("[{}] [{}] {}", sheetIndex, rowIndex, rowlist);\n\t\t}\n\t};\n}\n\nExcelUtil.readBySax("https://doc.hutool.cn/assets/js/aaa.xlsx", 0, createRowHandler());\n\n\n\n# 后续\n\nExcelUtil.getReader方法只是将实体Excel文件转换为ExcelReader对象进行操作。接下来请参阅章节ExcelReader对Excel工作簿进行具体操作。',normalizedContent:'# 介绍\n\nexcel操作工具封装\n\n\n# 使用\n\n 1. 从文件中读取excel为excelreader\n\nexcelreader reader = excelutil.getreader(fileutil.file("https://doc.hutool.cn/assets/js/test.xlsx"));\n\n\n 2. 从流中读取excel为excelreader（比如从classpath中读取excel文件）\n\nexcelreader reader = excelutil.getreader(resourceutil.getstream("https://doc.hutool.cn/assets/js/aaa.xlsx"));\n\n\n 3. 读取指定的sheet\n\nexcelreader reader;\n\n//通过sheet编号获取\nreader = excelutil.getreader(fileutil.file("https://doc.hutool.cn/assets/js/test.xlsx"), 0);\n//通过sheet名获取\nreader = excelutil.getreader(fileutil.file("https://doc.hutool.cn/assets/js/test.xlsx"), "sheet1");\n\n\n 4. 读取大数据量的excel\n\nprivate rowhandler createrowhandler() {\n\treturn new rowhandler() {\n\t\t@override\n\t\tpublic void handle(int sheetindex, int rowindex, list<object> rowlist) {\n\t\t\tconsole.log("[{}] [{}] {}", sheetindex, rowindex, rowlist);\n\t\t}\n\t};\n}\n\nexcelutil.readbysax("https://doc.hutool.cn/assets/js/aaa.xlsx", 0, createrowhandler());\n\n\n\n# 后续\n\nexcelutil.getreader方法只是将实体excel文件转换为excelreader对象进行操作。接下来请参阅章节excelreader对excel工作簿进行具体操作。',charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"Excel读取-ExcelReader",frontmatter:{title:"Excel读取-ExcelReader",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/ExcelReader/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/16.Office%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C%EF%BC%88Hutool-poi%EF%BC%89/05.Excel%E8%AF%BB%E5%8F%96-ExcelReader.html",relativePath:"01.指南/16.Office文档操作（Hutool-poi）/05.Excel读取-ExcelReader.md",key:"v-b690a60e",path:"/pages/ExcelReader/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:85}],headersStr:"介绍 使用",content:'# 介绍\n\n读取Excel内容的封装，通过构造ExcelReader对象，指定被读取的Excel文件、流或工作簿，然后调用readXXX方法读取内容为指定格式。\n\n\n# 使用\n\n 1. 读取Excel中所有行和列，用二维列表表示\n\nExcelReader reader = ExcelUtil.getReader("d:/aaa.xlsx");\nList<List<Object>> readAll = reader.read();\n\n\n 2. 读取为Map列表，默认第一行为标题行，数据从第二行开始，一个Map表示一行，Map中的key为标题，value为标题对应的单元格值。\n\nExcelReader reader = ExcelUtil.getReader("d:/aaa.xlsx");\nList<Map<String, Object>> readAll = reader.readAll();\n\n\n 3. 读取为Bean列表，Bean中的字段名为标题，字段值为标题对应的单元格值。\n\nExcelReader reader = ExcelUtil.getReader("d:/aaa.xlsx");\nList<Person> all = reader.readAll(Person.class);\n',normalizedContent:'# 介绍\n\n读取excel内容的封装，通过构造excelreader对象，指定被读取的excel文件、流或工作簿，然后调用readxxx方法读取内容为指定格式。\n\n\n# 使用\n\n 1. 读取excel中所有行和列，用二维列表表示\n\nexcelreader reader = excelutil.getreader("d:/aaa.xlsx");\nlist<list<object>> readall = reader.read();\n\n\n 2. 读取为map列表，默认第一行为标题行，数据从第二行开始，一个map表示一行，map中的key为标题，value为标题对应的单元格值。\n\nexcelreader reader = excelutil.getreader("d:/aaa.xlsx");\nlist<map<string, object>> readall = reader.readall();\n\n\n 3. 读取为bean列表，bean中的字段名为标题，字段值为标题对应的单元格值。\n\nexcelreader reader = excelutil.getreader("d:/aaa.xlsx");\nlist<person> all = reader.readall(person.class);\n',charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"流方式读取Excel2007-Excel07SaxReader",frontmatter:{title:"流方式读取Excel2007-Excel07SaxReader",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Excel07SaxReader/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/16.Office%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C%EF%BC%88Hutool-poi%EF%BC%89/08.%E6%B5%81%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96Excel2007-Excel07SaxReader.html",relativePath:"01.指南/16.Office文档操作（Hutool-poi）/08.流方式读取Excel2007-Excel07SaxReader.md",key:"v-a51c0314",path:"/pages/Excel07SaxReader/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:134},{level:3,title:"定义行处理器",slug:"定义行处理器",normalizedTitle:"定义行处理器",charIndex:141},{level:3,title:"ExcelUtil快速读取",slug:"excelutil快速读取",normalizedTitle:"excelutil快速读取",charIndex:483},{level:3,title:"构建对象读取",slug:"构建对象读取",normalizedTitle:"构建对象读取",charIndex:559}],headersStr:"介绍 使用 定义行处理器 ExcelUtil快速读取 构建对象读取",content:'# 介绍\n\n在标准的ExcelReader中，如果数据量较大，读取Excel会非常缓慢，并有可能造成内存溢出。因此针对大数据量的Excel，Hutool封装了Sax模式的读取方式。\n\nExcel07SaxReader只支持Excel2007格式的Sax读取。\n\n\n# 使用\n\n\n# 定义行处理器\n\n首先我们实现一下RowHandler接口，这个接口是Sax读取的核心，通过实现handle方法编写我们要对每行数据的操作方式（比如按照行入库，入List或者写出到文件等），在此我们只是在控制台打印。\n\nprivate RowHandler createRowHandler() {\n\treturn new RowHandler() {\n\t\t@Override\n\t\tpublic void handle(int sheetIndex, long rowIndex, List<Object> rowlist) {\n\t\t\tConsole.log("[{}] [{}] {}", sheetIndex, rowIndex, rowlist);\n\t\t}\n\t};\n}\n\n\n\n# ExcelUtil快速读取\n\nExcelUtil.readBySax("https://doc.hutool.cn/assets/js/aaa.xlsx", 0, createRowHandler());\n\n\n\n# 构建对象读取\n\nExcel07SaxReader reader = new Excel07SaxReader(createRowHandler());\nreader.read("d:/text.xlsx", 0);\n\n\nreader方法的第二个参数是sheet的序号，-1表示读取所有sheet，0表示第一个sheet，依此类推。',normalizedContent:'# 介绍\n\n在标准的excelreader中，如果数据量较大，读取excel会非常缓慢，并有可能造成内存溢出。因此针对大数据量的excel，hutool封装了sax模式的读取方式。\n\nexcel07saxreader只支持excel2007格式的sax读取。\n\n\n# 使用\n\n\n# 定义行处理器\n\n首先我们实现一下rowhandler接口，这个接口是sax读取的核心，通过实现handle方法编写我们要对每行数据的操作方式（比如按照行入库，入list或者写出到文件等），在此我们只是在控制台打印。\n\nprivate rowhandler createrowhandler() {\n\treturn new rowhandler() {\n\t\t@override\n\t\tpublic void handle(int sheetindex, long rowindex, list<object> rowlist) {\n\t\t\tconsole.log("[{}] [{}] {}", sheetindex, rowindex, rowlist);\n\t\t}\n\t};\n}\n\n\n\n# excelutil快速读取\n\nexcelutil.readbysax("https://doc.hutool.cn/assets/js/aaa.xlsx", 0, createrowhandler());\n\n\n\n# 构建对象读取\n\nexcel07saxreader reader = new excel07saxreader(createrowhandler());\nreader.read("d:/text.xlsx", 0);\n\n\nreader方法的第二个参数是sheet的序号，-1表示读取所有sheet，0表示第一个sheet，依此类推。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Word生成-Word07Writer",frontmatter:{title:"Word生成-Word07Writer",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Word07Writer/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/16.Office%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C%EF%BC%88Hutool-poi%EF%BC%89/06.Word%E7%94%9F%E6%88%90-Word07Writer.html",relativePath:"01.指南/16.Office文档操作（Hutool-poi）/06.Word生成-Word07Writer.md",key:"v-edbd1a1c",path:"/pages/Word07Writer/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:53},{level:2,title:"使用例子",slug:"使用例子",normalizedTitle:"使用例子",charIndex:112}],headersStr:"由来 介绍 使用例子",content:'# 由来\n\nHutool针对Word（主要是docx格式）进行封装，实现简单的Word文件创建。\n\n\n# 介绍\n\nHutool将POI中Word生成封装为Word07Writer, 通过分段写出，实现word生成。\n\n\n# 使用例子\n\nWord07Writer writer = new Word07Writer();\n\n// 添加段落（标题）\nwriter.addText(new Font("方正小标宋简体", Font.PLAIN, 22), "我是第一部分", "我是第二部分");\n// 添加段落（正文）\nwriter.addText(new Font("宋体", Font.PLAIN, 22), "我是正文第一部分", "我是正文第二部分");\n// 写出到文件\nwriter.flush(FileUtil.file("e:/wordWrite.docx"));\n// 关闭\nwriter.close();\n',normalizedContent:'# 由来\n\nhutool针对word（主要是docx格式）进行封装，实现简单的word文件创建。\n\n\n# 介绍\n\nhutool将poi中word生成封装为word07writer, 通过分段写出，实现word生成。\n\n\n# 使用例子\n\nword07writer writer = new word07writer();\n\n// 添加段落（标题）\nwriter.addtext(new font("方正小标宋简体", font.plain, 22), "我是第一部分", "我是第二部分");\n// 添加段落（正文）\nwriter.addtext(new font("宋体", font.plain, 22), "我是正文第一部分", "我是正文第二部分");\n// 写出到文件\nwriter.flush(fileutil.file("e:/wordwrite.docx"));\n// 关闭\nwriter.close();\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"系统属性调用-SystemUtil",frontmatter:{title:"系统属性调用-SystemUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/SystemUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/17.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88Hutool-system%EF%BC%89/01.%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7%E8%B0%83%E7%94%A8-SystemUtil.html",relativePath:"01.指南/17.系统调用（Hutool-system）/01.系统属性调用-SystemUtil.md",key:"v-e026e1c6",path:"/pages/SystemUtil/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:3,title:"Java Virtual Machine Specification信息",slug:"java-virtual-machine-specification信息",normalizedTitle:"java virtual machine specification信息",charIndex:60},{level:3,title:"Java Virtual Machine Implementation信息",slug:"java-virtual-machine-implementation信息",normalizedTitle:"java virtual machine implementation信息",charIndex:132},{level:3,title:"Java Specification信息",slug:"java-specification信息",normalizedTitle:"java specification信息",charIndex:201},{level:3,title:"Java Implementation信息",slug:"java-implementation信息",normalizedTitle:"java implementation信息",charIndex:258},{level:3,title:"Java运行时信息",slug:"java运行时信息",normalizedTitle:"java运行时信息",charIndex:312},{level:3,title:"系统信息",slug:"系统信息",normalizedTitle:"系统信息",charIndex:361},{level:3,title:"用户信息",slug:"用户信息",normalizedTitle:"用户信息",charIndex:396},{level:3,title:"当前主机网络地址信息",slug:"当前主机网络地址信息",normalizedTitle:"当前主机网络地址信息",charIndex:433},{level:3,title:"运行时信息，包括内存总大小、已用大小、可用大小等",slug:"运行时信息-包括内存总大小、已用大小、可用大小等",normalizedTitle:"运行时信息，包括内存总大小、已用大小、可用大小等",charIndex:476}],headersStr:"概述 Java Virtual Machine Specification信息 Java Virtual Machine Implementation信息 Java Specification信息 Java Implementation信息 Java运行时信息 系统信息 用户信息 当前主机网络地址信息 运行时信息，包括内存总大小、已用大小、可用大小等",content:"# 概述\n\n此工具是针对System.getProperty(name)的封装，通过此工具，可以获取如下信息：\n\n\n# Java Virtual Machine Specification信息\n\nSystemUtil.getJvmSpecInfo();\n\n\n\n# Java Virtual Machine Implementation信息\n\nSystemUtil.getJvmInfo();\n\n\n\n# Java Specification信息\n\nSystemUtil.getJavaSpecInfo();\n\n\n\n# Java Implementation信息\n\nSystemUtil.getJavaInfo();\n\n\n\n# Java运行时信息\n\nSystemUtil.getJavaRuntimeInfo();\n\n\n\n# 系统信息\n\nSystemUtil.getOsInfo();\n\n\n\n# 用户信息\n\nSystemUtil.getUserInfo();\n\n\n\n# 当前主机网络地址信息\n\nSystemUtil.getHostInfo();\n\n\n\n# 运行时信息，包括内存总大小、已用大小、可用大小等\n\nSystemUtil.getRuntimeInfo();\n",normalizedContent:"# 概述\n\n此工具是针对system.getproperty(name)的封装，通过此工具，可以获取如下信息：\n\n\n# java virtual machine specification信息\n\nsystemutil.getjvmspecinfo();\n\n\n\n# java virtual machine implementation信息\n\nsystemutil.getjvminfo();\n\n\n\n# java specification信息\n\nsystemutil.getjavaspecinfo();\n\n\n\n# java implementation信息\n\nsystemutil.getjavainfo();\n\n\n\n# java运行时信息\n\nsystemutil.getjavaruntimeinfo();\n\n\n\n# 系统信息\n\nsystemutil.getosinfo();\n\n\n\n# 用户信息\n\nsystemutil.getuserinfo();\n\n\n\n# 当前主机网络地址信息\n\nsystemutil.gethostinfo();\n\n\n\n# 运行时信息，包括内存总大小、已用大小、可用大小等\n\nsystemutil.getruntimeinfo();\n",charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"Oshi封装-OshiUtil",frontmatter:{title:"Oshi封装-OshiUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/OshiUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/17.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88Hutool-system%EF%BC%89/02.Oshi%E5%B0%81%E8%A3%85-OshiUtil.html",relativePath:"01.指南/17.系统调用（Hutool-system）/02.Oshi封装-OshiUtil.md",key:"v-61a4e700",path:"/pages/OshiUtil/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:114}],headersStr:"概述 使用",content:"# 概述\n\nOshi是一个免费的基于JNA的获取操作系统和硬件信息的java库，Github地址是：oshi\n\n它的优点是不需要安装任何其他本机库，并且旨在提供一种跨平台的实现来检索系统信息，例如操作系统版本，进程，内存和CPU使用率，磁盘和分区，设备，传感器等。\n\n这个库可以监测的内容包括：\n\n 1.  计算机系统和固件，底板\n 2.  操作系统和版本/内部版本\n 3.  物理（核心）和逻辑（超线程）CPU，处理器组，NUMA节点\n 4.  系统和每个处理器的负载百分比和滴答计数器\n 5.  CPU正常运行时间，进程和线程\n 6.  进程正常运行时间，CPU，内存使用率，用户/组，命令行\n 7.  已使用/可用的物理和虚拟内存\n 8.  挂载的文件系统（类型，可用空间和总空间）\n 9.  磁盘驱动器（型号，序列号，大小）和分区\n 10. 网络接口（IP，带宽输入/输出）\n 11. 电池状态（电量百分比，剩余时间，电量使用情况统计信息）\n 12. 连接的显示器（带有EDID信息）\n 13. USB设备\n 14. 传感器（温度，风扇速度，电压）\n\n也就是说配合一个前端界面，完全可以搞定系统监控了。\n\n\n# 使用\n\n先引入Oshi库：\n\n<dependency>\n\t<groupId>com.github.oshi</groupId>\n\t<artifactId>oshi-core</artifactId>\n\t<version>6.4.1</version>\n</dependency>\n\n\n然后可以调用相关API获取相关信息。\n\n例如我们想获取内存总量：\n\nlong total = OshiUtil.getMemory().getTotal();\n\n\n我们也可以获取CPU的一些信息：\n\nCpuInfo cpuInfo = OshiUtil.getCpuInfo();\nConsole.log(cpuInfo);\n\n\nCpuInfo{cpu核心数=12, CPU总的使用率=12595.0, CPU系统使用率=1.74, CPU用户使用率=6.69, CPU当前等待率=0.0, CPU当前空闲率=91.57, CPU利用率=8.43, CPU型号信息='AMD Ryzen 5 4600U with Radeon Graphics         \n 1 physical CPU package(s)\n 6 physical CPU core(s)\n 12 logical CPU(s)\nIdentifier: AuthenticAMD Family 23 Model 96 Stepping 1\nProcessorID: xxxxxxxxx\nMicroarchitecture: unknown'}\n",normalizedContent:"# 概述\n\noshi是一个免费的基于jna的获取操作系统和硬件信息的java库，github地址是：oshi\n\n它的优点是不需要安装任何其他本机库，并且旨在提供一种跨平台的实现来检索系统信息，例如操作系统版本，进程，内存和cpu使用率，磁盘和分区，设备，传感器等。\n\n这个库可以监测的内容包括：\n\n 1.  计算机系统和固件，底板\n 2.  操作系统和版本/内部版本\n 3.  物理（核心）和逻辑（超线程）cpu，处理器组，numa节点\n 4.  系统和每个处理器的负载百分比和滴答计数器\n 5.  cpu正常运行时间，进程和线程\n 6.  进程正常运行时间，cpu，内存使用率，用户/组，命令行\n 7.  已使用/可用的物理和虚拟内存\n 8.  挂载的文件系统（类型，可用空间和总空间）\n 9.  磁盘驱动器（型号，序列号，大小）和分区\n 10. 网络接口（ip，带宽输入/输出）\n 11. 电池状态（电量百分比，剩余时间，电量使用情况统计信息）\n 12. 连接的显示器（带有edid信息）\n 13. usb设备\n 14. 传感器（温度，风扇速度，电压）\n\n也就是说配合一个前端界面，完全可以搞定系统监控了。\n\n\n# 使用\n\n先引入oshi库：\n\n<dependency>\n\t<groupid>com.github.oshi</groupid>\n\t<artifactid>oshi-core</artifactid>\n\t<version>6.4.1</version>\n</dependency>\n\n\n然后可以调用相关api获取相关信息。\n\n例如我们想获取内存总量：\n\nlong total = oshiutil.getmemory().gettotal();\n\n\n我们也可以获取cpu的一些信息：\n\ncpuinfo cpuinfo = oshiutil.getcpuinfo();\nconsole.log(cpuinfo);\n\n\ncpuinfo{cpu核心数=12, cpu总的使用率=12595.0, cpu系统使用率=1.74, cpu用户使用率=6.69, cpu当前等待率=0.0, cpu当前空闲率=91.57, cpu利用率=8.43, cpu型号信息='amd ryzen 5 4600u with radeon graphics         \n 1 physical cpu package(s)\n 6 physical cpu core(s)\n 12 logical cpu(s)\nidentifier: authenticamd family 23 model 96 stepping 1\nprocessorid: xxxxxxxxx\nmicroarchitecture: unknown'}\n",charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/captcha/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/18.%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%88Hutool-captcha%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/18.图形验证码（Hutool-captcha）/01.概述.md",key:"v-4d9946c2",path:"/pages/captcha/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:58},{level:2,title:"实现类",slug:"实现类",normalizedTitle:"实现类",charIndex:136},{level:3,title:"LineCaptcha 线段干扰的验证码",slug:"linecaptcha-线段干扰的验证码",normalizedTitle:"linecaptcha 线段干扰的验证码",charIndex:406},{level:3,title:"CircleCaptcha 圆圈干扰验证码",slug:"circlecaptcha-圆圈干扰验证码",normalizedTitle:"circlecaptcha 圆圈干扰验证码",charIndex:860},{level:3,title:"ShearCaptcha 扭曲干扰验证码",slug:"shearcaptcha-扭曲干扰验证码",normalizedTitle:"shearcaptcha 扭曲干扰验证码",charIndex:1167},{level:2,title:"写出到浏览器（Servlet输出）",slug:"写出到浏览器-servlet输出",normalizedTitle:"写出到浏览器（servlet输出）",charIndex:1465},{level:2,title:"自定义验证码",slug:"自定义验证码",normalizedTitle:"自定义验证码",charIndex:1587}],headersStr:"由来 介绍 实现类 LineCaptcha 线段干扰的验证码 CircleCaptcha 圆圈干扰验证码 ShearCaptcha 扭曲干扰验证码 写出到浏览器（Servlet输出） 自定义验证码",content:'# 由来\n\n由于对验证码需求量巨大，且我之前项目中有所积累，因此在Hutool中加入验证码生成和校验功能。\n\n\n# 介绍\n\n验证码功能位于cn.hutool.captcha包中，核心接口为ICaptcha，此接口定义了以下方法：\n\n * createCode 创建验证码，实现类需同时生成随机验证码字符串和验证码图片\n * getCode 获取验证码的文字内容\n * verify 验证验证码是否正确，建议忽略大小写\n * write 将验证码图片写出到目标流中\n\n其中write方法只有一个OutputStream，ICaptcha实现类可以根据这个方法封装写出到文件等方法。\n\nAbstractCaptcha为一个ICaptcha抽象实现类，此类实现了验证码文本生成、非大小写敏感的验证、写出到流和文件等方法，通过继承此抽象类只需实现createImage方法定义图形生成规则即可。\n\n\n# 实现类\n\n\n# LineCaptcha 线段干扰的验证码\n\n生成效果大致如下：\n\n\n\n贴栗子：\n\n//定义图形验证码的长和宽\nLineCaptcha lineCaptcha = CaptchaUtil.createLineCaptcha(200, 100);\n\n//图形验证码写出，可以写出到文件，也可以写出到流\nlineCaptcha.write("d:/line.png");\n//输出code\nConsole.log(lineCaptcha.getCode());\n//验证图形验证码的有效性，返回boolean值\nlineCaptcha.verify("1234");\n\n//重新生成验证码\nlineCaptcha.createCode();\nlineCaptcha.write("d:/line.png");\n//新的验证码\nConsole.log(lineCaptcha.getCode());\n//验证图形验证码的有效性，返回boolean值\nlineCaptcha.verify("1234");\n\n\n\n# CircleCaptcha 圆圈干扰验证码\n\n\n\n贴栗子：\n\n//定义图形验证码的长、宽、验证码字符数、干扰元素个数\nCircleCaptcha captcha = CaptchaUtil.createCircleCaptcha(200, 100, 4, 20);\n//CircleCaptcha captcha = new CircleCaptcha(200, 100, 4, 20);\n//图形验证码写出，可以写出到文件，也可以写出到流\ncaptcha.write("d:/circle.png");\n//验证图形验证码的有效性，返回boolean值\ncaptcha.verify("1234");\n\n\n\n# ShearCaptcha 扭曲干扰验证码\n\n\n\n贴栗子：\n\n//定义图形验证码的长、宽、验证码字符数、干扰线宽度\nShearCaptcha captcha = CaptchaUtil.createShearCaptcha(200, 100, 4, 4);\n//ShearCaptcha captcha = new ShearCaptcha(200, 100, 4, 4);\n//图形验证码写出，可以写出到文件，也可以写出到流\ncaptcha.write("d:/shear.png");\n//验证图形验证码的有效性，返回boolean值\ncaptcha.verify("1234");\n\n\n\n# 写出到浏览器（Servlet输出）\n\nICaptcha captcha = ...;\ncaptcha.write(response.getOutputStream());\n//Servlet的OutputStream记得自行关闭哦！\n\n\n\n# 自定义验证码\n\n有时候标准的验证码不满足要求，比如我们希望使用纯字母的验证码、纯数字的验证码、加减乘除的验证码，此时我们就要自定义CodeGenerator\n\n// 自定义纯数字的验证码（随机4位数字，可重复）\nRandomGenerator randomGenerator = new RandomGenerator("0123456789", 4);\nLineCaptcha lineCaptcha = CaptchaUtil.createLineCaptcha(200, 100);\nlineCaptcha.setGenerator(randomGenerator);\n// 重新生成code\nlineCaptcha.createCode();\n\n\nShearCaptcha captcha = CaptchaUtil.createShearCaptcha(200, 45, 4, 4);\n// 自定义验证码内容为四则运算方式\ncaptcha.setGenerator(new MathGenerator());\n// 重新生成code\ncaptcha.createCode();\n',normalizedContent:'# 由来\n\n由于对验证码需求量巨大，且我之前项目中有所积累，因此在hutool中加入验证码生成和校验功能。\n\n\n# 介绍\n\n验证码功能位于cn.hutool.captcha包中，核心接口为icaptcha，此接口定义了以下方法：\n\n * createcode 创建验证码，实现类需同时生成随机验证码字符串和验证码图片\n * getcode 获取验证码的文字内容\n * verify 验证验证码是否正确，建议忽略大小写\n * write 将验证码图片写出到目标流中\n\n其中write方法只有一个outputstream，icaptcha实现类可以根据这个方法封装写出到文件等方法。\n\nabstractcaptcha为一个icaptcha抽象实现类，此类实现了验证码文本生成、非大小写敏感的验证、写出到流和文件等方法，通过继承此抽象类只需实现createimage方法定义图形生成规则即可。\n\n\n# 实现类\n\n\n# linecaptcha 线段干扰的验证码\n\n生成效果大致如下：\n\n\n\n贴栗子：\n\n//定义图形验证码的长和宽\nlinecaptcha linecaptcha = captchautil.createlinecaptcha(200, 100);\n\n//图形验证码写出，可以写出到文件，也可以写出到流\nlinecaptcha.write("d:/line.png");\n//输出code\nconsole.log(linecaptcha.getcode());\n//验证图形验证码的有效性，返回boolean值\nlinecaptcha.verify("1234");\n\n//重新生成验证码\nlinecaptcha.createcode();\nlinecaptcha.write("d:/line.png");\n//新的验证码\nconsole.log(linecaptcha.getcode());\n//验证图形验证码的有效性，返回boolean值\nlinecaptcha.verify("1234");\n\n\n\n# circlecaptcha 圆圈干扰验证码\n\n\n\n贴栗子：\n\n//定义图形验证码的长、宽、验证码字符数、干扰元素个数\ncirclecaptcha captcha = captchautil.createcirclecaptcha(200, 100, 4, 20);\n//circlecaptcha captcha = new circlecaptcha(200, 100, 4, 20);\n//图形验证码写出，可以写出到文件，也可以写出到流\ncaptcha.write("d:/circle.png");\n//验证图形验证码的有效性，返回boolean值\ncaptcha.verify("1234");\n\n\n\n# shearcaptcha 扭曲干扰验证码\n\n\n\n贴栗子：\n\n//定义图形验证码的长、宽、验证码字符数、干扰线宽度\nshearcaptcha captcha = captchautil.createshearcaptcha(200, 100, 4, 4);\n//shearcaptcha captcha = new shearcaptcha(200, 100, 4, 4);\n//图形验证码写出，可以写出到文件，也可以写出到流\ncaptcha.write("d:/shear.png");\n//验证图形验证码的有效性，返回boolean值\ncaptcha.verify("1234");\n\n\n\n# 写出到浏览器（servlet输出）\n\nicaptcha captcha = ...;\ncaptcha.write(response.getoutputstream());\n//servlet的outputstream记得自行关闭哦！\n\n\n\n# 自定义验证码\n\n有时候标准的验证码不满足要求，比如我们希望使用纯字母的验证码、纯数字的验证码、加减乘除的验证码，此时我们就要自定义codegenerator\n\n// 自定义纯数字的验证码（随机4位数字，可重复）\nrandomgenerator randomgenerator = new randomgenerator("0123456789", 4);\nlinecaptcha linecaptcha = captchautil.createlinecaptcha(200, 100);\nlinecaptcha.setgenerator(randomgenerator);\n// 重新生成code\nlinecaptcha.createcode();\n\n\nshearcaptcha captcha = captchautil.createshearcaptcha(200, 45, 4, 4);\n// 自定义验证码内容为四则运算方式\ncaptcha.setgenerator(new mathgenerator());\n// 重新生成code\ncaptcha.createcode();\n',charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/socket/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/19.%E7%BD%91%E7%BB%9CSocket%EF%BC%88Hutool-socket%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/19.网络Socket（Hutool-socket）/01.概述.md",key:"v-10cdf0c6",path:"/pages/socket/",headers:[{level:2,title:"模块介绍",slug:"模块介绍",normalizedTitle:"模块介绍",charIndex:2},{level:3,title:"Socket介绍",slug:"socket介绍",normalizedTitle:"socket介绍",charIndex:11},{level:3,title:"Hutool封装",slug:"hutool封装",normalizedTitle:"hutool封装",charIndex:136}],headersStr:"模块介绍 Socket介绍 Hutool封装",content:"# 模块介绍\n\n\n# Socket介绍\n\n介绍来自：TCP编程\n\n在开发网络应用程序的时候，我们又会遇到Socket这个概念。Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络。\n\n\n# Hutool封装\n\nJDK中提供了Socket功能，包括：\n\n * BIO\n * NIO\n * AIO\n\nHutool只针对NIO和AIO做了简单的封装，用于简化Socket异步开发。\n\n> 现阶段，Hutool的socket封装依旧不是一个完整框架或者高效的工具类，不能提供完整的高性能IO功能，因此推荐更加专业的Socket库。例如：\n\n> t-io\n\n> Voovan\n\n> Netty\n\n> Mina",normalizedContent:"# 模块介绍\n\n\n# socket介绍\n\n介绍来自：tcp编程\n\n在开发网络应用程序的时候，我们又会遇到socket这个概念。socket是一个抽象概念，一个应用程序通过一个socket来建立一个远程连接，而socket内部通过tcp/ip协议把数据传输到网络。\n\n\n# hutool封装\n\njdk中提供了socket功能，包括：\n\n * bio\n * nio\n * aio\n\nhutool只针对nio和aio做了简单的封装，用于简化socket异步开发。\n\n> 现阶段，hutool的socket封装依旧不是一个完整框架或者高效的工具类，不能提供完整的高性能io功能，因此推荐更加专业的socket库。例如：\n\n> t-io\n\n> voovan\n\n> netty\n\n> mina",charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"NIO封装-NioServer和NioClient",frontmatter:{title:"NIO封装-NioServer和NioClient",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/NioServer/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/19.%E7%BD%91%E7%BB%9CSocket%EF%BC%88Hutool-socket%EF%BC%89/03.NIO%E5%B0%81%E8%A3%85-NioServer%E5%92%8CNioClient.html",relativePath:"01.指南/19.网络Socket（Hutool-socket）/03.NIO封装-NioServer和NioClient.md",key:"v-ce732f52",path:"/pages/NioServer/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:31},{level:3,title:"服务端",slug:"服务端",normalizedTitle:"服务端",charIndex:38},{level:3,title:"客户端",slug:"客户端",normalizedTitle:"客户端",charIndex:997}],headersStr:"由来 使用 服务端 客户端",content:'# 由来\n\nHutool对NIO其进行了简单的封装。\n\n\n# 使用\n\n\n# 服务端\n\nNioServer server = new NioServer(8080);\nserver.setChannelHandler((sc)->{\n\tByteBuffer readBuffer = ByteBuffer.allocate(1024);\n\ttry{\n\t\t//从channel读数据到缓冲区\n\t\tint readBytes = sc.read(readBuffer);\n\t\tif (readBytes > 0) {\n\t\t\t//Flips this buffer.  The limit is set to the current position and then\n\t\t\t// the position is set to zero，就是表示要从起始位置开始读取数据\n\t\t\treadBuffer.flip();\n\t\t\t//eturns the number of elements between the current position and the  limit.\n\t\t\t// 要读取的字节长度\n\t\t\tbyte[] bytes = new byte[readBuffer.remaining()];\n\t\t\t//将缓冲区的数据读到bytes数组\n\t\t\treadBuffer.get(bytes);\n\t\t\tString body = StrUtil.utf8Str(bytes);\n\t\t\tConsole.log("[{}]: {}", sc.getRemoteAddress(), body);\n\t\t\tdoWrite(sc, body);\n\t\t} else if (readBytes < 0) {\n\t\t\tIoUtil.close(sc);\n\t\t}\n\t} catch (IOException e){\n\t\tthrow new IORuntimeException(e);\n\t}\n});\nserver.listen();\n\n\npublic static void doWrite(SocketChannel channel, String response) throws IOException {\n\tresponse = "收到消息：" + response;\n\t//将缓冲数据写入渠道，返回给客户端\n\tchannel.write(BufferUtil.createUtf8(response));\n}\n\n\n\n# 客户端\n\nNioClient client = new NioClient("127.0.0.1", 8080);\nclient.setChannelHandler((sc)->{\n\tByteBuffer readBuffer = ByteBuffer.allocate(1024);\n\t//从channel读数据到缓冲区\n\tint readBytes = sc.read(readBuffer);\n\tif (readBytes > 0) {\n\t\t//Flips this buffer.  The limit is set to the current position and then\n\t\t// the position is set to zero，就是表示要从起始位置开始读取数据\n\t\treadBuffer.flip();\n\t\t//returns the number of elements between the current position and the  limit.\n\t\t// 要读取的字节长度\n\t\tbyte[] bytes = new byte[readBuffer.remaining()];\n\t\t//将缓冲区的数据读到bytes数组\n\t\treadBuffer.get(bytes);\n\t\tString body = StrUtil.utf8Str(bytes);\n\t\tConsole.log("[{}]: {}", sc.getRemoteAddress(), body);\n\t} else if (readBytes < 0) {\n\t\tsc.close();\n\t}\n});\nclient.listen();\nclient.write(BufferUtil.createUtf8("你好。\\n"));\nclient.write(BufferUtil.createUtf8("你好2。"));\n// 在控制台向服务器端发送数据\nConsole.log("请输入发送的消息：");\nScanner scanner = new Scanner(System.in);\nwhile (scanner.hasNextLine()) {\n\tString request = scanner.nextLine();\n\tif (request != null && request.trim().length() > 0) {\n\t\tclient.write(BufferUtil.createUtf8(request));\n\t}\n}\n',normalizedContent:'# 由来\n\nhutool对nio其进行了简单的封装。\n\n\n# 使用\n\n\n# 服务端\n\nnioserver server = new nioserver(8080);\nserver.setchannelhandler((sc)->{\n\tbytebuffer readbuffer = bytebuffer.allocate(1024);\n\ttry{\n\t\t//从channel读数据到缓冲区\n\t\tint readbytes = sc.read(readbuffer);\n\t\tif (readbytes > 0) {\n\t\t\t//flips this buffer.  the limit is set to the current position and then\n\t\t\t// the position is set to zero，就是表示要从起始位置开始读取数据\n\t\t\treadbuffer.flip();\n\t\t\t//eturns the number of elements between the current position and the  limit.\n\t\t\t// 要读取的字节长度\n\t\t\tbyte[] bytes = new byte[readbuffer.remaining()];\n\t\t\t//将缓冲区的数据读到bytes数组\n\t\t\treadbuffer.get(bytes);\n\t\t\tstring body = strutil.utf8str(bytes);\n\t\t\tconsole.log("[{}]: {}", sc.getremoteaddress(), body);\n\t\t\tdowrite(sc, body);\n\t\t} else if (readbytes < 0) {\n\t\t\tioutil.close(sc);\n\t\t}\n\t} catch (ioexception e){\n\t\tthrow new ioruntimeexception(e);\n\t}\n});\nserver.listen();\n\n\npublic static void dowrite(socketchannel channel, string response) throws ioexception {\n\tresponse = "收到消息：" + response;\n\t//将缓冲数据写入渠道，返回给客户端\n\tchannel.write(bufferutil.createutf8(response));\n}\n\n\n\n# 客户端\n\nnioclient client = new nioclient("127.0.0.1", 8080);\nclient.setchannelhandler((sc)->{\n\tbytebuffer readbuffer = bytebuffer.allocate(1024);\n\t//从channel读数据到缓冲区\n\tint readbytes = sc.read(readbuffer);\n\tif (readbytes > 0) {\n\t\t//flips this buffer.  the limit is set to the current position and then\n\t\t// the position is set to zero，就是表示要从起始位置开始读取数据\n\t\treadbuffer.flip();\n\t\t//returns the number of elements between the current position and the  limit.\n\t\t// 要读取的字节长度\n\t\tbyte[] bytes = new byte[readbuffer.remaining()];\n\t\t//将缓冲区的数据读到bytes数组\n\t\treadbuffer.get(bytes);\n\t\tstring body = strutil.utf8str(bytes);\n\t\tconsole.log("[{}]: {}", sc.getremoteaddress(), body);\n\t} else if (readbytes < 0) {\n\t\tsc.close();\n\t}\n});\nclient.listen();\nclient.write(bufferutil.createutf8("你好。\\n"));\nclient.write(bufferutil.createutf8("你好2。"));\n// 在控制台向服务器端发送数据\nconsole.log("请输入发送的消息：");\nscanner scanner = new scanner(system.in);\nwhile (scanner.hasnextline()) {\n\tstring request = scanner.nextline();\n\tif (request != null && request.trim().length() > 0) {\n\t\tclient.write(bufferutil.createutf8(request));\n\t}\n}\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"概述",frontmatter:{title:"概述",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/jwt/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/20.JWT%EF%BC%88Hutool-jwt%EF%BC%89/01.%E6%A6%82%E8%BF%B0.html",relativePath:"01.指南/20.JWT（Hutool-jwt）/01.概述.md",key:"v-6bf762c9",path:"/pages/jwt/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"JWT介绍",slug:"jwt介绍",normalizedTitle:"jwt介绍",charIndex:55},{level:3,title:"结构",slug:"结构",normalizedTitle:"结构",charIndex:110},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:268},{level:3,title:"JWT生成",slug:"jwt生成",normalizedTitle:"jwt生成",charIndex:349},{level:3,title:"JWT解析",slug:"jwt解析",normalizedTitle:"jwt解析",charIndex:1460},{level:3,title:"JWT验证",slug:"jwt验证",normalizedTitle:"jwt验证",charIndex:1893}],headersStr:"由来 JWT介绍 结构 使用 JWT生成 JWT解析 JWT验证",content:'# 由来\n\n从5.7.0开始，Hutool提供了零依赖的JWT（JSON Web Token）实现。\n\n\n# JWT介绍\n\n相关资料网络上非常多，可以自行搜索，简单点说JWT就是一种网络身份认证和信息交换格式。\n\n\n# 结构\n\n * Header 头部信息，主要声明了JWT的签名算法等信息\n * Payload 载荷信息，主要承载了各种声明并传递明文数据\n * Signature 签名，拥有该部分的JWT被称为JWS，也就是签了名的JWT，用于校验数据\n\n整体结构是：\n\nheader.payload.signature\n\n\n\n# 使用\n\nJWT模块的核心主要是两个类：\n\n 1. JWT类用于链式生成、解析或验证JWT信息。\n 2. JWTUtil类主要是JWT的一些工具封装，提供更加简洁的JWT生成、解析和验证工作\n\n\n# JWT生成\n\n 1. HS256(HmacSHA256)算法\n\n// 密钥\nbyte[] key = "1234567890".getBytes();\n\nString token = JWT.create()\n\t.setPayload("sub", "1234567890")\n\t.setPayload("name", "looly")\n\t.setPayload("admin", true)\n\t.setKey(key)\n\t.sign();\n\n\n生成的内容为：\n\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiYWRtaW4iOnRydWUsIm5hbWUiOiJsb29seSJ9.536690902d931d857d2f47d337ec81048ee09a8e71866bcc8404edbbcbf4cc40\n\n\n 2. 其他算法\n\n// 密钥\nbyte[] key = "1234567890".getBytes();\n\n// SHA256withRSA\nString id = "rs256";\nJWTSigner signer = JWTSignerUtil.createSigner(id, \n\t// 随机生成密钥对，此处用户可自行读取`KeyPair`、公钥或私钥生成`JWTSigner`\n\tKeyUtil.generateKeyPair(AlgorithmUtil.getAlgorithm(id)));\n\nString token = JWT.create()\n\t.setPayload("sub", "1234567890")\n\t.setPayload("name", "looly")\n\t.setPayload("admin", true)\n\t.setSigner(signer)\n\t.sign();\n\n\n 3. 不签名JWT\n\n// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiYWRtaW4iOnRydWUsIm5hbWUiOiJsb29seSJ9.\nString token = JWT.create()\n\t.setPayload("sub", "1234567890")\n\t.setPayload("name", "looly")\n\t.setPayload("admin", true)\n\t.setSigner(JWTSignerUtil.none())\n\t.sign()\n\n\n\n# JWT解析\n\nString rightToken = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9." +\n\t"eyJzdWIiOiIxMjM0NTY3ODkwIiwiYWRtaW4iOnRydWUsIm5hbWUiOiJsb29seSJ9." +\n\t"536690902d931d857d2f47d337ec81048ee09a8e71866bcc8404edbbcbf4cc40";\n\nJWT jwt = JWT.of(rightToken);\n\n// JWT\njwt.getHeader(JWTHeader.TYPE);\n// HS256\njwt.getHeader(JWTHeader.ALGORITHM);\n\n// 1234567890\njwt.getPayload("sub");\n// looly\njwt.getPayload("name");\n// true\njwt.getPayload("admin");\n\n\n\n# JWT验证\n\n 1. 验证签名\n\nString rightToken = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9." +\n\t"eyJzdWIiOiIxMjM0NTY3ODkwIiwiYWRtaW4iOnRydWUsIm5hbWUiOiJsb29seSJ9." +\n\t"536690902d931d857d2f47d337ec81048ee09a8e71866bcc8404edbbcbf4cc40";\n\n// 密钥\nbyte[] key = "1234567890".getBytes();\n\n// 默认验证HS256的算法\nJWT.of(rightToken).setKey(key).verify()\n\n\n 2. 详细验证\n\n除了验证签名，Hutool提供了更加详细的验证：validate，主要包括：\n\n * Token是否正确\n * 生效时间不能晚于当前时间\n * 失效时间不能早于当前时间\n * 签发时间不能晚于当前时间\n\n使用方式如下：\n\nString token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJNb0xpIiwiZXhwIjoxNjI0OTU4MDk0NTI4LCJpYXQiOjE2MjQ5NTgwMzQ1MjAsInVzZXIiOiJ1c2VyIn0.L0uB38p9sZrivbmP0VlDe--j_11YUXTu3TfHhfQhRKc";\n\nbyte[] key = "1234567890".getBytes();\n// 容忍时间，0秒\nboolean validate = JWT.of(token).setKey(key).validate(0);\n\n\n其他自定义详细验证见JWT验证-JWTValidator章节。',normalizedContent:'# 由来\n\n从5.7.0开始，hutool提供了零依赖的jwt（json web token）实现。\n\n\n# jwt介绍\n\n相关资料网络上非常多，可以自行搜索，简单点说jwt就是一种网络身份认证和信息交换格式。\n\n\n# 结构\n\n * header 头部信息，主要声明了jwt的签名算法等信息\n * payload 载荷信息，主要承载了各种声明并传递明文数据\n * signature 签名，拥有该部分的jwt被称为jws，也就是签了名的jwt，用于校验数据\n\n整体结构是：\n\nheader.payload.signature\n\n\n\n# 使用\n\njwt模块的核心主要是两个类：\n\n 1. jwt类用于链式生成、解析或验证jwt信息。\n 2. jwtutil类主要是jwt的一些工具封装，提供更加简洁的jwt生成、解析和验证工作\n\n\n# jwt生成\n\n 1. hs256(hmacsha256)算法\n\n// 密钥\nbyte[] key = "1234567890".getbytes();\n\nstring token = jwt.create()\n\t.setpayload("sub", "1234567890")\n\t.setpayload("name", "looly")\n\t.setpayload("admin", true)\n\t.setkey(key)\n\t.sign();\n\n\n生成的内容为：\n\neyj0exaioijkv1qilcjhbgcioijiuzi1nij9.eyjzdwiioiixmjm0nty3odkwiiwiywrtaw4ionrydwusim5hbwuioijsb29sesj9.536690902d931d857d2f47d337ec81048ee09a8e71866bcc8404edbbcbf4cc40\n\n\n 2. 其他算法\n\n// 密钥\nbyte[] key = "1234567890".getbytes();\n\n// sha256withrsa\nstring id = "rs256";\njwtsigner signer = jwtsignerutil.createsigner(id, \n\t// 随机生成密钥对，此处用户可自行读取`keypair`、公钥或私钥生成`jwtsigner`\n\tkeyutil.generatekeypair(algorithmutil.getalgorithm(id)));\n\nstring token = jwt.create()\n\t.setpayload("sub", "1234567890")\n\t.setpayload("name", "looly")\n\t.setpayload("admin", true)\n\t.setsigner(signer)\n\t.sign();\n\n\n 3. 不签名jwt\n\n// eyj0exaioijkv1qilcjhbgcioijiuzi1nij9.eyjzdwiioiixmjm0nty3odkwiiwiywrtaw4ionrydwusim5hbwuioijsb29sesj9.\nstring token = jwt.create()\n\t.setpayload("sub", "1234567890")\n\t.setpayload("name", "looly")\n\t.setpayload("admin", true)\n\t.setsigner(jwtsignerutil.none())\n\t.sign()\n\n\n\n# jwt解析\n\nstring righttoken = "eyj0exaioijkv1qilcjhbgcioijiuzi1nij9." +\n\t"eyjzdwiioiixmjm0nty3odkwiiwiywrtaw4ionrydwusim5hbwuioijsb29sesj9." +\n\t"536690902d931d857d2f47d337ec81048ee09a8e71866bcc8404edbbcbf4cc40";\n\njwt jwt = jwt.of(righttoken);\n\n// jwt\njwt.getheader(jwtheader.type);\n// hs256\njwt.getheader(jwtheader.algorithm);\n\n// 1234567890\njwt.getpayload("sub");\n// looly\njwt.getpayload("name");\n// true\njwt.getpayload("admin");\n\n\n\n# jwt验证\n\n 1. 验证签名\n\nstring righttoken = "eyj0exaioijkv1qilcjhbgcioijiuzi1nij9." +\n\t"eyjzdwiioiixmjm0nty3odkwiiwiywrtaw4ionrydwusim5hbwuioijsb29sesj9." +\n\t"536690902d931d857d2f47d337ec81048ee09a8e71866bcc8404edbbcbf4cc40";\n\n// 密钥\nbyte[] key = "1234567890".getbytes();\n\n// 默认验证hs256的算法\njwt.of(righttoken).setkey(key).verify()\n\n\n 2. 详细验证\n\n除了验证签名，hutool提供了更加详细的验证：validate，主要包括：\n\n * token是否正确\n * 生效时间不能晚于当前时间\n * 失效时间不能早于当前时间\n * 签发时间不能晚于当前时间\n\n使用方式如下：\n\nstring token = "eyj0exaioijkv1qilcjhbgcioijiuzi1nij9.eyjpc3mioijnb0xpiiwizxhwijoxnji0otu4mdk0nti4lcjpyxqioje2mjq5ntgwmzq1mjasinvzzxiioij1c2vyin0.l0ub38p9szrivbmp0vlde--j_11yuxtu3tfhhfqhrkc";\n\nbyte[] key = "1234567890".getbytes();\n// 容忍时间，0秒\nboolean validate = jwt.of(token).setkey(key).validate(0);\n\n\n其他自定义详细验证见jwt验证-jwtvalidator章节。',charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"流方式读取Excel2003-Excel03SaxReader",frontmatter:{title:"流方式读取Excel2003-Excel03SaxReader",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/Excel03SaxReader/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/16.Office%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C%EF%BC%88Hutool-poi%EF%BC%89/07.%E6%B5%81%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96Excel2003-Excel03SaxReader.html",relativePath:"01.指南/16.Office文档操作（Hutool-poi）/07.流方式读取Excel2003-Excel03SaxReader.md",key:"v-69a41f30",path:"/pages/Excel03SaxReader/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:136},{level:3,title:"定义行处理器",slug:"定义行处理器",normalizedTitle:"定义行处理器",charIndex:143},{level:3,title:"ExcelUtil快速读取",slug:"excelutil快速读取",normalizedTitle:"excelutil快速读取",charIndex:485},{level:3,title:"构建对象读取",slug:"构建对象读取",normalizedTitle:"构建对象读取",charIndex:560}],headersStr:"介绍 使用 定义行处理器 ExcelUtil快速读取 构建对象读取",content:'# 介绍\n\n在标准的ExcelReader中，如果数据量较大，读取Excel会非常缓慢，并有可能造成内存溢出。因此针对大数据量的Excel，Hutool封装了event模式的读取方式。\n\nExcel03SaxReader只支持Excel2003格式的Sax读取。\n\n\n# 使用\n\n\n# 定义行处理器\n\n首先我们实现一下RowHandler接口，这个接口是Sax读取的核心，通过实现handle方法编写我们要对每行数据的操作方式（比如按照行入库，入List或者写出到文件等），在此我们只是在控制台打印。\n\nprivate RowHandler createRowHandler() {\n\treturn new RowHandler() {\n\t\t@Override\n\t\tpublic void handle(int sheetIndex, long rowIndex, List<Object> rowlist) {\n\t\t\tConsole.log("[{}] [{}] {}", sheetIndex, rowIndex, rowlist);\n\t\t}\n\t};\n}\n\n\n\n# ExcelUtil快速读取\n\nExcelUtil.readBySax("https://doc.hutool.cn/assets/js/aaa.xls", 1, createRowHandler());\n\n\n\n# 构建对象读取\n\nExcel03SaxReader reader = new Excel03SaxReader(createRowHandler());\nreader.read("https://doc.hutool.cn/assets/js/aaa.xls", 0);\n\n\nreader方法的第二个参数是sheet的序号，-1表示读取所有sheet，0表示第一个sheet，依此类推。',normalizedContent:'# 介绍\n\n在标准的excelreader中，如果数据量较大，读取excel会非常缓慢，并有可能造成内存溢出。因此针对大数据量的excel，hutool封装了event模式的读取方式。\n\nexcel03saxreader只支持excel2003格式的sax读取。\n\n\n# 使用\n\n\n# 定义行处理器\n\n首先我们实现一下rowhandler接口，这个接口是sax读取的核心，通过实现handle方法编写我们要对每行数据的操作方式（比如按照行入库，入list或者写出到文件等），在此我们只是在控制台打印。\n\nprivate rowhandler createrowhandler() {\n\treturn new rowhandler() {\n\t\t@override\n\t\tpublic void handle(int sheetindex, long rowindex, list<object> rowlist) {\n\t\t\tconsole.log("[{}] [{}] {}", sheetindex, rowindex, rowlist);\n\t\t}\n\t};\n}\n\n\n\n# excelutil快速读取\n\nexcelutil.readbysax("https://doc.hutool.cn/assets/js/aaa.xls", 1, createrowhandler());\n\n\n\n# 构建对象读取\n\nexcel03saxreader reader = new excel03saxreader(createrowhandler());\nreader.read("https://doc.hutool.cn/assets/js/aaa.xls", 0);\n\n\nreader方法的第二个参数是sheet的序号，-1表示读取所有sheet，0表示第一个sheet，依此类推。',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"JWT工具-JWTUtil",frontmatter:{title:"JWT工具-JWTUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/JWTUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/20.JWT%EF%BC%88Hutool-jwt%EF%BC%89/02.JWT%E5%B7%A5%E5%85%B7-JWTUtil.html",relativePath:"01.指南/20.JWT（Hutool-jwt）/02.JWT工具-JWTUtil.md",key:"v-655373ba",path:"/pages/JWTUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:101}],headersStr:"介绍 使用",content:'# 介绍\n\n我们可以通过JWT实现链式创建JWT对象或JWT字符串，Hutool同样提供了一些快捷方法封装在JWTUtil中。主要包括：\n\n * JWT创建\n * JWT解析\n * JWT验证\n\n\n# 使用\n\n * JWT创建\n\nMap<String, Object> map = new HashMap<String, Object>() {\n\tprivate static final long serialVersionUID = 1L;\n\t{\n\t\tput("uid", Integer.parseInt("123"));\n\t\tput("expire_time", System.currentTimeMillis() + 1000 * 60 * 60 * 24 * 15);\n\t}\n};\n\nJWTUtil.createToken(map, "1234".getBytes());\n\n\n * JWT解析\n\nString rightToken = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9." +\n\t"eyJzdWIiOiIxMjM0NTY3ODkwIiwiYWRtaW4iOnRydWUsIm5hbWUiOiJsb29seSJ9." +\n\t"U2aQkC2THYV9L0fTN-yBBI7gmo5xhmvMhATtu8v0zEA";\n\nfinal JWT jwt = JWTUtil.parseToken(rightToken);\n\njwt.getHeader(JWTHeader.TYPE);\njwt.getPayload("sub");\n\n\n * JWT验证\n\nString token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9." +\n\t"eyJ1c2VyX25hbWUiOiJhZG1pbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2MjQwMDQ4MjIsInVzZXJJZCI6MSwiYXV0aG9yaXRpZXMiOlsiUk9MRV_op5LoibLkuozlj7ciLCJzeXNfbWVudV8xIiwiUk9MRV_op5LoibLkuIDlj7ciLCJzeXNfbWVudV8yIl0sImp0aSI6ImQ0YzVlYjgwLTA5ZTctNGU0ZC1hZTg3LTVkNGI5M2FhNmFiNiIsImNsaWVudF9pZCI6ImhhbmR5LXNob3AifQ." +\n\t"aixF1eKlAKS_k3ynFnStE7-IRGiD5YaqznvK2xEjBew";\n\nJWTUtil.verify(token, "123456".getBytes());\n',normalizedContent:'# 介绍\n\n我们可以通过jwt实现链式创建jwt对象或jwt字符串，hutool同样提供了一些快捷方法封装在jwtutil中。主要包括：\n\n * jwt创建\n * jwt解析\n * jwt验证\n\n\n# 使用\n\n * jwt创建\n\nmap<string, object> map = new hashmap<string, object>() {\n\tprivate static final long serialversionuid = 1l;\n\t{\n\t\tput("uid", integer.parseint("123"));\n\t\tput("expire_time", system.currenttimemillis() + 1000 * 60 * 60 * 24 * 15);\n\t}\n};\n\njwtutil.createtoken(map, "1234".getbytes());\n\n\n * jwt解析\n\nstring righttoken = "eyj0exaioijkv1qilcjhbgcioijiuzi1nij9." +\n\t"eyjzdwiioiixmjm0nty3odkwiiwiywrtaw4ionrydwusim5hbwuioijsb29sesj9." +\n\t"u2aqkc2thyv9l0ftn-ybbi7gmo5xhmvmhattu8v0zea";\n\nfinal jwt jwt = jwtutil.parsetoken(righttoken);\n\njwt.getheader(jwtheader.type);\njwt.getpayload("sub");\n\n\n * jwt验证\n\nstring token = "eyjhbgcioijiuzi1niisinr5cci6ikpxvcj9." +\n\t"eyj1c2vyx25hbwuioijhzg1pbiisinnjb3blijpbimfsbcjdlcjlehaioje2mjqwmdq4mjisinvzzxjjzci6mswiyxv0ag9yaxrpzxmiolsiuk9mrv_op5loiblkuozlj7cilcjzexnfbwvudv8xiiwiuk9mrv_op5loiblkuidlj7cilcjzexnfbwvudv8yil0simp0asi6imq0yzvlyjgwlta5ztctngu0zc1hztg3ltvkngi5m2fhnmfiniisimnsawvudf9pzci6imhhbmr5lxnob3aifq." +\n\t"aixf1eklaks_k3ynfnste7-irgid5yaqznvk2xejbew";\n\njwtutil.verify(token, "123456".getbytes());\n',charsets:{cjk:!0},lastUpdated:"2023/05/11, 20:08:21",lastUpdatedTimestamp:1683806901e3},{title:"JWT签名工具-JWTSignerUtil",frontmatter:{title:"JWT签名工具-JWTSignerUtil",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/JWTSignerUtil/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/20.JWT%EF%BC%88Hutool-jwt%EF%BC%89/03.JWT%E7%AD%BE%E5%90%8D%E5%B7%A5%E5%85%B7-JWTSignerUtil.html",relativePath:"01.指南/20.JWT（Hutool-jwt）/03.JWT签名工具-JWTSignerUtil.md",key:"v-2556fd3f",path:"/pages/JWTSignerUtil/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"对称签名",slug:"对称签名",normalizedTitle:"对称签名",charIndex:60},{level:3,title:"非对称签名",slug:"非对称签名",normalizedTitle:"非对称签名",charIndex:133},{level:3,title:"依赖于BounyCastle的算法",slug:"依赖于bounycastle的算法",normalizedTitle:"依赖于bounycastle的算法",charIndex:299},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:406},{level:3,title:"创建预定义算法签名器",slug:"创建预定义算法签名器",normalizedTitle:"创建预定义算法签名器",charIndex:413},{level:3,title:"创建自定义算法签名器",slug:"创建自定义算法签名器",normalizedTitle:"创建自定义算法签名器",charIndex:586},{level:3,title:"自行实现算法签名器",slug:"自行实现算法签名器",normalizedTitle:"自行实现算法签名器",charIndex:1043}],headersStr:"介绍 对称签名 非对称签名 依赖于BounyCastle的算法 使用 创建预定义算法签名器 创建自定义算法签名器 自行实现算法签名器",content:'# 介绍\n\nJWT签名算法比较多，主要分为非对称算法和对称算法，支持的算法定义在SignAlgorithm中。\n\n\n# 对称签名\n\n * HS256(HmacSHA256)\n * HS384(HmacSHA384)\n * HS512(HmacSHA512)\n\n\n# 非对称签名\n\n * RS256(SHA256withRSA)\n\n * RS384(SHA384withRSA)\n\n * RS512(SHA512withRSA)\n\n * ES256(SHA256withECDSA)\n\n * ES384(SHA384withECDSA)\n\n * ES512(SHA512withECDSA)\n\n\n# 依赖于BounyCastle的算法\n\n * PS256(SHA256WithRSA/PSS)\n * PS384(SHA384WithRSA/PSS)\n * PS512(SHA512WithRSA/PSS)\n\n\n# 使用\n\n\n# 创建预定义算法签名器\n\nJWTSignerUtil中预定义了一些算法的签名器的创建方法，如创建HS256的签名器：\n\nfinal JWTSigner signer = JWTSignerUtil.hs256("123456".getBytes());\nJWT jwt = JWT.create().setSigner(signer);\n\n\n\n# 创建自定义算法签名器\n\n通过JWTSignerUtil.createSigner即可通过动态传入algorithmId创建对应的签名器，如我们如果需要实现ps256算法，则首先引入bcprov-jdk15to18包：\n\n<dependency>\n\t<groupId>org.bouncycastle</groupId>\n\t<artifactId>bcpkix-jdk18on</artifactId>\n\t<version>${bouncycastle.version}</version>\n</dependency>\n\n\n再创建对应签名器即可：\n\nString id = "ps256";\nfinal JWTSigner signer = JWTSignerUtil.createSigner(id, KeyUtil.generateKeyPair(AlgorithmUtil.getAlgorithm(id)));\n\nJWT jwt = JWT.create().setSigner(signer);\n\n\n\n# 自行实现算法签名器\n\nJWTSigner接口是一个通用的签名器接口，如果想实现自定义算法，实现此接口即可。',normalizedContent:'# 介绍\n\njwt签名算法比较多，主要分为非对称算法和对称算法，支持的算法定义在signalgorithm中。\n\n\n# 对称签名\n\n * hs256(hmacsha256)\n * hs384(hmacsha384)\n * hs512(hmacsha512)\n\n\n# 非对称签名\n\n * rs256(sha256withrsa)\n\n * rs384(sha384withrsa)\n\n * rs512(sha512withrsa)\n\n * es256(sha256withecdsa)\n\n * es384(sha384withecdsa)\n\n * es512(sha512withecdsa)\n\n\n# 依赖于bounycastle的算法\n\n * ps256(sha256withrsa/pss)\n * ps384(sha384withrsa/pss)\n * ps512(sha512withrsa/pss)\n\n\n# 使用\n\n\n# 创建预定义算法签名器\n\njwtsignerutil中预定义了一些算法的签名器的创建方法，如创建hs256的签名器：\n\nfinal jwtsigner signer = jwtsignerutil.hs256("123456".getbytes());\njwt jwt = jwt.create().setsigner(signer);\n\n\n\n# 创建自定义算法签名器\n\n通过jwtsignerutil.createsigner即可通过动态传入algorithmid创建对应的签名器，如我们如果需要实现ps256算法，则首先引入bcprov-jdk15to18包：\n\n<dependency>\n\t<groupid>org.bouncycastle</groupid>\n\t<artifactid>bcpkix-jdk18on</artifactid>\n\t<version>${bouncycastle.version}</version>\n</dependency>\n\n\n再创建对应签名器即可：\n\nstring id = "ps256";\nfinal jwtsigner signer = jwtsignerutil.createsigner(id, keyutil.generatekeypair(algorithmutil.getalgorithm(id)));\n\njwt jwt = jwt.create().setsigner(signer);\n\n\n\n# 自行实现算法签名器\n\njwtsigner接口是一个通用的签名器接口，如果想实现自定义算法，实现此接口即可。',charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"JWT验证-JWTValidator",frontmatter:{title:"JWT验证-JWTValidator",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/JWTValidator/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/20.JWT%EF%BC%88Hutool-jwt%EF%BC%89/04.JWT%E9%AA%8C%E8%AF%81-JWTValidator.html",relativePath:"01.指南/20.JWT（Hutool-jwt）/04.JWT验证-JWTValidator.md",key:"v-798cb182",path:"/pages/JWTValidator/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:56},{level:3,title:"验证算法",slug:"验证算法",normalizedTitle:"验证算法",charIndex:85},{level:3,title:"验证时间",slug:"验证时间",normalizedTitle:"验证时间",charIndex:382}],headersStr:"介绍 使用 验证算法 验证时间",content:'# 介绍\n\n由于JWT.verify，只能验证JWT Token的签名是否有效，其他payload字段验证都可以使用JWTValidator完成。\n\n\n# 使用\n\n\n# 验证算法\n\n算法的验证包括两个方面\n\n 1. 验证header中算法ID和提供的算法ID是否一致\n 2. 调用JWT.verify验证token是否正确\n\n// 创建JWT Token\nfinal String token = JWT.create()\n\t.setNotBefore(DateUtil.date())\n\t.setKey("123456".getBytes())\n\t.sign();\n\n// 验证算法\nJWTValidator.of(token).validateAlgorithm(JWTSignerUtil.hs256("123456".getBytes()));\n\n\n\n# 验证时间\n\n对于时间类载荷，有单独的验证方法，主要包括：\n\n * 生效时间（JWTPayload.NOT_BEFORE）不能晚于当前时间\n * 失效时间（JWTPayload.EXPIRES_AT）不能早于当前时间\n * 签发时间（JWTPayload.ISSUED_AT）不能晚于当前时间\n\n一般时间线是：\n\n(签发时间)---------(生效时间)---------(当前时间)---------(失效时间)\n\n> 签发时间和生效时间一般没有前后要求，都早于当前时间即可。\n\nfinal String token = JWT.create()\n\t// 设置签发时间\n\t.setIssuedAt(DateUtil.date())\n\t.setKey("123456".getBytes())\n\t.sign();\n\n// 由于只定义了签发时间，因此只检查签发时间\nJWTValidator.of(token).validateDate(DateUtil.date());\n',normalizedContent:'# 介绍\n\n由于jwt.verify，只能验证jwt token的签名是否有效，其他payload字段验证都可以使用jwtvalidator完成。\n\n\n# 使用\n\n\n# 验证算法\n\n算法的验证包括两个方面\n\n 1. 验证header中算法id和提供的算法id是否一致\n 2. 调用jwt.verify验证token是否正确\n\n// 创建jwt token\nfinal string token = jwt.create()\n\t.setnotbefore(dateutil.date())\n\t.setkey("123456".getbytes())\n\t.sign();\n\n// 验证算法\njwtvalidator.of(token).validatealgorithm(jwtsignerutil.hs256("123456".getbytes()));\n\n\n\n# 验证时间\n\n对于时间类载荷，有单独的验证方法，主要包括：\n\n * 生效时间（jwtpayload.not_before）不能晚于当前时间\n * 失效时间（jwtpayload.expires_at）不能早于当前时间\n * 签发时间（jwtpayload.issued_at）不能晚于当前时间\n\n一般时间线是：\n\n(签发时间)---------(生效时间)---------(当前时间)---------(失效时间)\n\n> 签发时间和生效时间一般没有前后要求，都早于当前时间即可。\n\nfinal string token = jwt.create()\n\t// 设置签发时间\n\t.setissuedat(dateutil.date())\n\t.setkey("123456".getbytes())\n\t.sign();\n\n// 由于只定义了签发时间，因此只检查签发时间\njwtvalidator.of(token).validatedate(dateutil.date());\n',charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"核心（Hutool-core）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/02.核心（Hutool-core）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"Hutool核心方法及数据结构包"}},title:"核心（Hutool-core）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/core/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/02.%E6%A0%B8%E5%BF%83%EF%BC%88Hutool-core%EF%BC%89.html",relativePath:"02.模块/02.核心（Hutool-core）.md",key:"v-9ec23b3a",path:"/module/core/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"AIO封装-AioServer和AioClient",frontmatter:{title:"AIO封装-AioServer和AioClient",date:"2023-03-28T18:39:47.000Z",permalink:"/pages/AioServer/"},regularPath:"https://doc.hutool.cn/01.%E6%8C%87%E5%8D%97/19.%E7%BD%91%E7%BB%9CSocket%EF%BC%88Hutool-socket%EF%BC%89/02.AIO%E5%B0%81%E8%A3%85-AioServer%E5%92%8CAioClient.html",relativePath:"01.指南/19.网络Socket（Hutool-socket）/02.AIO封装-AioServer和AioClient.md",key:"v-2fd09e57",path:"/pages/AioServer/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:54},{level:3,title:"服务端",slug:"服务端",normalizedTitle:"服务端",charIndex:61},{level:3,title:"客户端",slug:"客户端",normalizedTitle:"客户端",charIndex:229}],headersStr:"由来 使用 服务端 客户端",content:'# 由来\n\n在JDK7+后，提供了异步Socket库——AIO，Hutool对其进行了简单的封装。\n\n\n# 使用\n\n\n# 服务端\n\nAioServer aioServer = new AioServer(8899);\naioServer.setIoAction(new SimpleIoAction() {\n\t\n\t@Override\n\tpublic void accept(AioSession session) {\n\t\tStaticLog.debug("【客户端】：{} 连接。", session.getRemoteAddress());\n\t\tsession.write(BufferUtil.createUtf8("=== Welcome to Hutool socket server. ==="));\n\t}\n\t\n\t@Override\n\tpublic void doAction(AioSession session, ByteBuffer data) {\n\t\tConsole.log(data);\n\t\t\n\t\tif(false == data.hasRemaining()) {\n\t\t\tStringBuilder response = StrUtil.builder()//\n\t\t\t\t\t.append("HTTP/1.1 200 OK\\r\\n")//\n\t\t\t\t\t.append("Date: ").append(DateUtil.formatHttpDate(DateUtil.date())).append("\\r\\n")//\n\t\t\t\t\t.append("Content-Type: text/html; charset=UTF-8\\r\\n")//\n\t\t\t\t\t.append("\\r\\n")\n\t\t\t\t\t.append("Hello Hutool socket");//\n\t\t\tsession.writeAndClose(BufferUtil.createUtf8(response));\n\t\t}else {\n\t\t\tsession.read();\n\t\t}\n\t}\n}).start(true);\n\n\n\n# 客户端\n\nfinal AsynchronousChannelGroup GROUP = AsynchronousChannelGroup.withFixedThreadPool(//\n\t\tRuntime.getRuntime().availableProcessors(), // 默认线程池大小\n\t\tThreadFactoryBuilder.create().setNamePrefix("Huool-socket-").build()//\n);\n\nAsynchronousSocketChannel channel;\ntry {\n\tchannel = AsynchronousSocketChannel.open(GROUP);\n} catch (IOException e) {\n\tthrow new IORuntimeException(e);\n}\ntry {\n\tchannel.connect(new InetSocketAddress("localhost", 8899)).get();\n} catch (InterruptedException | ExecutionException e) {\n\tIoUtil.close(channel);\n\tthrow new SocketRuntimeException(e);\n}\n\nAioClient client = new AioClient(channel, new SimpleIoAction() {\n\t\n\t@Override\n\tpublic void doAction(AioSession session, ByteBuffer data) {\n\t\tif(data.hasRemaining()) {\n\t\t\tConsole.log(StrUtil.utf8Str(data));\n\t\t\tsession.read();\n\t\t}\n\t\tConsole.log("OK");\n\t}\n});\n\nclient.write(ByteBuffer.wrap("Hello".getBytes()));\nclient.read();\n\nclient.close();\n\n\n> > 注意： GROUP维护一个连接池，建议全局单例持有。 见：issues/I56SYG',normalizedContent:'# 由来\n\n在jdk7+后，提供了异步socket库——aio，hutool对其进行了简单的封装。\n\n\n# 使用\n\n\n# 服务端\n\naioserver aioserver = new aioserver(8899);\naioserver.setioaction(new simpleioaction() {\n\t\n\t@override\n\tpublic void accept(aiosession session) {\n\t\tstaticlog.debug("【客户端】：{} 连接。", session.getremoteaddress());\n\t\tsession.write(bufferutil.createutf8("=== welcome to hutool socket server. ==="));\n\t}\n\t\n\t@override\n\tpublic void doaction(aiosession session, bytebuffer data) {\n\t\tconsole.log(data);\n\t\t\n\t\tif(false == data.hasremaining()) {\n\t\t\tstringbuilder response = strutil.builder()//\n\t\t\t\t\t.append("http/1.1 200 ok\\r\\n")//\n\t\t\t\t\t.append("date: ").append(dateutil.formathttpdate(dateutil.date())).append("\\r\\n")//\n\t\t\t\t\t.append("content-type: text/html; charset=utf-8\\r\\n")//\n\t\t\t\t\t.append("\\r\\n")\n\t\t\t\t\t.append("hello hutool socket");//\n\t\t\tsession.writeandclose(bufferutil.createutf8(response));\n\t\t}else {\n\t\t\tsession.read();\n\t\t}\n\t}\n}).start(true);\n\n\n\n# 客户端\n\nfinal asynchronouschannelgroup group = asynchronouschannelgroup.withfixedthreadpool(//\n\t\truntime.getruntime().availableprocessors(), // 默认线程池大小\n\t\tthreadfactorybuilder.create().setnameprefix("huool-socket-").build()//\n);\n\nasynchronoussocketchannel channel;\ntry {\n\tchannel = asynchronoussocketchannel.open(group);\n} catch (ioexception e) {\n\tthrow new ioruntimeexception(e);\n}\ntry {\n\tchannel.connect(new inetsocketaddress("localhost", 8899)).get();\n} catch (interruptedexception | executionexception e) {\n\tioutil.close(channel);\n\tthrow new socketruntimeexception(e);\n}\n\naioclient client = new aioclient(channel, new simpleioaction() {\n\t\n\t@override\n\tpublic void doaction(aiosession session, bytebuffer data) {\n\t\tif(data.hasremaining()) {\n\t\t\tconsole.log(strutil.utf8str(data));\n\t\t\tsession.read();\n\t\t}\n\t\tconsole.log("ok");\n\t}\n});\n\nclient.write(bytebuffer.wrap("hello".getbytes()));\nclient.read();\n\nclient.close();\n\n\n> > 注意： group维护一个连接池，建议全局单例持有。 见：issues/i56syg',charsets:{cjk:!0},lastUpdated:"2023/10/26, 14:10:35",lastUpdatedTimestamp:1698300635e3},{title:"配置文件(Hutool-setting）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/03.配置文件(Hutool-setting）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"Setting模块主要针对Properties文件读写做封装，同时定义一套自己的配置文件规范，实现兼容性良好的配置工具。"}},title:"配置文件(Hutool-setting）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/setting/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/03.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6(Hutool-setting%EF%BC%89.html",relativePath:"02.模块/03.配置文件(Hutool-setting）.md",key:"v-f72692ce",path:"/module/setting/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"日志（Hutool-log）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/04.日志（Hutool-log）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"Hutool-log只是一个日志的通用门面，功能类似于Slf4j。"}},title:"日志（Hutool-log）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/log/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/04.%E6%97%A5%E5%BF%97%EF%BC%88Hutool-log%EF%BC%89.html",relativePath:"02.模块/04.日志（Hutool-log）.md",key:"v-874a2d94",path:"/module/log/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"缓存（Hutool-cache）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/05.缓存（Hutool-cache）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"提供简易的缓存实现，此模块参考了jodd工具中的Cache模块"}},title:"缓存（Hutool-cache）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/cache/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/05.%E7%BC%93%E5%AD%98%EF%BC%88Hutool-cache%EF%BC%89.html",relativePath:"02.模块/05.缓存（Hutool-cache）.md",key:"v-7be0cdab",path:"/module/cache/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"JSON（Hutool-json）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/06.JSON（Hutool-json）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"JSON封装，基于json.org官方库改造"}},title:"JSON（Hutool-json）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/json/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/06.JSON%EF%BC%88Hutool-json%EF%BC%89.html",relativePath:"02.模块/06.JSON（Hutool-json）.md",key:"v-1237f2a3",path:"/module/json/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"加密解密（Hutool-crypto）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/07.加密解密（Hutool-crypto）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"加密解密模块，实现了对JDK中加密解密算法的封装，入口为SecureUtil"}},title:"加密解密（Hutool-crypto）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/crypto/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/07.%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%EF%BC%88Hutool-crypto%EF%BC%89.html",relativePath:"02.模块/07.加密解密（Hutool-crypto）.md",key:"v-cd5eb84e",path:"/module/crypto/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"DFA查找（Hutool-dfa）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/08.DFA查找（Hutool-dfa）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"DFA全称为：Deterministic Finite Automaton,即确定有穷自动机。"}},title:"DFA查找（Hutool-dfa）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/dfa/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/08.DFA%E6%9F%A5%E6%89%BE%EF%BC%88Hutool-dfa%EF%BC%89.html",relativePath:"02.模块/08.DFA查找（Hutool-dfa）.md",key:"v-ef8cee36",path:"/module/dfa/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"数据库（Hutool-db）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/09.数据库（Hutool-db）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"Hutool-db是一个在JDBC基础上封装的数据库操作工具类，通过包装，使用ActiveRecord思想操作数据库。"}},title:"数据库（Hutool-db）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/db/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/09.%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hutool-db%EF%BC%89.html",relativePath:"02.模块/09.数据库（Hutool-db）.md",key:"v-503f4502",path:"/module/db/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"HTTP客户端（Hutool-http）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/10.HTTP客户端（Hutool-http）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"Hutool-http针对JDK的HttpUrlConnection做一层封装，简化了HTTPS请求、文件上传、Cookie记忆等操作，使Http请求变得无比简单。"}},title:"HTTP客户端（Hutool-http）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/http/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/10.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Hutool-http%EF%BC%89.html",relativePath:"02.模块/10.HTTP客户端（Hutool-http）.md",key:"v-7f839c76",path:"/module/http/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"定时任务（Hutool-cron）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/11.定时任务（Hutool-cron）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"定时任务模块，提供类Crontab表达式的定时任务，实现参考了Cron4j，同时可以支持秒级别的定时任务定义和年的定义（同时兼容Crontab、Cron4j、Quartz表达式）"}},title:"定时任务（Hutool-cron）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/cron/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/11.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88Hutool-cron%EF%BC%89.html",relativePath:"02.模块/11.定时任务（Hutool-cron）.md",key:"v-573468e8",path:"/module/cron/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"扩展（Hutool-extra）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/12.扩展（Hutool-extra）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"由于Hutool的原则是不依赖于其它配置文件，但是很多时候我们需要针对第三方非常棒的库做一些工具类化的支持，因此Hutoo-extra包主要用于支持第三方库的工具类支持。"}},title:"扩展（Hutool-extra）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/extra/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/12.%E6%89%A9%E5%B1%95%EF%BC%88Hutool-extra%EF%BC%89.html",relativePath:"02.模块/12.扩展（Hutool-extra）.md",key:"v-4a94ddbe",path:"/module/extra/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"布隆过滤（Hutool-bloomFilter）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/13.布隆过滤（Hutool-bloomFilter）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"布隆过滤，提供一些Hash算法的布隆过滤"}},title:"布隆过滤（Hutool-bloomFilter）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/bloomFilter/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/13.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%EF%BC%88Hutool-bloomFilter%EF%BC%89.html",relativePath:"02.模块/13.布隆过滤（Hutool-bloomFilter）.md",key:"v-034cfd88",path:"/module/bloomFilter/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"脚本（Hutool-script）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/15.脚本（Hutool-script）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"Script模块主要针对Java的javax.script封装，可以运行Javascript脚本。"}},title:"脚本（Hutool-script）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/script/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/15.%E8%84%9A%E6%9C%AC%EF%BC%88Hutool-script%EF%BC%89.html",relativePath:"02.模块/15.脚本（Hutool-script）.md",key:"v-755203b9",path:"/module/script/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"图形验证码（Hutool-captcha）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/18.图形验证码（Hutool-captcha）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"图片验证码实现"}},title:"图形验证码（Hutool-captcha）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/captcha/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/18.%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%88Hutool-captcha%EF%BC%89.html",relativePath:"02.模块/18.图形验证码（Hutool-captcha）.md",key:"v-6565e77a",path:"/module/captcha/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"JWT（Hutool-jwt）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/20.JWT（Hutool-jwt）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"JSON Web Token (JWT)封装"}},title:"JWT（Hutool-jwt）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/jwt/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/20.JWT%EF%BC%88Hutool-jwt%EF%BC%89.html",relativePath:"02.模块/20.JWT（Hutool-jwt）.md",key:"v-559e6da6",path:"/module/jwt/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"系统调用（Hutool-system）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/17.系统调用（Hutool-system）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"System模块主要获取系统、JVM、内存、CPU等信息，以便动态监测系统状态"}},title:"系统调用（Hutool-system）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/system/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/17.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88Hutool-system%EF%BC%89.html",relativePath:"02.模块/17.系统调用（Hutool-system）.md",key:"v-7930af96",path:"/module/system/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"支持这个项目",frontmatter:{title:"支持这个项目",permalink:"/pages/support/",date:"2023-04-06T20:07:31.000Z",sidebar:!1,article:!1,editLink:!1},regularPath:"https://doc.hutool.cn/03.%E6%94%AF%E6%8C%81/01.%E6%94%AF%E6%8C%81.html",relativePath:"03.支持/01.支持.md",key:"v-71bbe5a6",path:"/pages/support/",headers:[{level:3,title:"📢成为赞助商",slug:"📢成为赞助商",normalizedTitle:"📢成为赞助商",charIndex:2},{level:3,title:"💳捐赠",slug:"💳捐赠",normalizedTitle:"💳捐赠",charIndex:217},{level:3,title:"👕周边商店",slug:"👕周边商店",normalizedTitle:"👕周边商店",charIndex:276}],headersStr:"📢成为赞助商 💳捐赠 👕周边商店",content:"# 📢成为赞助商\n\n现今，Hutool成为众多开发者选择的类库之一，Hutool官网及其文档也成为大家不可或缺的资源。\n\n如果希望你的产品或品牌在Hutool官网和文档中展示，可以成为我们的赞助商，即产品标识可以在如下位置展示：\n\n * Hutool主页的“特别赞助”位置\n * Hutool中部的banner\n * Hutool文档页顶部\n\n你可以通过如下方式与我们联系：\n\n👉微信：hutool（添加请注明赞助联络）\n\n\n# 💳捐赠\n\n如果你觉得Hutool不错，可以捐赠请维护者吃包辣条~，在此表示感谢^_^。\n\nGitee上捐赠\n\n\n# 👕周边商店\n\n你也可以通过购买Hutool的周边商品来支持Hutool维护哦！\n\n我们提供了印有Hutool Logo的周边商品，欢迎点击购买支持：\n\n👉 Hutool 周边商店 👈",normalizedContent:"# 📢成为赞助商\n\n现今，hutool成为众多开发者选择的类库之一，hutool官网及其文档也成为大家不可或缺的资源。\n\n如果希望你的产品或品牌在hutool官网和文档中展示，可以成为我们的赞助商，即产品标识可以在如下位置展示：\n\n * hutool主页的“特别赞助”位置\n * hutool中部的banner\n * hutool文档页顶部\n\n你可以通过如下方式与我们联系：\n\n👉微信：hutool（添加请注明赞助联络）\n\n\n# 💳捐赠\n\n如果你觉得hutool不错，可以捐赠请维护者吃包辣条~，在此表示感谢^_^。\n\ngitee上捐赠\n\n\n# 👕周边商店\n\n你也可以通过购买hutool的周边商品来支持hutool维护哦！\n\n我们提供了印有hutool logo的周边商品，欢迎点击购买支持：\n\n👉 hutool 周边商店 👈",charsets:{cjk:!0},lastUpdated:"2023/05/08, 01:55:50",lastUpdatedTimestamp:168348215e4},{title:"知识星球",frontmatter:{title:"知识星球",permalink:"/pages/KnowledgePlanet/",date:"2023-04-06T20:07:31.000Z",sidebar:!1,article:!1,editLink:!1},regularPath:"https://doc.hutool.cn/04.%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83/01.%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83.html",relativePath:"https://doc.hutool.cn/assets/js/04.知识星球/01.知识星球.md",key:"v-e35e4bc0",path:"/pages/KnowledgePlanet/",headers:[{level:3,title:"📢Hutool程序员社区",slug:"📢hutool程序员社区",normalizedTitle:"📢hutool程序员社区",charIndex:2},{level:4,title:"我们是谁？",slug:"我们是谁",normalizedTitle:"我们是谁？",charIndex:19},{level:4,title:"Hutool为什么要搞知识星球？",slug:"hutool为什么要搞知识星球",normalizedTitle:"hutool为什么要搞知识星球？",charIndex:244},{level:4,title:"Hutool 知识星球提供什么服务？",slug:"hutool-知识星球提供什么服务",normalizedTitle:"hutool 知识星球提供什么服务？",charIndex:331},{level:4,title:"谁需要加入星球？",slug:"谁需要加入星球",normalizedTitle:"谁需要加入星球？",charIndex:565},{level:4,title:"谁不需要加入星球",slug:"谁不需要加入星球",normalizedTitle:"谁不需要加入星球",charIndex:731},{level:4,title:"最后给小白一点点建议",slug:"最后给小白一点点建议",normalizedTitle:"最后给小白一点点建议",charIndex:838},{level:4,title:"专属项目",slug:"专属项目",normalizedTitle:"专属项目",charIndex:974},{level:3,title:"两种加入星球的方法：",slug:"两种加入星球的方法",normalizedTitle:"两种加入星球的方法：",charIndex:1180},{level:4,title:"免费：",slug:"免费",normalizedTitle:"免费：",charIndex:1194},{level:4,title:"收费：",slug:"收费",normalizedTitle:"收费：",charIndex:1376}],headersStr:"📢Hutool程序员社区 我们是谁？ Hutool为什么要搞知识星球？ Hutool 知识星球提供什么服务？ 谁需要加入星球？ 谁不需要加入星球 最后给小白一点点建议 专属项目 两种加入星球的方法： 免费： 收费：",content:"# 📢Hutool程序员社区\n\n# 我们是谁？\n\nHutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。\n\n大家可以看看我们的github星星的数量，在不强制要求给star的情况下， 我们有27.6k。\n\n星球好评也有很多，请大家放心我们的实力。\n\n\n\n我们会持续为大家提供优质的服务，也希望大家一起来星球聊天，分享自己的知识，交交朋友，共同学习进步。 抱团取暖！\n\n# Hutool为什么要搞知识星球？\n\nHutool是一个开源软件，目前只有官网广告收入。 我们软件开源了， 也需要在收入上进行“开源节流“。\n\n因此开通了付费知识星球。\n\n# Hutool 知识星球提供什么服务？\n\n 1. Hutool使用方法问答。 经常有程序员在群里问Hutool有没有某某功能，Hutool某某功能怎么使用等等。 星球可以提供这方面的服务。\n 2. Sloth脚手架，现在正在开发中。 https://sloth.hutool.cn 为预览地址，代码在星球中。 我们会一直迭代开发。\n 3. 电商系统， 正在开发。 https://mall.hutool.cn/index, 代码在星球中。 暂定计划是每周一提交。\n\n# 谁需要加入星球？\n\n 1. 愿意支持Hutool的朋友们，可以把他看作一种捐赠行为。如果你觉得Hutool不错，可以给我们捐赠一下。\n 2. 开发新人使用Hutool过程不是很顺利，可以加入星球寻求帮助。\n 3. 想要使用一个脚手架开发项目，Sloth可以做为一个选择。\n 4. 想要学习一个电商系统。 也是可以加入我们的。\n\n# 谁不需要加入星球\n\n 1. Hutool有比较完整的文档和免费的QQ群，如果你能够正常使用Hutool完成工作就不需要加入星球。\n 2. 对星球期望过高的小伙伴， 我们不是万能的，没有办法给你解决所有问题。\n\n# 最后给小白一点点建议\n\n近年知识付费很火，但水平参差不齐， 如果你想从零入门java开发。 B站是一个很好的平台， 一些传统大型的机构都在上面开课。他们在教育行业深耕多年，还是非常有水平的。 希望大家擦亮双眼。\n\n最近祝大家2024年大吉大利，身体健康，万事如意。\n\n# 专属项目\n\n 1. 项目一： 脚手架\n\n技术方案springboot3+react组合\n\n项目地址： sloth脚手架\n\n 2. 项目二： 电商系统\n    \n    项目地址： Hutool电商\n    \n    我们的目标是替换掉现在正在使用的第三方系统的周边商店，开发一个自己的系统。 做一个真实可以交易的电商系统。大学生们可以用来做毕设，刚入职场的新手可以学习一下。 暂定计划是每周一迭代。\n\n\n\n\n# 两种加入星球的方法：\n\n# 免费：\n\n如果你的hutool的开源贡献者， 哪怕是只提交过一段代码就可以免费加入星球。\n\n加入方式请加我微信：canghaihongxin 并且注明来意“hutool开源贡献者，加入星球”。 我会给你邀请链接，名额只有80个，先到先得。\n\n注：三个月不活跃就会被移除（如果三个月不活跃了，大概率是不想和我们交流了， 那就把位置让给那些还想和我交流的人哈）\n\n# 收费：\n\n请使用微信扫描二维码，即可加入我们。\n\n",normalizedContent:"# 📢hutool程序员社区\n\n# 我们是谁？\n\nhutool是一个小而全的java工具类库，通过静态方法封装，降低相关api的学习成本，提高工作效率，使java拥有函数式语言般的优雅，让java语言也可以“甜甜的”。\n\n大家可以看看我们的github星星的数量，在不强制要求给star的情况下， 我们有27.6k。\n\n星球好评也有很多，请大家放心我们的实力。\n\n\n\n我们会持续为大家提供优质的服务，也希望大家一起来星球聊天，分享自己的知识，交交朋友，共同学习进步。 抱团取暖！\n\n# hutool为什么要搞知识星球？\n\nhutool是一个开源软件，目前只有官网广告收入。 我们软件开源了， 也需要在收入上进行“开源节流“。\n\n因此开通了付费知识星球。\n\n# hutool 知识星球提供什么服务？\n\n 1. hutool使用方法问答。 经常有程序员在群里问hutool有没有某某功能，hutool某某功能怎么使用等等。 星球可以提供这方面的服务。\n 2. sloth脚手架，现在正在开发中。 https://sloth.hutool.cn 为预览地址，代码在星球中。 我们会一直迭代开发。\n 3. 电商系统， 正在开发。 https://mall.hutool.cn/index, 代码在星球中。 暂定计划是每周一提交。\n\n# 谁需要加入星球？\n\n 1. 愿意支持hutool的朋友们，可以把他看作一种捐赠行为。如果你觉得hutool不错，可以给我们捐赠一下。\n 2. 开发新人使用hutool过程不是很顺利，可以加入星球寻求帮助。\n 3. 想要使用一个脚手架开发项目，sloth可以做为一个选择。\n 4. 想要学习一个电商系统。 也是可以加入我们的。\n\n# 谁不需要加入星球\n\n 1. hutool有比较完整的文档和免费的qq群，如果你能够正常使用hutool完成工作就不需要加入星球。\n 2. 对星球期望过高的小伙伴， 我们不是万能的，没有办法给你解决所有问题。\n\n# 最后给小白一点点建议\n\n近年知识付费很火，但水平参差不齐， 如果你想从零入门java开发。 b站是一个很好的平台， 一些传统大型的机构都在上面开课。他们在教育行业深耕多年，还是非常有水平的。 希望大家擦亮双眼。\n\n最近祝大家2024年大吉大利，身体健康，万事如意。\n\n# 专属项目\n\n 1. 项目一： 脚手架\n\n技术方案springboot3+react组合\n\n项目地址： sloth脚手架\n\n 2. 项目二： 电商系统\n    \n    项目地址： hutool电商\n    \n    我们的目标是替换掉现在正在使用的第三方系统的周边商店，开发一个自己的系统。 做一个真实可以交易的电商系统。大学生们可以用来做毕设，刚入职场的新手可以学习一下。 暂定计划是每周一迭代。\n\n\n\n\n# 两种加入星球的方法：\n\n# 免费：\n\n如果你的hutool的开源贡献者， 哪怕是只提交过一段代码就可以免费加入星球。\n\n加入方式请加我微信：canghaihongxin 并且注明来意“hutool开源贡献者，加入星球”。 我会给你邀请链接，名额只有80个，先到先得。\n\n注：三个月不活跃就会被移除（如果三个月不活跃了，大概率是不想和我们交流了， 那就把位置让给那些还想和我交流的人哈）\n\n# 收费：\n\n请使用微信扫描二维码，即可加入我们。\n\n",charsets:{cjk:!0},lastUpdated:"2024/11/02, 21:06:45",lastUpdatedTimestamp:1730552805e3},{title:"网络Socket（Hutool-socket）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/19.网络Socket（Hutool-socket）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"Socket套接字相关工具类封装"}},title:"网络Socket（Hutool-socket）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/socket/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/19.%E7%BD%91%E7%BB%9CSocket%EF%BC%88Hutool-socket%EF%BC%89.html",relativePath:"02.模块/19.网络Socket（Hutool-socket）.md",key:"v-7d9c622a",path:"/module/socket/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"Office文档操作（Hutool-poi）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/16.Office文档操作（Hutool-poi）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"Hutool针对POI封装一些常用工具，使Java操作Excel等文件变得异常简单。"}},title:"Office文档操作（Hutool-poi）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/poi/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/16.Office%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C%EF%BC%88Hutool-poi%EF%BC%89.html",relativePath:"02.模块/16.Office文档操作（Hutool-poi）.md",key:"v-73864004",path:"/module/poi/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"切面（Hutool-aop）",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.指南/14.切面（Hutool-aop）",imgUrl:"../../img/logo_small.jpg"/*tpa=https://doc.hutool.cn/img/logo_small.jpg*/,description:"JDK动态代理封装，提供非IOC下的切面支持"}},title:"切面（Hutool-aop）",date:"2023-04-04T23:00:00.000Z",permalink:"/module/aop/",article:!1,comment:!1,editLink:!1,author:{name:"Hutool",link:"https://hutool.cn/"}},regularPath:"https://doc.hutool.cn/02.%E6%A8%A1%E5%9D%97/14.%E5%88%87%E9%9D%A2%EF%BC%88Hutool-aop%EF%BC%89.html",relativePath:"02.模块/14.切面（Hutool-aop）.md",key:"v-5f539617",path:"/module/aop/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 10:53:43",lastUpdatedTimestamp:1700708023e3},{title:"博客文章",frontmatter:{archivesPage:!0,title:"博客文章",permalink:"/blog/",article:!1},regularPath:"https://doc.hutool.cn/@pages/archivesPage.html",relativePath:"https://doc.hutool.cn/assets/js/@pages/archivesPage.md",key:"v-39a42cf8",path:"/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/05/08, 01:55:50",lastUpdatedTimestamp:168348215e4},{title:"Home",frontmatter:{home:!0,heroImage:"https://plus.hutool.cn/images/hutool.svg",tagline:"🚀A set of tools that keep Java sweet.",actionText:"快速开始 →",actionLink:"/pages/index/",bannerBg:"none",postList:"none"},regularPath:"/",relativePath:"https://doc.hutool.cn/assets/js/index.md",key:"v-61189df0",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/05/08, 01:55:50",lastUpdatedTimestamp:168348215e4}],themeConfig:{nav:[{text:"🏡首页",link:"/"},{text:"📖指南",link:"/pages/index/"},{text:"📚模块",link:"/module/core/",items:[{text:"核心(Hutool-core)",link:"/module/core/"},{text:"配置文件(Hutool-setting)",link:"/module/setting/"},{text:"日志(Hutool-log)",link:"/module/log/"},{text:"缓存(Hutool-cache)",link:"/module/cache/"},{text:"JSON(Hutool-json)",link:"/module/json/"},{text:"加密解密(Hutool-crypto)",link:"/module/crypto/"},{text:"DFA查找(Hutool-dfa)",link:"/module/dfa/"},{text:"数据库(Hutool-db)",link:"/module/db/"},{text:"HTTP客户端(Hutool-http)",link:"/module/http/"},{text:"定时任务(Hutool-cron)",link:"/module/cron/"},{text:"扩展(Hutool-extra)",link:"/module/extra/"},{text:"布隆过滤(Hutool-bloomFilter)",link:"/module/bloomFilter/"},{text:"切面(Hutool-aop)",link:"/module/aop/"},{text:"脚本(Hutool-script)",link:"/module/script/"},{text:"Office文档操作(Hutool-poi)",link:"/module/poi/"},{text:"系统调用(Hutool-system)",link:"/module/system/"},{text:"图形验证码(Hutool-captcha)",link:"/module/captcha/"},{text:"网络Socket(Hutool-socket)",link:"/module/socket/"},{text:"JWT(Hutool-jwt)",link:"/module/jwt/"}]},{text:"🤓知识星球",link:"/pages/KnowledgePlanet/"},{text:"💖支持",link:"/pages/support/"},{text:"💡javaDoc",link:"https://plus.hutool.cn/apidocs/"},{text:"⏳更新记录",link:"https://hutool.cn/docs/#/CHANGELOG"},{text:"🏮仓库地址",items:[{text:"🍎gitee",link:"https://gitee.com/dromara/hutool"},{text:"🍏github",link:"https://github.com/dromara/hutool"}]}],sidebarDepth:2,logo:"https://plus.hutool.cn/images/hutool.svg",searchMaxSuggestions:10,lastUpdated:"上次更新",sidebar:{"/01.指南/":[{title:"快速入门",collapsable:!1,children:[["01.快速入门/01.简介.md","简介","/pages/index/"]]},{title:"核心（Hutool-core）",collapsable:!1,children:[{title:"克隆",collapsable:!1,children:[["02.核心（Hutool-core）/01.克隆/01.支持泛型的克隆接口和克隆类.md","支持泛型的克隆接口和克隆类","/pages/Cloneable/"]]},{title:"类型转换",collapsable:!1,children:[["02.核心（Hutool-core）/02.类型转换/01.类型转换工具类-Convert.md","类型转换工具类-Convert","/pages/Convert/"],["02.核心（Hutool-core）/02.类型转换/02.自定义类型转换-ConverterRegistry.md","自定义类型转换-ConverterRegistry","/pages/ConverterRegistry/"]]},{title:"日期时间",collapsable:!1,children:[["02.核心（Hutool-core）/03.日期时间/01.概述.md","概述","/pages/Date/"],["02.核心（Hutool-core）/03.日期时间/02.日期时间工具-DateUtil.md","日期时间工具-DateUtil","/pages/DateUtil/"],["02.核心（Hutool-core）/03.日期时间/03.日期时间对象-DateTime.md","日期时间对象-DateTime","/pages/DateTime/"],["02.核心（Hutool-core）/03.日期时间/04.农历日期-ChineseDate.md","农历日期-ChineseDate","/pages/ChineseDate/"],["02.核心（Hutool-core）/03.日期时间/05.LocalDateTime工具-LocalDateTimeUtil.md","LocalDateTime工具-LocalDateTimeUtil","/pages/LocalDateTimeUtil/"],["02.核心（Hutool-core）/03.日期时间/06.计时器工具-TimeInterval.md","计时器工具-TimeInterval","/pages/TimeInterval/"]]},{title:"IO流相关",collapsable:!1,children:[["02.核心（Hutool-core）/04.IO流相关/00.概述.md","概述","/pages/io/"],["02.核心（Hutool-core）/04.IO流相关/01.IO工具类-IoUtil.md","IO工具类-IoUtil","/pages/IoUtil/"],["02.核心（Hutool-core）/04.IO流相关/02.文件工具类-FileUtil.md","文件工具类-FileUtil","/pages/FileUtil/"],["02.核心（Hutool-core）/04.IO流相关/03.文件监听-WatchMonitor.md","文件监听-WatchMonitor","/pages/WatchMonitor/"],["02.核心（Hutool-core）/04.IO流相关/04.文件类型判断-FileTypeUtil.md","文件类型判断-FileTypeUtil","/pages/FileTypeUtil/"],{title:"文件",collapsable:!1,children:[["02.核心（Hutool-core）/04.IO流相关/05.文件/01.文件读取-FileReader.md","文件读取-FileReader","/pages/FileReader/"],["02.核心（Hutool-core）/04.IO流相关/05.文件/02.文件写入-FileWriter.md","文件写入-FileWriter","/pages/FileWriter/"],["02.核心（Hutool-core）/04.IO流相关/05.文件/03.文件追加-FileAppender.md","文件追加-FileAppender","/pages/FileAppender/"],["02.核心（Hutool-core）/04.IO流相关/05.文件/04.文件跟随-Tailer.md","文件跟随-Tailer","/pages/Tailer/"],["02.核心（Hutool-core）/04.IO流相关/05.文件/05.文件名工具-FileNameUtil.md","文件名工具-FileNameUtil","/pages/FileNameUtil/"]]},{title:"资源",collapsable:!1,children:[["02.核心（Hutool-core）/04.IO流相关/06.资源/00.概述.md","概述","/pages/resource"],["02.核心（Hutool-core）/04.IO流相关/06.资源/01.资源工具-ResourceUtil.md","资源工具-ResourceUtil","/pages/ResourceUtil/"],["02.核心（Hutool-core）/04.IO流相关/06.资源/02.ClassPath资源访问-ClassPathResource.md","ClassPath资源访问-ClassPathResource","/pages/ClassPathResource/"]]}]},{title:"工具类",collapsable:!1,children:[["02.核心（Hutool-core）/05.工具类/00.概述.md","概述","/pages/util/"],["02.核心（Hutool-core）/05.工具类/01.字符串工具-StrUtil.md","字符串工具-StrUtil","/pages/StrUtil/"],["02.核心（Hutool-core）/05.工具类/02.16进制工具-HexUtil.md","16进制工具-HexUtil","/pages/HexUtil/"],["02.核心（Hutool-core）/05.工具类/03.Escape工具-EscapeUtil.md","Escape工具-EscapeUtil","/pages/EscapeUtil/"],["02.核心（Hutool-core）/05.工具类/04.Hash算法-HashUtil.md","Hash算法-HashUtil","/pages/HashUtil/"],["02.核心（Hutool-core）/05.工具类/05.URL工具-URLUtil.md","URL工具-URLUtil","/pages/URLUtil/"],["02.核心（Hutool-core）/05.工具类/06.XML工具-XmlUtil.md","XML工具-XmlUtil","/pages/XmlUtil/"],["02.核心（Hutool-core）/05.工具类/07.对象工具-ObjectUtil.md","对象工具-ObjectUtil","/pages/ObjectUtil/"],["02.核心（Hutool-core）/05.工具类/08.反射工具-ReflectUtil.md","反射工具-ReflectUtil","/pages/ReflectUtil/"],["02.核心（Hutool-core）/05.工具类/09.泛型类型工具-TypeUtil.md","泛型类型工具-TypeUtil","/pages/TypeUtil/"],["02.核心（Hutool-core）/05.工具类/10.分页工具-PageUtil.md","分页工具-PageUtil","/pages/PageUtil/"],["02.核心（Hutool-core）/05.工具类/11.剪贴板工具-ClipboardUtil.md","剪贴板工具-ClipboardUtil","/pages/ClipboardUtil/"],["02.核心（Hutool-core）/05.工具类/12.类工具-ClassUtil.md","类工具-ClassUtil","/pages/ClassUtil/"],["02.核心（Hutool-core）/05.工具类/13.枚举工具-EnumUtil.md","枚举工具-EnumUtil","/pages/EnumUtil/"],["02.核心（Hutool-core）/05.工具类/14.命令行工具-RuntimeUtil.md","命令行工具-RuntimeUtil","/pages/RuntimeUtil/"],["02.核心（Hutool-core）/05.工具类/15.数字工具-NumberUtil.md","数字工具-NumberUtil","/pages/NumberUtil/"],["02.核心（Hutool-core）/05.工具类/16.数组工具-ArrayUtil.md","数组工具-ArrayUtil","/pages/ArrayUtil/"],["02.核心（Hutool-core）/05.工具类/17.随机工具-RandomUtil.md","随机工具-RandomUtil","/pages/RandomUtil/"],["02.核心（Hutool-core）/05.工具类/18.唯一ID工具-IdUtil.md","唯一ID工具-IdUtil","/pages/IdUtil/"],["02.核心（Hutool-core）/05.工具类/19.压缩工具-ZipUtil.md","压缩工具-ZipUtil","/pages/ZipUtil/"],["02.核心（Hutool-core）/05.工具类/20.引用工具-ReferenceUtil.md","引用工具-ReferenceUtil","/pages/ReferenceUtil/"],["02.核心（Hutool-core）/05.工具类/21.正则工具-ReUtil.md","正则工具-ReUtil","/pages/ReUtil/"],["02.核心（Hutool-core）/05.工具类/23.身份证工具-IdcardUtil.md","身份证工具-IdcardUtil","/pages/IdcardUtil/"],["02.核心（Hutool-core）/05.工具类/24.信息脱敏工具-DesensitizedUtil.md","信息脱敏工具-DesensitizedUtil","/pages/DesensitizedUtil/"],["02.核心（Hutool-core）/05.工具类/25.社会信用代码工具-CreditCodeUtil.md","社会信用代码工具-CreditCodeUtil","/pages/CreditCodeUtil/"],["02.核心（Hutool-core）/05.工具类/26.SPI加载工具-ServiceLoaderUtil.md","SPI加载工具-ServiceLoaderUtil","/pages/ServiceLoaderUtil/"],["02.核心（Hutool-core）/05.工具类/27.字符编码工具-CharsetUtil.md","字符编码工具-CharsetUtil","/pages/CharsetUtil/"],["02.核心（Hutool-core）/05.工具类/28.类加载工具-ClassLoaderUtil.md","类加载工具-ClassLoaderUtil","/pages/ClassLoaderUtil/"]]},{title:"语言特性",collapsable:!1,children:[["02.核心（Hutool-core）/06.语言特性/01.概述.md","概述","/pages/language/characteristics/"],["02.核心（Hutool-core）/06.语言特性/02.HashMap扩展-Dict.md","HashMap扩展-Dict","/pages/Dict/"],["02.核心（Hutool-core）/06.语言特性/03.单例工具-Singleton.md","单例工具-Singleton","/pages/Singleton/"],["02.核心（Hutool-core）/06.语言特性/04.断言-Assert.md","断言-Assert","/pages/Assert/"],["02.核心（Hutool-core）/06.语言特性/05.二进码十进数-BCD.md","二进码十进数-BCD","/pages/BCD/"],["02.核心（Hutool-core）/06.语言特性/06.控制台打印封装-Console.md","控制台打印封装-Console","/pages/Console/"],["02.核心（Hutool-core）/06.语言特性/07.字段验证器-Validator.md","字段验证器-Validator","/pages/Validator/"],["02.核心（Hutool-core）/06.语言特性/08.字符串格式化-StrFormatter.md","字符串格式化-StrFormatter","/pages/StrFormatter/"],{title:"树结构",collapsable:!1,children:[["02.核心（Hutool-core）/06.语言特性/09.树结构/10.树结构工具-TreeUtil.md","树结构工具-TreeUtil","/pages/TreeUtil/"]]}]},{title:"JavaBean",collapsable:!1,children:[["02.核心（Hutool-core）/07.JavaBean/01.概述.md","概述","/pages/javaBean/"],["02.核心（Hutool-core）/07.JavaBean/02.Bean工具-BeanUtil.md","Bean工具-BeanUtil","/pages/BeanUtil/"],["02.核心（Hutool-core）/07.JavaBean/03.DynaBean.md","DynaBean","/pages/DynaBean/"],["02.核心（Hutool-core）/07.JavaBean/04.表达式解析-BeanPath.md","表达式解析-BeanPath","/pages/BeanPath/"],["02.核心（Hutool-core）/07.JavaBean/05.Bean描述-BeanDesc.md","Bean描述-BeanDesc","/pages/BeanDesc/"],["02.核心（Hutool-core）/07.JavaBean/06.空检查属性获取-Opt.md","空检查属性获取-Opt","/pages/Opt/"]]},{title:"集合类",collapsable:!1,children:[["02.核心（Hutool-core）/08.集合类/01.概述.md","概述","/pages/Coll/"],["02.核心（Hutool-core）/08.集合类/02.集合工具-CollUtil.md","集合工具-CollUtil","/pages/CollUtil/"],["02.核心（Hutool-core）/08.集合类/03.列表工具-ListUtil.md","列表工具-ListUtil","/pages/ListUtil/"],["02.核心（Hutool-core）/08.集合类/04.Iterator工具-IterUtil.md","Iterator工具-IterUtil","/pages/IterUtil/"],["02.核心（Hutool-core）/08.集合类/05.有界优先队列-BoundedPriorityQueue.md","有界优先队列-BoundedPriorityQueue","/pages/BoundedPriorityQueue/"],["02.核心（Hutool-core）/08.集合类/06.线程安全的HashSet-ConcurrentHashSet.md","线程安全的HashSet-ConcurrentHashSet","/pages/ConcurrentHashSet/"],["02.核心（Hutool-core）/08.集合类/07.集合串行流工具-CollStreamUtil.md","集合串行流工具-CollStreamUtil","/pages/CollStreamUtil/"],["02.核心（Hutool-core）/08.集合类/08.行遍历器-LineIter.md","行遍历器-LineIter","/pages/LineIter/"]]},{title:"Map",collapsable:!1,children:[["02.核心（Hutool-core）/09.Map/01.概述.md","概述","/pages/map/"],["02.核心（Hutool-core）/09.Map/02.Map工具-MapUtil.md","Map工具-MapUtil","/pages/MapUtil/"],["02.核心（Hutool-core）/09.Map/03.双向查找Map-BiMap.md","双向查找Map-BiMap","/pages/BiMap/"],["02.核心（Hutool-core）/09.Map/04.可重复键值Map-TableMap.md","可重复键值Map-TableMap","/pages/TableMap/"],["02.核心（Hutool-core）/09.Map/05.Map流式构建器-MapBuilder copy.md","Map流式构建器-MapBuilder","/pages/MapBuilder/"]]},{title:"Codec编码",collapsable:!1,children:[["02.核心（Hutool-core）/10.Codec编码/01.Base62编码解码-Base62.md","Base62编码解码-Base62","/pages/Base62/"],["02.核心（Hutool-core）/10.Codec编码/02.Base64编码解码-Base64.md","Base64编码解码-Base64","/pages/Base64/"],["02.核心（Hutool-core）/10.Codec编码/03.Base32编码解码-Base32.md","Base32编码解码-Base32","/pages/Base32/"],["02.核心（Hutool-core）/10.Codec编码/04.莫尔斯电码-Morse.md","莫尔斯电码-Morse","/pages/Morse/"],["02.核心（Hutool-core）/10.Codec编码/05.BCD码-BCD.md","BCD码-BCD","/pages/codec/BCD/"],["02.核心（Hutool-core）/10.Codec编码/06.回转N位密码-Rot.md","回转N位密码-Rot","/pages/Rot/"],["02.核心（Hutool-core）/10.Codec编码/07.Punycode实现-PunyCode.md","Punycode实现-PunyCode","/pages/PunyCode/"]]},{title:"文本操作",collapsable:!1,children:[["02.核心（Hutool-core）/11.文本操作/01.CSV文件处理工具-CsvUtil.md","CSV文件处理工具-CsvUtil","/pages/CsvUtil/"],["02.核心（Hutool-core）/11.文本操作/02.Unicode编码转换工具-UnicodeUtil.md","Unicode编码转换工具-UnicodeUtil","/pages/UnicodeUtil/"],["02.核心（Hutool-core）/11.文本操作/03.可复用字符串生成器-StrBuilder.md","可复用字符串生成器-StrBuilder","/pages/StrBuilder/"],["02.核心（Hutool-core）/11.文本操作/04.字符串切割-StrSplitter.md","字符串切割-StrSplitter","/pages/StrSplitter/"]]},{title:"注解",collapsable:!1,children:[["02.核心（Hutool-core）/12.注解/01.注解工具-AnnotationUtil.md","注解工具-AnnotationUtil","/pages/AnnotationUtil/"]]},{title:"比较器",collapsable:!1,children:[["02.核心（Hutool-core）/13.比较器/01.概述.md","概述","/pages/Comparator/"],["02.核心（Hutool-core）/13.比较器/02.比较工具-CompareUtil.md","比较工具-CompareUtil","/pages/CompareUtil/"],["02.核心（Hutool-core）/13.比较器/03.版本比较器-VersionComparator.md","版本比较器-VersionComparator","/pages/VersionComparator/"]]},{title:"异常",collapsable:!1,children:[["02.核心（Hutool-core）/14.异常/01.异常工具-ExceptionUtil.md","异常工具-ExceptionUtil","/pages/ExceptionUtil/"],["02.核心（Hutool-core）/14.异常/02.其它异常封装.md","其它异常封装","/pages/Exception/"]]},{title:"数学",collapsable:!1,children:[["02.核心（Hutool-core）/15.数学/01.数学相关-MathUtil.md","数学相关-MathUtil","/pages/MathUtil/"]]},{title:"线程和并发",collapsable:!1,children:[["02.核心（Hutool-core）/16.线程和并发/01.线程工具-ThreadUtil.md","线程工具-ThreadUtil","/pages/ThreadUtil/"],["02.核心（Hutool-core）/16.线程和并发/02.异步工具类-AsyncUtil.md","异步工具类-AsyncUtil","/pages/AsyncUtil/"],["02.核心（Hutool-core）/16.线程和并发/03.自定义线程池-ExecutorBuilder.md","自定义线程池-ExecutorBuilder","/pages/ExecutorBuilder/"],["02.核心（Hutool-core）/16.线程和并发/04.高并发测试-ConcurrencyTester.md","高并发测试-ConcurrencyTester","/pages/ConcurrencyTester/"]]},{title:"图片",collapsable:!1,children:[["02.核心（Hutool-core）/17.图片/01.图片工具-ImgUtil.md","图片工具-ImgUtil","/pages/ImgUtil/"],["02.核心（Hutool-core）/17.图片/02.图片编辑器-Img.md","图片编辑器-Img","/pages/Img/"]]},{title:"网络",collapsable:!1,children:[["02.核心（Hutool-core）/18.网络/01.网络工具-NetUtil.md","网络工具-NetUtil","/pages/NetUtil/"],["02.核心（Hutool-core）/18.网络/02.URL生成器-UrlBuilder.md","URL生成器-UrlBuilder","/pages/UrlBuilder/"]]},{title:"源码编译",collapsable:!1,children:[["02.核心（Hutool-core）/19.源码编译/01.源码编译工具-CompilerUtil.md","源码编译工具-CompilerUtil","/pages/CompilerUtil/"]]}]},{title:"配置文件(Hutool-setting）",collapsable:!1,children:[["03.配置文件(Hutool-setting）/01.概述.md","概述","/pages/setting/"],["03.配置文件(Hutool-setting）/02.Properties扩展-Props.md","Properties扩展-Props","/pages/Props/"],["03.配置文件(Hutool-setting）/03.设置文件-Setting.md","设置文件-Setting","/pages/setting/example/"]]},{title:"日志（Hutool-log）",collapsable:!1,children:[["04.日志（Hutool-log）/01.概述.md","概述","/pages/log/"],["04.日志（Hutool-log）/02.日志工厂-LogFactory.md","日志工厂-LogFactory","/pages/LogFactory/"],["04.日志（Hutool-log）/03.疑惑解答.md","疑惑解答","/pages/log/faq/"],["04.日志（Hutool-log）/04.静态调用日志-StaticLog.md","静态调用日志-StaticLog","/pages/StaticLog/"]]},{title:"缓存（Hutool-cache）",collapsable:!1,children:[["05.缓存（Hutool-cache）/01.概述.md","概述","/pages/cache/index/"],["05.缓存（Hutool-cache）/02.缓存工具-CacheUtil.md","缓存工具-CacheUtil","/pages/CacheUtil/"],["05.缓存（Hutool-cache）/03.先入先出-FIFOCache.md","先入先出-FIFOCache","/pages/FIFOCache/"],["05.缓存（Hutool-cache）/04.文件缓存-FileCache.md","文件缓存-FileCache","/pages/FileCache/"],["05.缓存（Hutool-cache）/05.最少使用-LFUCache.md","最少使用-LFUCache","/pages/LFUCache/"],["05.缓存（Hutool-cache）/06.最近最久未使用-LRUCache.md","最近最久未使用-LRUCache","/pages/LRUCache/"],["05.缓存（Hutool-cache）/07.超时-TimedCache.md","超时-TimedCache","/pages/TimedCache/"],["05.缓存（Hutool-cache）/08.弱引用-WeakCache.md","弱引用-WeakCache","/pages/WeakCache/"]]},{title:"JSON（Hutool-json）",collapsable:!1,children:[["06.JSON（Hutool-json）/01.概述.md","概述","/pages/json/"],["06.JSON（Hutool-json）/02.JSON工具-JSONUtil.md","JSON工具-JSONUtil","/pages/JSONUtil/"],["06.JSON（Hutool-json）/03.JSON对象-JSONObject.md","JSON对象-JSONObject","/pages/JSONObject/"],["06.JSON（Hutool-json）/04.JSON数组-JSONArray.md","JSON数组-JSONArray","/pages/JSONArray/"]]},{title:"加密解密（Hutool-crypto）",collapsable:!1,children:[["07.加密解密（Hutool-crypto）/01.概述.md","概述","/pages/crypto/index/"],["07.加密解密（Hutool-crypto）/02.加密解密工具-SecureUtil.md","加密解密工具-SecureUtil","/pages/SecureUtil/"],["07.加密解密（Hutool-crypto）/03.国密算法工具-SmUtil.md","国密算法工具-SmUtil","/pages/SmUtil/"],["07.加密解密（Hutool-crypto）/04.对称加密-SymmetricCrypto.md","对称加密-SymmetricCrypto","/pages/SymmetricCrypto/"],["07.加密解密（Hutool-crypto）/05.摘要加密-Digester.md","摘要加密-Digester","/pages/Digester/"],["07.加密解密（Hutool-crypto）/06.消息认证码算法-HMac.md","消息认证码算法-HMac","/pages/HMac/"],["07.加密解密（Hutool-crypto）/07.签名和验证-Sign.md","签名和验证-Sign","/pages/Sign/"],["07.加密解密（Hutool-crypto）/08.非对称加密-AsymmetricCrypto.md","非对称加密-AsymmetricCrypto","/pages/AsymmetricCrypto/"]]},{title:"DFA查找（Hutool-dfa）",collapsable:!1,children:[["08.DFA查找（Hutool-dfa）/01.概述.md","概述","/pages/dfa/index/"],["08.DFA查找（Hutool-dfa）/02.DFA查找.md","DFA查找","/pages/dfa/"]]},{title:"数据库（Hutool-db）",collapsable:!1,children:[["09.数据库（Hutool-db）/01.概述.md","概述","/pages/db/index/"],["09.数据库（Hutool-db）/02.SQL执行器-SqlExecutor.md","SQL执行器-SqlExecutor","/pages/SqlExecutor/"],["09.数据库（Hutool-db）/03.支持事务的CRUD-Session.md","支持事务的CRUD-Session","/pages/Session/"],["09.数据库（Hutool-db）/04.数据库简单操作-Db.md","数据库简单操作-Db","/pages/Db/"],["09.数据库（Hutool-db）/05.数据源工厂-DsFactory.md","数据源工厂-DsFactory","/pages/DsFactory/"],["09.数据库（Hutool-db）/06.数据源配置db.setting样例.md","数据源配置db.setting样例","/pages/db/setting/example/"],["09.数据库（Hutool-db）/07.案例1-导出Blob字段图像.md","案例1-导出Blob字段图像","/pages/blob/example/"],["09.数据库（Hutool-db）/08.常见问题.md","常见问题","/pages/db/faq/"],{title:"NoSQL",collapsable:!1,children:[["09.数据库（Hutool-db）/09.NoSQL/01.Redis客户端封装-RedisDS.md","Redis客户端封装-RedisDS","/pages/RedisDS/"],["09.数据库（Hutool-db）/09.NoSQL/02.MongoDB客户端封装-MongoDS.md","MongoDB客户端封装-MongoDS","/pages/MongoDS/"]]}]},{title:"HTTP客户端（Hutool-http）",collapsable:!1,children:[["10.HTTP客户端（Hutool-http）/00.概述.md","概述","/pages/http/"],["10.HTTP客户端（Hutool-http）/01.Http客户端工具类-HttpUtil.md","Http客户端工具类-HttpUtil","/pages/HttpUtil/"],["10.HTTP客户端（Hutool-http）/02.HTML工具类-HtmlUtil.md","HTML工具类-HtmlUtil","/pages/HtmlUtil/"],["10.HTTP客户端（Hutool-http）/03.Http响应-HttpResponse.md","Http响应-HttpResponse","/pages/HttpResponse/"],["10.HTTP客户端（Hutool-http）/04.Http请求-HttpRequest.md","Http请求-HttpRequest","/pages/HttpRequest/"],["10.HTTP客户端（Hutool-http）/05.UA工具类-UserAgentUtil.md","UA工具类-UserAgentUtil","/pages/UserAgentUtil/"],["10.HTTP客户端（Hutool-http）/06.常用Http状态码-HttpStatus.md","常用Http状态码-HttpStatus","/pages/HttpStatus/"],["10.HTTP客户端（Hutool-http）/07.案例1-爬取开源中国的开源资讯.md","案例1-爬取开源中国的开源资讯","/pages/http/example/"],["10.HTTP客户端（Hutool-http）/08.常见问题.md","常见问题","/pages/http/faq/"],{title:"Server",collapsable:!1,children:[["10.HTTP客户端（Hutool-http）/09.Server/10.简易Http服务器-SimpleServer.md","简易Http服务器-SimpleServer","/pages/SimpleServer/"]]},{title:"WebService",collapsable:!1,children:[["10.HTTP客户端（Hutool-http）/11.WebService/12.Soap客户端-SoapClient.md","Soap客户端-SoapClient","/pages/SoapClient/"]]}]},{title:"定时任务（Hutool-cron）",collapsable:!1,children:[["11.定时任务（Hutool-cron）/01.概述.md","概述","/pages/cron/"],["11.定时任务（Hutool-cron）/02.全局定时任务-CronUtil.md","全局定时任务-CronUtil","/pages/CronUtil/"]]},{title:"扩展（Hutool-extra）",collapsable:!1,children:[["12.扩展（Hutool-extra）/01.概述.md","概述","/pages/extra/"],["12.扩展（Hutool-extra）/02.Servlet工具-ServletUtil.md","Servlet工具-ServletUtil","/pages/ServletUtil/"],["12.扩展（Hutool-extra）/03.二维码工具-QrCodeUtil.md","二维码工具-QrCodeUtil","/pages/QrCodeUtil/"],["12.扩展（Hutool-extra）/04.邮件工具-MailUtil.md","邮件工具-MailUtil","/pages/MailUtil/"],{title:"cglib",collapsable:!1,children:[["12.扩展（Hutool-extra）/05.cglib/01.Cglib工具-CglibUtil.md","Cglib工具-CglibUtil","/pages/CglibUtil/"]]},{title:"emoji",collapsable:!1,children:[["12.扩展（Hutool-extra）/06.emoji/01.Emoji工具-EmojiUtil.md","Emoji工具-EmojiUtil","/pages/EmojiUtil/"]]},{title:"FTP",collapsable:!1,children:[["12.扩展（Hutool-extra）/07.FTP/01.FTP客户端封装-Ftp.md","FTP客户端封装-Ftp","/pages/Ftp/"],["12.扩展（Hutool-extra）/07.FTP/02.简易FTP服务器-SimpleFtpServer.md","简易FTP服务器-SimpleFtpServer","/pages/SimpleFtpServer/"]]},{title:"Jsch封装",collapsable:!1,children:[["12.扩展（Hutool-extra）/08.Jsch封装/00.SFTP封装-Sftp.md","SFTP封装-Sftp","/pages/Sftp/"],["12.扩展（Hutool-extra）/08.Jsch封装/01.Jsch工具-JschUtil.md","Jsch工具-JschUtil","/pages/JschUtil/"]]},{title:"Spring",collapsable:!1,children:[["12.扩展（Hutool-extra）/09.Spring/01.Spring工具-SpringUtil.md","Spring工具-SpringUtil","/pages/SpringUtil/"]]},{title:"中文分词",collapsable:!1,children:[["12.扩展（Hutool-extra）/10.中文分词/01.中文分词封装-TokenizerUtil.md","中文分词封装-TokenizerUtil","/pages/TokenizerUtil/"]]},{title:"压缩",collapsable:!1,children:[["12.扩展（Hutool-extra）/11.压缩/01.压缩封装-CompressUtil.md","压缩封装-CompressUtil","/pages/CompressUtil/"]]},{title:"拼音",collapsable:!1,children:[["12.扩展（Hutool-extra）/12.拼音/01.拼音工具-PinyinUtil.md","拼音工具-PinyinUtil","/pages/PinyinUtil/"]]},{title:"表达式引擎",collapsable:!1,children:[["12.扩展（Hutool-extra）/13.表达式引擎/01.表达式引擎封装-ExpressionUtil.md","表达式引擎封装-ExpressionUtil","/pages/ExpressionUtil/"]]},{title:"模板引擎",collapsable:!1,children:[["12.扩展（Hutool-extra）/14.模板引擎/01.模板引擎封装-TemplateUtil.md","模板引擎封装-TemplateUtil","/pages/TemplateUtil/"]]}]},{title:"布隆过滤（Hutool-bloomFilter）",collapsable:!1,children:[["13.布隆过滤（Hutool-bloomFilter）/01.概述.md","概述","/pages/bloomFilter/"]]},{title:"切面（Hutool-aop）",collapsable:!1,children:[["14.切面（Hutool-aop）/01.概述.md","概述","/pages/aop/"],["14.切面（Hutool-aop）/02.切面代理工具-ProxyUtil.md","切面代理工具-ProxyUtil","/pages/ProxyUtil/"]]},{title:"脚本（Hutool-script）",collapsable:!1,children:[["15.脚本（Hutool-script）/01.概述.md","概述","/pages/script/"],["15.脚本（Hutool-script）/02.Script工具-ScriptUtil.md","Script工具-ScriptUtil","/pages/ScriptUtil/"]]},{title:"Office文档操作（Hutool-poi）",collapsable:!1,children:[["16.Office文档操作（Hutool-poi）/01.概述.md","概述","/pages/poi/"],["16.Office文档操作（Hutool-poi）/02.Excel工具-ExcelUtil.md","Excel工具-ExcelUtil","/pages/ExcelUtil/"],["16.Office文档操作（Hutool-poi）/03.Excel生成-ExcelWriter.md","Excel生成-ExcelWriter","/pages/ExcelWriter/"],["16.Office文档操作（Hutool-poi）/04.Excel大数据生成-BigExcelWriter.md","Excel大数据生成-BigExcelWriter","/pages/BigExcelWriter/"],["16.Office文档操作（Hutool-poi）/05.Excel读取-ExcelReader.md","Excel读取-ExcelReader","/pages/ExcelReader/"],["16.Office文档操作（Hutool-poi）/06.Word生成-Word07Writer.md","Word生成-Word07Writer","/pages/Word07Writer/"],["16.Office文档操作（Hutool-poi）/07.流方式读取Excel2003-Excel03SaxReader.md","流方式读取Excel2003-Excel03SaxReader","/pages/Excel03SaxReader/"],["16.Office文档操作（Hutool-poi）/08.流方式读取Excel2007-Excel07SaxReader.md","流方式读取Excel2007-Excel07SaxReader","/pages/Excel07SaxReader/"]]},{title:"系统调用（Hutool-system）",collapsable:!1,children:[["17.系统调用（Hutool-system）/01.系统属性调用-SystemUtil.md","系统属性调用-SystemUtil","/pages/SystemUtil/"],["17.系统调用（Hutool-system）/02.Oshi封装-OshiUtil.md","Oshi封装-OshiUtil","/pages/OshiUtil/"]]},{title:"图形验证码（Hutool-captcha）",collapsable:!1,children:[["18.图形验证码（Hutool-captcha）/01.概述.md","概述","/pages/captcha/"]]},{title:"网络Socket（Hutool-socket）",collapsable:!1,children:[["19.网络Socket（Hutool-socket）/01.概述.md","概述","/pages/socket/"],["19.网络Socket（Hutool-socket）/02.AIO封装-AioServer和AioClient.md","AIO封装-AioServer和AioClient","/pages/AioServer/"],["19.网络Socket（Hutool-socket）/03.NIO封装-NioServer和NioClient.md","NIO封装-NioServer和NioClient","/pages/NioServer/"]]},{title:"JWT（Hutool-jwt）",collapsable:!1,children:[["20.JWT（Hutool-jwt）/01.概述.md","概述","/pages/jwt/"],["20.JWT（Hutool-jwt）/02.JWT工具-JWTUtil.md","JWT工具-JWTUtil","/pages/JWTUtil/"],["20.JWT（Hutool-jwt）/03.JWT签名工具-JWTSignerUtil.md","JWT签名工具-JWTSignerUtil","/pages/JWTSignerUtil/"],["20.JWT（Hutool-jwt）/04.JWT验证-JWTValidator.md","JWT验证-JWTValidator","/pages/JWTValidator/"]]}],catalogue:{"核心（Hutool-core）":"/module/core/","配置文件(Hutool-setting）":"/module/setting/","日志（Hutool-log）":"/module/log/","缓存（Hutool-cache）":"/module/cache/","JSON（Hutool-json）":"/module/json/","加密解密（Hutool-crypto）":"/module/crypto/","DFA查找（Hutool-dfa）":"/module/dfa/","数据库（Hutool-db）":"/module/db/","HTTP客户端（Hutool-http）":"/module/http/","定时任务（Hutool-cron）":"/module/cron/","扩展（Hutool-extra）":"/module/extra/","布隆过滤（Hutool-bloomFilter）":"/module/bloomFilter/","切面（Hutool-aop）":"/module/aop/","脚本（Hutool-script）":"/module/script/","Office文档操作（Hutool-poi）":"/module/poi/","系统调用（Hutool-system）":"/module/system/","图形验证码（Hutool-captcha）":"/module/captcha/","网络Socket（Hutool-socket）":"/module/socket/","JWT（Hutool-jwt）":"/module/jwt/"},"/02.模块/":[["02.核心（Hutool-core）.md","核心（Hutool-core）","/module/core/"],["03.配置文件(Hutool-setting）.md","配置文件(Hutool-setting）","/module/setting/"],["04.日志（Hutool-log）.md","日志（Hutool-log）","/module/log/"],["05.缓存（Hutool-cache）.md","缓存（Hutool-cache）","/module/cache/"],["06.JSON（Hutool-json）.md","JSON（Hutool-json）","/module/json/"],["07.加密解密（Hutool-crypto）.md","加密解密（Hutool-crypto）","/module/crypto/"],["08.DFA查找（Hutool-dfa）.md","DFA查找（Hutool-dfa）","/module/dfa/"],["09.数据库（Hutool-db）.md","数据库（Hutool-db）","/module/db/"],["10.HTTP客户端（Hutool-http）.md","HTTP客户端（Hutool-http）","/module/http/"],["11.定时任务（Hutool-cron）.md","定时任务（Hutool-cron）","/module/cron/"],["12.扩展（Hutool-extra）.md","扩展（Hutool-extra）","/module/extra/"],["13.布隆过滤（Hutool-bloomFilter）.md","布隆过滤（Hutool-bloomFilter）","/module/bloomFilter/"],["14.切面（Hutool-aop）.md","切面（Hutool-aop）","/module/aop/"],["15.脚本（Hutool-script）.md","脚本（Hutool-script）","/module/script/"],["16.Office文档操作（Hutool-poi）.md","Office文档操作（Hutool-poi）","/module/poi/"],["17.系统调用（Hutool-system）.md","系统调用（Hutool-system）","/module/system/"],["18.图形验证码（Hutool-captcha）.md","图形验证码（Hutool-captcha）","/module/captcha/"],["19.网络Socket（Hutool-socket）.md","网络Socket（Hutool-socket）","/module/socket/"],["20.JWT（Hutool-jwt）.md","JWT（Hutool-jwt）","/module/jwt/"]],"/03.支持/":[["01.支持.md","支持这个项目","/pages/support/"]],"/04.知识星球/":[["01.知识星球.md","知识星球","/pages/KnowledgePlanet/"]]},updateBar:{showToArticle:!1},pageStyle:"line",category:!1,tag:!1,author:{name:"Hutool",href:"https://hutool.cn/"},social:{icons:[{iconClass:"icon-youjian",title:"https://doc.hutool.cn/assets/js/loolly@aliyun.com",link:"mailto:loolly@aliyun.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/dromara/hutool"},{iconClass:"icon-gitee",title:"Gitee",link:"https://gitee.com/dromara/hutool"}]},footer:{createYear:2023,copyrightInfo:"Hutool | MulanPSL-2.0"},htmlModules:{windowLB:'\n      <div class="lbzz">\n        <a target="_blank" href="https://www.mall4j.com/">\n          <img src="../../../plus.hutool.cn/images/zz/mall4j.png"/*tpa=https://plus.hutool.cn/images/zz/mall4j.png*//>\n        </a>\n      </div>\n      <div class="lbzz">\n        <a target="_blank" href="https://github.com/chat2db/Chat2DB">\n          <img src="../../../plus.hutool.cn/images/zz/chat2db.jpg"/*tpa=https://plus.hutool.cn/images/zz/chat2db.jpg*//>\n        </a>\n      </div>\n  ',sidebarT:'\n      <div class="t_blank" style="margin-top: 6rem;"></div>\n  ',pageT:'\n    <div class="wwads-cn wwads-horizontal" data-id="126" style="max-width:100%"></div>\n    <div class="hutool-top-zz" style="background-color: #E8ECF1;text-align:center">\n      <div style="text-align:left">特别赞助 by：</div>\n      <a target="_blank" href="https://www.xiaonuo.vip/?from=hutool">\n        <img src="../../../plus.hutool.cn/images/zz/xiaonuo_banner.jpg"/*tpa=https://plus.hutool.cn/images/zz/xiaonuo_banner.jpg*/ />\n      </a>\n      <a target="_blank" href="http://github.crmeb.net/u/Hutool">\n        <img src="../../../plus.hutool.cn/images/zz/crmeb/crmeb_banner.jpg"/*tpa=https://plus.hutool.cn/images/zz/crmeb/crmeb_banner.jpg*/ />\n      </a>\n      <a target="_blank" href="https://www.jeequan.com/product/jeepay.html?from=hutool">\n        <img src="../../../plus.hutool.cn/images/zz/jeepay/jeepay_banner.jpg"/*tpa=https://plus.hutool.cn/images/zz/jeepay/jeepay_banner.jpg*/ />\n      </a>\n      <a target="_blank" href="https://dwz.cn/dX5lJKZt">\n        <img src="../../../plus.hutool.cn/images/zz/yungouos.jpg"/*tpa=https://plus.hutool.cn/images/zz/yungouos.jpg*/ />\n      </a>\n      <a target="_blank" href="https://vue.misboot.com/#/user/login?from=hutool2">\n        <img src="../../../plus.hutool.cn/images/zz/misboot/misboot-banner.png"/*tpa=https://plus.hutool.cn/images/zz/misboot/misboot-banner.png*/ />\n      </a>\n    </div>\n    <style>\n      .hutool-top-zz a img{width:48%;margin-left:5px}\n    </style>\n  '}}};var Ss=n(93),Cs=n(94),ws=n(11);var Us={computed:{$filterPosts(){return this.$site.pages.filter(e=>{const{frontmatter:{pageComponent:t,article:n,home:a}}=e;return!(t||!1===n||!0===a)})},$sortPosts(){return(e=this.$filterPosts).sort((e,t)=>{const n=e.frontmatter.sticky,a=t.frontmatter.sticky;return n&&a?n==a?Object(ws.a)(e,t):n-a:n&&!a?-1:!n&&a?1:Object(ws.a)(e,t)}),e;var e},$sortPostsByDate(){return(e=this.$filterPosts).sort((e,t)=>Object(ws.a)(e,t)),e;var e},$groupPosts(){return function(e){const t={},n={};for(let a=0,r=e.length;a<r;a++){const{frontmatter:{categories:r,tags:i}}=e[a];"array"===Object(ws.n)(r)&&r.forEach(n=>{n&&(t[n]||(t[n]=[]),t[n].push(e[a]))}),"array"===Object(ws.n)(i)&&i.forEach(t=>{t&&(n[t]||(n[t]=[]),n[t].push(e[a]))})}return{categories:t,tags:n}}(this.$sortPosts)},$categoriesAndTags(){return function(e){const t=[],n=[];for(let n in e.categories)t.push({key:n,length:e.categories[n].length});for(let t in e.tags)n.push({key:t,length:e.tags[t].length});return{categories:t,tags:n}}(this.$groupPosts)}}};Xn.component(Ss.default),Xn.component(Cs.default);function Ts(e){return e.toString().padStart(2,"0")}n(243);Xn.component("CodeBlock",()=>Promise.resolve().then(n.bind(null,93))),Xn.component("Badge",()=>Promise.all([n.e(0),n.e(3)]).then(n.bind(null,554))),Xn.component("CodeGroup",()=>Promise.resolve().then(n.bind(null,94)));n(244);var Bs=[({Vue:e,options:t,router:n,siteData:a,isServer:r})=>{r||n.afterEach(()=>{var e;e=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const e=document.getElementsByClassName("wwads-cn"),t=document.querySelector(".wwads-content");e[0]&&!t&&(e[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://fastly.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='https://doc.hutool.cn/assets/js/M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(e,1):document.addEventListener("DOMContentLoaded",e),setTimeout(()=>{const e=document.querySelector(".page-wwads");if(!e)return;const t=e.querySelector(".wwads-hide");t&&(t.onclick=()=>{e.style.display="none"}),"none"===e.style.display&&(e.style.display="flex")},900)})},({Vue:e,options:t,router:n,siteData:a})=>{a.pages.map(e=>{const{frontmatter:{date:t,author:n}}=e;"string"==typeof t&&"Z"===t.charAt(t.length-1)&&(e.frontmatter.date=function(e){e instanceof Date||(e=new Date(e));return`${e.getUTCFullYear()}-${Ts(e.getUTCMonth()+1)}-${Ts(e.getUTCDate())} ${Ts(e.getUTCHours())}:${Ts(e.getUTCMinutes())}:${Ts(e.getUTCSeconds())}`}(t)),n?e.author=n:a.themeConfig.author&&(e.author=a.themeConfig.author)}),e.mixin(Us)},{},({Vue:e})=>{e.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:e})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var e=document.createElement("script");e.src="../../../hm.baidu.com/hm.js-f2c884fc06fca522c4105429259b8a73.js"/*tpa=https://hm.baidu.com/hm.js?f2c884fc06fca522c4105429259b8a73*/;var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}(),e.afterEach((function(e){_hmt.push(["_trackPageview",e.fullPath])})))}],ks=[];class js extends class{constructor(){this.store=new Xn({data:{state:{}}})}$get(e){return this.store.state[e]}$set(e,t){Xn.set(this.store.state,e,t)}$emit(...e){this.store.$emit(...e)}$on(...e){this.store.$on(...e)}}{}Object.assign(js.prototype,{getPageAsyncComponent:lo,getLayoutAsyncComponent:oo,getAsyncComponent:so,getVueComponent:co});var As={install(e){const t=new js;e.$vuepress=t,e.prototype.$vuepress=t}};function Hs(e,t){const n=t.toLowerCase();return e.options.routes.some(e=>e.path.toLowerCase()===n)}var Is={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(e){const t=this.pageKey||this.$parent.$page.key;return po("pageKey",t),Xn.component(t)||Xn.component(t,lo(t)),Xn.component(t)?e(t):e("")}},zs={functional:!0,props:{slotKey:String,required:!0},render:(e,{props:t,slots:n})=>e("div",{class:["content__"+t.slotKey]},n()[t.slotKey])},Ds={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Fs=(n(245),n(246),Object(bs.a)(Ds,(function(){var e=this._self._c;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"https://doc.hutool.cn/assets/js/M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ps={functional:!0,render(e,{parent:t,children:n}){if(t._isMounted)return n;t.$once("hook:mounted",()=>{t.$forceUpdate()})}};Xn.config.productionTip=!1,Xn.use(ql),Xn.use(As),Xn.mixin(function(e,t,n=Xn){!function(e){e.locales&&Object.keys(e.locales).forEach(t=>{e.locales[t].path=t});Object.freeze(e)}(t),n.$vuepress.$set("siteData",t);const a=new(e(n.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(r).reduce((e,t)=>(t.startsWith("$")&&(e[t]=r[t].get),e),i),{computed:i}}(e=>class{setPage(e){this.__page=e}get $site(){return e}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:e={}}=this.$site;let t,n;for(const a in e)"/"===a?n=e[a]:0===this.$page.path.indexOf(a)&&(t=e[a]);return t||n||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:e}=this.$page.frontmatter;return"string"==typeof e&&e}get $title(){const e=this.$page,{metaTitle:t}=this.$page.frontmatter;if("string"==typeof t)return t;const n=this.$siteTitle,a=e.frontmatter.home?null:e.frontmatter.title||e.title;return n?a?a+" | "+n:n:a||"VuePress"}get $description(){const e=function(e){if(e){const t=e.filter(e=>"description"===e.name)[0];if(t)return t.content}}(this.$page.frontmatter.meta);return e||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(a.path.toLowerCase()===t.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Es)),Xn.component("Content",Is),Xn.component("ContentSlotsDistributor",zs),Xn.component("OutboundLink",Fs),Xn.component("ClientOnly",Ps),Xn.component("Layout",oo("Layout")),Xn.component("NotFound",oo("NotFound")),Xn.prototype.$withBase=function(e){const t=this.$site.base;return"/"===e.charAt(0)?t+e.slice(1):e},window.__VUEPRESS__={version:"1.9.9",hash:"b91fa13"},async function(e){const t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Es.routerBase||Es.base,n=new ql({base:t,mode:"history",fallback:!1,routes:xs,scrollBehavior:(e,t,n)=>n||(e.hash?!Xn.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(e.hash)}:{x:0,y:0})});!function(e){e.beforeEach((t,n,a)=>{if(Hs(e,t.path))a();else if(/(\/|\.html)$/.test(t.path))if(/\/$/.test(t.path)){const n=t.path.replace(/\/$/,"")+".html";Hs(e,n)?a(n):a()}else a();else{const n=t.path+"/",r=t.path+".html";Hs(e,r)?a(r):Hs(e,n)?a(n):a()}})}(n);const a={};try{await Promise.all(Bs.filter(e=>"function"==typeof e).map(t=>t({Vue:Xn,options:a,router:n,siteData:Es,isServer:e})))}catch(e){console.error(e)}return{app:new Xn(Object.assign(a,{router:n,render:e=>e("div",{attrs:{id:"app"}},[e("RouterView",{ref:"layout"}),e("div",{class:"global-ui"},ks.map(t=>e(t)))])})),router:n}}(!1).then(({app:e,router:t})=>{t.onReady(()=>{e.$mount("#app")})})}]);